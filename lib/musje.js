(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("snapsvg"), require("MIDI"));
	else if(typeof define === 'function' && define.amd)
		define(["snapsvg", "MIDI"], factory);
	else if(typeof exports === 'object')
		exports["musje"] = factory(require("snapsvg"), require("MIDI"));
	else
		root["musje"] = factory(root["Snap"], root["MIDI"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_8__, __WEBPACK_EXTERNAL_MODULE_42__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Score = exports.parse = undefined;
	
	var _parser = __webpack_require__(1);
	
	var _parser2 = _interopRequireDefault(_parser);
	
	var _Score = __webpack_require__(3);
	
	var _Score2 = _interopRequireDefault(_Score);
	
	var _Renderer = __webpack_require__(23);
	
	var _Renderer2 = _interopRequireDefault(_Renderer);
	
	var _util = __webpack_require__(2);
	
	var _PlayerMixin = __webpack_require__(41);
	
	var _PlayerMixin2 = _interopRequireDefault(_PlayerMixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Render the score in jianpu (numbered musical notation).
	 * @member
	 * @function
	 * @param {string} svg
	 * @param {Object} lo - Layout options.
	 */
	_Score2.default.prototype.render = function (svg, lo) {
	  new _Renderer2.default(svg, lo).render(this);
	};
	
	(0, _util.defineProperties)(_Score2.default.prototype, _PlayerMixin2.default);
	
	/**
	 * Parse source musje string to be a Score instance.
	 * @param {string} input - Input of the musje source code.
	 * @return {Score} - A `Score` instance.
	 */
	var parse = exports.parse = function parse(input) {
	  return _parser2.default.parse(input);
	  // var plainScore = parser.parse(input);
	  // return new Score(plainScore);
	};
	
	exports.Score = _Score2.default;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* parser generated by jison 0.4.17 */
	/*
	  Returns a Parser object of the following structure:
	
	  Parser: {
	    yy: {}
	  }
	
	  Parser.prototype: {
	    yy: {},
	    trace: function(),
	    symbols_: {associative list: name ==> number},
	    terminals_: {associative list: number ==> name},
	    productions_: [...],
	    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
	    table: [...],
	    defaultActions: {...},
	    parseError: function(str, hash),
	    parse: function(input),
	
	    lexer: {
	        EOF: 1,
	        parseError: function(str, hash),
	        setInput: function(input),
	        input: function(),
	        unput: function(str),
	        more: function(),
	        less: function(n),
	        pastInput: function(),
	        upcomingInput: function(),
	        showPosition: function(),
	        test_match: function(regex_match_array, rule_index),
	        next: function(),
	        lex: function(),
	        begin: function(condition),
	        popState: function(),
	        _currentRules: function(),
	        topState: function(),
	        pushState: function(condition),
	
	        options: {
	            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
	            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
	            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
	        },
	
	        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
	        rules: [...],
	        conditions: {associative list: name ==> set},
	    }
	  }
	
	
	  token location info (@$, _$, etc.): {
	    first_line: n,
	    last_line: n,
	    first_column: n,
	    last_column: n,
	    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
	  }
	
	
	  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
	    text:        (matched text)
	    token:       (the produced terminal token, if any)
	    line:        (yylineno)
	  }
	  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
	    loc:         (yylloc)
	    expected:    (string describing the set of expected tokens)
	    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
	  }
	*/
	var parser = (function(){
	var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,11],$V1=[1,15],$V2=[1,16],$V3=[1,17],$V4=[1,18],$V5=[1,19],$V6=[1,20],$V7=[1,23],$V8=[1,27],$V9=[1,34],$Va=[1,35],$Vb=[1,33],$Vc=[1,28],$Vd=[1,29],$Ve=[5,9,10,14,21,22,23,24,25,26,29,34,39,41,48,51,58],$Vf=[2,8],$Vg=[5,9,10,21,22,23,24,25,26,29,34,39,41,48,51,58],$Vh=[5,21,22,23,24,25,26],$Vi=[2,47],$Vj=[1,48],$Vk=[1,49],$Vl=[1,50],$Vm=[1,51],$Vn=[1,52],$Vo=[5,9,10,21,22,23,24,25,26,28,29,34,35,39,41,48,51,53,58],$Vp=[5,9,10,21,22,23,24,25,26,28,29,34,35,39,41,43,44,45,46,47,48,51,53,58],$Vq=[5,9,10,21,22,23,24,25,26,28,29,34,35,39,41,43,44,45,46,47,48,50,51,53,58],$Vr=[1,63],$Vs=[1,64],$Vt=[5,21,22,23,24,25,26,29,34,39,41,48,51,58],$Vu=[5,9,10,21,22,23,24,25,26,28,29,34,35,39,41,43,48,51,53,58],$Vv=[5,9,10,21,22,23,24,25,26,28,29,34,39,41,48,51,53,58],$Vw=[39,41,50];
	var parser = {trace: function trace() { },
	yy: {},
	symbols_: {"0":29,"error":2,"e":3,"maybe_musje":4,"EOF":5,"space":6,"maybe_space":7,"musje":8,"S":9,"NL":10,"score_head":11,"part_list":12,"title":13,"TITLE":14,"COMPOSER":15,"part":16,"measure_list":17,"bar":18,"measure":19,"music_data":20,"|":21,"||":22,"|]":23,"|:":24,":|":25,":|:":26,"slurable":27,"TIE":28,"maybe_duration":30,"voice":31,"time_signature":32,"pitchful":33,"(":34,")":35,"note":36,"chord":37,"pitch":38,"STEP":39,"OCTAVE":40,"ACCIDENTAL":41,"type_modifier":42,"DOT":43,"_":44,"=":45,"HALF":46,"WHOLE":47,"<":48,"pitch_list":49,">":50,"{":51,"voice_list":52,"}":53,"voice_data_list":54,":":55,"voice_data":56,"restslurable_list":57,"BEATS":58,"BEAT_TYPE":59,"$accept":0,"$end":1},
	terminals_: {2:"error",5:"EOF",9:"S",10:"NL",14:"TITLE",15:"COMPOSER",21:"|",22:"||",23:"|]",24:"|:",25:":|",26:":|:",28:"TIE",29:"0",34:"(",35:")",39:"STEP",40:"OCTAVE",41:"ACCIDENTAL",43:"DOT",44:"_",45:"=",46:"HALF",47:"WHOLE",48:"<",50:">",51:"{",53:"}",54:"voice_data_list",55:":",57:"restslurable_list",58:"BEATS",59:"BEAT_TYPE"},
	productions_: [0,[3,2],[4,0],[4,2],[4,3],[4,1],[6,1],[6,1],[7,0],[7,2],[7,2],[8,1],[8,1],[8,2],[11,2],[13,1],[13,2],[12,1],[16,1],[16,3],[17,1],[17,4],[17,3],[19,2],[19,3],[18,1],[18,1],[18,1],[18,1],[18,1],[18,1],[20,1],[20,2],[20,2],[20,1],[20,1],[27,2],[27,3],[27,3],[27,4],[33,1],[33,1],[36,1],[38,1],[38,2],[38,2],[38,3],[30,0],[30,1],[30,1],[30,2],[42,1],[42,1],[42,2],[42,2],[42,3],[42,3],[42,1],[42,1],[37,3],[49,1],[49,2],[31,3],[52,1],[52,3],[56,1],[56,2],[32,2]],
	performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
	/* this == yyval */
	
	var $0 = $$.length - 1;
	switch (yystate) {
	case 1:
	 return $$[$0-1]; 
	break;
	case 2: case 3:
	 this.$ = null; 
	break;
	case 4: case 5:
	 this.$ = $$[$0]; removeLastEmptyMeasure($$[$0]); 
	break;
	case 10:
	 this.$ = $$[$0-1] ? $$[$0-1] + 1 : 1; 
	break;
	case 11:
	this.$ = { head: $$[$0] };
	break;
	case 12:
	this.$ = { parts: $$[$0] };
	break;
	case 13:
	this.$ = { head: $$[$0-1], parts: $$[$0] };
	break;
	case 15:
	 this.$ = { title: $$[$0] } 
	break;
	case 16:
	 this.$ =  { title: $$[$0-1], composer: $$[$0] } 
	break;
	case 17: case 60: case 63:
	this.$ = [$$[$0]];
	break;
	case 18:
	this.$ = { measures: $$[$0] };
	break;
	case 19:
	 this.$ = { measures: $$[$0]}; $$[$0][0].data.unshift({ bar: $$[$0-2] }); 
	break;
	case 20:
	 this.$ = [$$[$0]]; 
	break;
	case 21:
	 this.$ = $$[$0-3]; lastItem($$[$0-3]).data.push({ bar: $$[$0-2] }); $$[$0-3].push($$[$0]) 
	break;
	case 22:
	 this.$ = $$[$0-2]; lastItem($$[$0-2]).data.push({ bar: $$[$0-1] }); $$[$0-2].push({ data: [] }) 
	break;
	case 23:
	this.$ = { data: [$$[$0-1]] };
	break;
	case 24:
	 this.$ = $$[$0-2]; $$[$0-2].data.push($$[$0-1]) 
	break;
	case 25:
	this.$ = 'single';
	break;
	case 26:
	this.$ = 'double';
	break;
	case 27:
	this.$ = 'end';
	break;
	case 28:
	this.$ = 'repeat-begin';
	break;
	case 29:
	this.$ = 'repeat-end';
	break;
	case 30:
	this.$ = 'repeat-both';
	break;
	case 32:
	 this.$ = $$[$0-1]; onlyProperty($$[$0-1]).tie = '~' 
	break;
	case 33:
	this.$ = { rest: { duration: $$[$0] } };
	break;
	case 34:
	this.$ = { voice: $$[$0] };
	break;
	case 36:
	 this.$ = $$[$0-1]; onlyProperty($$[$0-1]).duration = $$[$0] 
	break;
	case 37:
	
	      this.$ = $$[$0-1];
	      extend(onlyProperty($$[$0-1]), {
	        duration: $$[$0],
	        slur: { begin: 'solid' }
	      })
	    
	break;
	case 38:
	
	      this.$ = $$[$0-2]
	      extend(onlyProperty($$[$0-2]), {
	        duration: $$[$0-1],
	        slur: { end: 'solid' }
	      })
	    
	break;
	case 39:
	
	      this.$ = $$[$0-2]
	      extend(onlyProperty($$[$0-2]), {
	        duration: $$[$0-1],
	        slur: { begin: 'solid', end: 'solid' }
	      })
	    
	break;
	case 40:
	this.$ = { note: $$[$0] };
	break;
	case 41:
	this.$ = { chord: $$[$0] };
	break;
	case 42:
	this.$ = { pitch: $$[$0] };
	break;
	case 43:
	this.$ = { step: +$$[$0] };
	break;
	case 44:
	this.$ = { step: +$$[$0-1], octave: octave($$[$0]) };
	break;
	case 45:
	this.$ = { accidental: $$[$0-1], step: +$$[$0] };
	break;
	case 46:
	this.$ = { accidental: $$[$0-2], step: +$$[$0-1], octave: octave($$[$0]) };
	break;
	case 48:
	this.$ = { type: $$[$0] };
	break;
	case 49:
	this.$ = { type: 4, dot: $$[$0].length };
	break;
	case 50:
	this.$ = { type: $$[$0-1], dot: $$[$0].length };
	break;
	case 51:
	this.$ = 8;
	break;
	case 52:
	this.$ = 16;
	break;
	case 53:
	this.$ = 32;
	break;
	case 54:
	this.$ = 64;
	break;
	case 55:
	this.$ = 128;
	break;
	case 56:
	this.$ = 256;
	break;
	case 57:
	this.$ = 2;
	break;
	case 58:
	this.$ = 1;
	break;
	case 59:
	this.$ = { pitches: $$[$0-1] };
	break;
	case 61: case 66:
	 this.$ = $$[$0-1]; $$[$0-1].push($$[$0]) 
	break;
	case 62:
	this.$ = $$[$0-1];
	break;
	case 64:
	 this.$ = $$[$0-2]; $$[$0-2].push($$[$0-1]) 
	break;
	case 67:
	this.$ = { time: { beats: +$$[$0-1], beatType: +$$[$0] } };
	break;
	}
	},
	table: [{3:1,4:2,5:[2,2],6:3,8:4,9:[1,5],10:[1,6],11:7,12:8,13:9,14:$V0,16:10,17:12,18:13,19:14,20:21,21:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6,27:22,29:$V7,31:24,32:25,33:26,34:$V8,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd},{1:[3]},{5:[1,36]},o($Ve,$Vf,{7:37}),{5:[2,5]},o($Ve,[2,6]),o($Ve,[2,7]),{5:[2,11],12:38,16:10,17:12,18:13,19:14,20:21,21:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6,27:22,29:$V7,31:24,32:25,33:26,34:$V8,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd},{5:[2,12]},o($Vg,$Vf,{7:39}),{5:[2,17]},o($Vg,[2,15],{15:[1,40]}),{5:[2,18],18:41,21:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6},o([9,10,29,34,39,41,48,51,58],$Vf,{7:42}),o($Vh,[2,20],{27:22,31:24,32:25,33:26,36:30,37:31,38:32,20:43,29:$V7,34:$V8,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd}),o($Vg,[2,25]),o($Vg,[2,26]),o($Vg,[2,27]),o($Vg,[2,28]),o($Vg,[2,29]),o($Vg,[2,30]),o($Vg,$Vf,{7:44}),o($Vg,[2,31],{28:[1,45]}),o($Vg,$Vi,{30:46,42:47,43:$Vj,44:$Vk,45:$Vl,46:$Vm,47:$Vn}),o($Vg,[2,34]),o($Vg,[2,35]),o($Vo,$Vi,{42:47,30:53,43:$Vj,44:$Vk,45:$Vl,46:$Vm,47:$Vn}),{33:54,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb},{52:55,54:[1,56]},{59:[1,57]},o($Vp,[2,40]),o($Vp,[2,41]),o($Vp,[2,42]),{38:59,39:$V9,41:$Va,49:58},o($Vq,[2,43],{40:[1,60]}),{39:[1,61]},{1:[2,1]},{5:[2,3],8:62,9:$Vr,10:$Vs,11:7,12:8,13:9,14:$V0,16:10,17:12,18:13,19:14,20:21,21:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6,27:22,29:$V7,31:24,32:25,33:26,34:$V8,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd},{5:[2,13]},o($Vt,[2,14],{9:$Vr,10:$Vs}),o($Vg,[2,16]),o($Vg,$Vf,{7:65}),{9:$Vr,10:$Vs,17:66,19:14,20:21,27:22,29:$V7,31:24,32:25,33:26,34:$V8,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd},o($Vg,$Vf,{7:67}),o($Vt,[2,23],{9:$Vr,10:$Vs}),o($Vg,[2,32]),o($Vg,[2,33]),o($Vo,[2,48],{43:[1,68]}),o($Vo,[2,49]),o($Vu,[2,51]),o($Vu,[2,52],{44:[1,69],45:[1,70]}),o($Vu,[2,57]),o($Vu,[2,58]),o($Vv,[2,36],{35:[1,71]}),o($Vo,$Vi,{42:47,30:72,43:$Vj,44:$Vk,45:$Vl,46:$Vm,47:$Vn}),{53:[1,73]},{53:[2,63],55:[1,74]},o($Vg,[2,67]),{38:76,39:$V9,41:$Va,50:[1,75]},o($Vw,[2,60]),o($Vq,[2,44]),o($Vq,[2,45],{40:[1,77]}),{5:[2,4]},o($Ve,[2,9]),o($Ve,[2,10]),o($Vh,[2,22],{20:21,27:22,31:24,32:25,33:26,36:30,37:31,38:32,19:78,9:$Vr,10:$Vs,29:$V7,34:$V8,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd}),{5:[2,19],18:41,21:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6},o($Vt,[2,24],{9:$Vr,10:$Vs}),o($Vo,[2,50]),o($Vu,[2,53]),o($Vu,[2,54],{44:[1,79],45:[1,80]}),o($Vv,[2,38]),o($Vv,[2,37],{35:[1,81]}),o($Vg,[2,62]),{27:83,33:26,34:$V8,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb,56:82,57:[1,84]},o($Vp,[2,59]),o($Vw,[2,61]),o($Vq,[2,46]),o($Vh,[2,21],{27:22,31:24,32:25,33:26,36:30,37:31,38:32,20:43,29:$V7,34:$V8,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd}),o($Vu,[2,55]),o($Vu,[2,56]),o($Vv,[2,39]),{53:[2,64]},{53:[2,65]},{27:85,33:26,34:$V8,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb},{53:[2,66]}],
	defaultActions: {4:[2,5],8:[2,12],10:[2,17],36:[2,1],38:[2,13],62:[2,4],82:[2,64],83:[2,65],85:[2,66]},
	parseError: function parseError(str, hash) {
	    if (hash.recoverable) {
	        this.trace(str);
	    } else {
	        function _parseError (msg, hash) {
	            this.message = msg;
	            this.hash = hash;
	        }
	        _parseError.prototype = Error;
	
	        throw new _parseError(str, hash);
	    }
	},
	parse: function parse(input) {
	    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
	    var args = lstack.slice.call(arguments, 1);
	    var lexer = Object.create(this.lexer);
	    var sharedState = { yy: {} };
	    for (var k in this.yy) {
	        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
	            sharedState.yy[k] = this.yy[k];
	        }
	    }
	    lexer.setInput(input, sharedState.yy);
	    sharedState.yy.lexer = lexer;
	    sharedState.yy.parser = this;
	    if (typeof lexer.yylloc == 'undefined') {
	        lexer.yylloc = {};
	    }
	    var yyloc = lexer.yylloc;
	    lstack.push(yyloc);
	    var ranges = lexer.options && lexer.options.ranges;
	    if (typeof sharedState.yy.parseError === 'function') {
	        this.parseError = sharedState.yy.parseError;
	    } else {
	        this.parseError = Object.getPrototypeOf(this).parseError;
	    }
	    function popStack(n) {
	        stack.length = stack.length - 2 * n;
	        vstack.length = vstack.length - n;
	        lstack.length = lstack.length - n;
	    }
	    _token_stack:
	        var lex = function () {
	            var token;
	            token = lexer.lex() || EOF;
	            if (typeof token !== 'number') {
	                token = self.symbols_[token] || token;
	            }
	            return token;
	        };
	    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
	    while (true) {
	        state = stack[stack.length - 1];
	        if (this.defaultActions[state]) {
	            action = this.defaultActions[state];
	        } else {
	            if (symbol === null || typeof symbol == 'undefined') {
	                symbol = lex();
	            }
	            action = table[state] && table[state][symbol];
	        }
	                    if (typeof action === 'undefined' || !action.length || !action[0]) {
	                var errStr = '';
	                expected = [];
	                for (p in table[state]) {
	                    if (this.terminals_[p] && p > TERROR) {
	                        expected.push('\'' + this.terminals_[p] + '\'');
	                    }
	                }
	                if (lexer.showPosition) {
	                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
	                } else {
	                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
	                }
	                this.parseError(errStr, {
	                    text: lexer.match,
	                    token: this.terminals_[symbol] || symbol,
	                    line: lexer.yylineno,
	                    loc: yyloc,
	                    expected: expected
	                });
	            }
	        if (action[0] instanceof Array && action.length > 1) {
	            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
	        }
	        switch (action[0]) {
	        case 1:
	            stack.push(symbol);
	            vstack.push(lexer.yytext);
	            lstack.push(lexer.yylloc);
	            stack.push(action[1]);
	            symbol = null;
	            if (!preErrorSymbol) {
	                yyleng = lexer.yyleng;
	                yytext = lexer.yytext;
	                yylineno = lexer.yylineno;
	                yyloc = lexer.yylloc;
	                if (recovering > 0) {
	                    recovering--;
	                }
	            } else {
	                symbol = preErrorSymbol;
	                preErrorSymbol = null;
	            }
	            break;
	        case 2:
	            len = this.productions_[action[1]][1];
	            yyval.$ = vstack[vstack.length - len];
	            yyval._$ = {
	                first_line: lstack[lstack.length - (len || 1)].first_line,
	                last_line: lstack[lstack.length - 1].last_line,
	                first_column: lstack[lstack.length - (len || 1)].first_column,
	                last_column: lstack[lstack.length - 1].last_column
	            };
	            if (ranges) {
	                yyval._$.range = [
	                    lstack[lstack.length - (len || 1)].range[0],
	                    lstack[lstack.length - 1].range[1]
	                ];
	            }
	            r = this.performAction.apply(yyval, [
	                yytext,
	                yyleng,
	                yylineno,
	                sharedState.yy,
	                action[1],
	                vstack,
	                lstack
	            ].concat(args));
	            if (typeof r !== 'undefined') {
	                return r;
	            }
	            if (len) {
	                stack = stack.slice(0, -1 * len * 2);
	                vstack = vstack.slice(0, -1 * len);
	                lstack = lstack.slice(0, -1 * len);
	            }
	            stack.push(this.productions_[action[1]][0]);
	            vstack.push(yyval.$);
	            lstack.push(yyval._$);
	            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
	            stack.push(newState);
	            break;
	        case 3:
	            return true;
	        }
	    }
	    return true;
	}};
	
	
	const extend = __webpack_require__(2).extend
	
	const lastItem = arr => arr[arr.length - 1]
	
	const onlyProperty = obj => obj[Object.keys(obj)[0]]
	
	const octave = str => {
	  const len = str.length
	  return str.charAt(0) === ',' ? -len : len
	}
	
	const removeLastEmptyMeasure = score => {
	  const parts = score.parts
	  if (!parts) return
	
	  parts.forEach(part => {
	    const lastMeasure = lastItem(part.measures)
	    if (lastMeasure.data.length === 0) part.measures.pop()
	  })
	}
	
	/* generated by jison-lex 0.3.4 */
	var lexer = (function(){
	var lexer = ({
	
	EOF:1,
	
	parseError:function parseError(str, hash) {
	        if (this.yy.parser) {
	            this.yy.parser.parseError(str, hash);
	        } else {
	            throw new Error(str);
	        }
	    },
	
	// resets the lexer, sets new input
	setInput:function (input, yy) {
	        this.yy = yy || this.yy || {};
	        this._input = input;
	        this._more = this._backtrack = this.done = false;
	        this.yylineno = this.yyleng = 0;
	        this.yytext = this.matched = this.match = '';
	        this.conditionStack = ['INITIAL'];
	        this.yylloc = {
	            first_line: 1,
	            first_column: 0,
	            last_line: 1,
	            last_column: 0
	        };
	        if (this.options.ranges) {
	            this.yylloc.range = [0,0];
	        }
	        this.offset = 0;
	        return this;
	    },
	
	// consumes and returns one char from the input
	input:function () {
	        var ch = this._input[0];
	        this.yytext += ch;
	        this.yyleng++;
	        this.offset++;
	        this.match += ch;
	        this.matched += ch;
	        var lines = ch.match(/(?:\r\n?|\n).*/g);
	        if (lines) {
	            this.yylineno++;
	            this.yylloc.last_line++;
	        } else {
	            this.yylloc.last_column++;
	        }
	        if (this.options.ranges) {
	            this.yylloc.range[1]++;
	        }
	
	        this._input = this._input.slice(1);
	        return ch;
	    },
	
	// unshifts one char (or a string) into the input
	unput:function (ch) {
	        var len = ch.length;
	        var lines = ch.split(/(?:\r\n?|\n)/g);
	
	        this._input = ch + this._input;
	        this.yytext = this.yytext.substr(0, this.yytext.length - len);
	        //this.yyleng -= len;
	        this.offset -= len;
	        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
	        this.match = this.match.substr(0, this.match.length - 1);
	        this.matched = this.matched.substr(0, this.matched.length - 1);
	
	        if (lines.length - 1) {
	            this.yylineno -= lines.length - 1;
	        }
	        var r = this.yylloc.range;
	
	        this.yylloc = {
	            first_line: this.yylloc.first_line,
	            last_line: this.yylineno + 1,
	            first_column: this.yylloc.first_column,
	            last_column: lines ?
	                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
	                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
	              this.yylloc.first_column - len
	        };
	
	        if (this.options.ranges) {
	            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
	        }
	        this.yyleng = this.yytext.length;
	        return this;
	    },
	
	// When called from action, caches matched text and appends it on next action
	more:function () {
	        this._more = true;
	        return this;
	    },
	
	// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
	reject:function () {
	        if (this.options.backtrack_lexer) {
	            this._backtrack = true;
	        } else {
	            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
	                text: "",
	                token: null,
	                line: this.yylineno
	            });
	
	        }
	        return this;
	    },
	
	// retain first n characters of the match
	less:function (n) {
	        this.unput(this.match.slice(n));
	    },
	
	// displays already matched input, i.e. for error messages
	pastInput:function () {
	        var past = this.matched.substr(0, this.matched.length - this.match.length);
	        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
	    },
	
	// displays upcoming input, i.e. for error messages
	upcomingInput:function () {
	        var next = this.match;
	        if (next.length < 20) {
	            next += this._input.substr(0, 20-next.length);
	        }
	        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
	    },
	
	// displays the character position where the lexing error occurred, i.e. for error messages
	showPosition:function () {
	        var pre = this.pastInput();
	        var c = new Array(pre.length + 1).join("-");
	        return pre + this.upcomingInput() + "\n" + c + "^";
	    },
	
	// test the lexed token: return FALSE when not a match, otherwise return token
	test_match:function (match, indexed_rule) {
	        var token,
	            lines,
	            backup;
	
	        if (this.options.backtrack_lexer) {
	            // save context
	            backup = {
	                yylineno: this.yylineno,
	                yylloc: {
	                    first_line: this.yylloc.first_line,
	                    last_line: this.last_line,
	                    first_column: this.yylloc.first_column,
	                    last_column: this.yylloc.last_column
	                },
	                yytext: this.yytext,
	                match: this.match,
	                matches: this.matches,
	                matched: this.matched,
	                yyleng: this.yyleng,
	                offset: this.offset,
	                _more: this._more,
	                _input: this._input,
	                yy: this.yy,
	                conditionStack: this.conditionStack.slice(0),
	                done: this.done
	            };
	            if (this.options.ranges) {
	                backup.yylloc.range = this.yylloc.range.slice(0);
	            }
	        }
	
	        lines = match[0].match(/(?:\r\n?|\n).*/g);
	        if (lines) {
	            this.yylineno += lines.length;
	        }
	        this.yylloc = {
	            first_line: this.yylloc.last_line,
	            last_line: this.yylineno + 1,
	            first_column: this.yylloc.last_column,
	            last_column: lines ?
	                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
	                         this.yylloc.last_column + match[0].length
	        };
	        this.yytext += match[0];
	        this.match += match[0];
	        this.matches = match;
	        this.yyleng = this.yytext.length;
	        if (this.options.ranges) {
	            this.yylloc.range = [this.offset, this.offset += this.yyleng];
	        }
	        this._more = false;
	        this._backtrack = false;
	        this._input = this._input.slice(match[0].length);
	        this.matched += match[0];
	        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
	        if (this.done && this._input) {
	            this.done = false;
	        }
	        if (token) {
	            return token;
	        } else if (this._backtrack) {
	            // recover context
	            for (var k in backup) {
	                this[k] = backup[k];
	            }
	            return false; // rule action called reject() implying the next rule should be tested instead.
	        }
	        return false;
	    },
	
	// return next match in input
	next:function () {
	        if (this.done) {
	            return this.EOF;
	        }
	        if (!this._input) {
	            this.done = true;
	        }
	
	        var token,
	            match,
	            tempMatch,
	            index;
	        if (!this._more) {
	            this.yytext = '';
	            this.match = '';
	        }
	        var rules = this._currentRules();
	        for (var i = 0; i < rules.length; i++) {
	            tempMatch = this._input.match(this.rules[rules[i]]);
	            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
	                match = tempMatch;
	                index = i;
	                if (this.options.backtrack_lexer) {
	                    token = this.test_match(tempMatch, rules[i]);
	                    if (token !== false) {
	                        return token;
	                    } else if (this._backtrack) {
	                        match = false;
	                        continue; // rule action called reject() implying a rule MISmatch.
	                    } else {
	                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
	                        return false;
	                    }
	                } else if (!this.options.flex) {
	                    break;
	                }
	            }
	        }
	        if (match) {
	            token = this.test_match(match, rules[index]);
	            if (token !== false) {
	                return token;
	            }
	            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
	            return false;
	        }
	        if (this._input === "") {
	            return this.EOF;
	        } else {
	            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
	                text: "",
	                token: null,
	                line: this.yylineno
	            });
	        }
	    },
	
	// return next match that has a token
	lex:function lex() {
	        var r = this.next();
	        if (r) {
	            return r;
	        } else {
	            return this.lex();
	        }
	    },
	
	// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
	begin:function begin(condition) {
	        this.conditionStack.push(condition);
	    },
	
	// pop the previously active lexer condition state off the condition stack
	popState:function popState() {
	        var n = this.conditionStack.length - 1;
	        if (n > 0) {
	            return this.conditionStack.pop();
	        } else {
	            return this.conditionStack[0];
	        }
	    },
	
	// produce the lexer rule set which is active for the currently active lexer condition state
	_currentRules:function _currentRules() {
	        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
	            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
	        } else {
	            return this.conditions["INITIAL"].rules;
	        }
	    },
	
	// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
	topState:function topState(n) {
	        n = this.conditionStack.length - 1 - Math.abs(n || 0);
	        if (n >= 0) {
	            return this.conditionStack[n];
	        } else {
	            return "INITIAL";
	        }
	    },
	
	// alias for begin(condition)
	pushState:function pushState(condition) {
	        this.begin(condition);
	    },
	
	// return the number of states currently on the stack
	stateStackSize:function stateStackSize() {
	        return this.conditionStack.length;
	    },
	options: {},
	performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
	var YYSTATE=YY_START;
	switch($avoiding_name_collisions) {
	case 0:return 9
	break;
	case 1:return 9
	break;
	case 2:return 9
	break;
	case 3: this.begin('title') 
	break;
	case 4: yy_.yytext = yy_.yytext.substr(0, yy_.yyleng - 2).trim()
	                          return 14 
	break;
	case 5: this.begin('INITIAL') 
	break;
	case 6: this.begin('INITIAL')
	                          yy_.yytext = yy_.yytext.trim()
	                          return 15 
	break;
	case 7: this.begin('time')
	                          yy_.yytext = yy_.yytext.substr(0, yy_.yyleng - 1)
	                          return 58 
	break;
	case 8: this.begin('INITIAL'); return 59 
	break;
	case 9:return 41
	break;
	case 10:return 39
	break;
	case 11:return 40
	break;
	case 12:return 43
	break;
	case 13:return 47
	break;
	case 14:return 46
	break;
	case 15:return 28
	break;
	case 16:return 44
	break;
	case 17:return 45
	break;
	case 18:return '.'
	break;
	case 19:return 29
	break;
	case 20:return 48
	break;
	case 21:return 50
	break;
	case 22:return 34
	break;
	case 23:return 35
	break;
	case 24:return '/'
	break;
	case 25:return '\\'
	break;
	case 26:return 23
	break;
	case 27:return 22
	break;
	case 28:return '[|'
	break;
	case 29:return 24
	break;
	case 30:return 26
	break;
	case 31:return 25
	break;
	case 32:return 21
	break;
	case 33:return 51
	break;
	case 34:return 53
	break;
	case 35:return 55
	break;
	case 36:return 10
	break;
	case 37:return 9
	break;
	case 38:return 5
	break;
	case 39:return 'INVALID'
	break;
	}
	},
	rules: [/^(?:\/\/[^\n]*)/,/^(?:\/\*([\s\S]*?)\*\/)/,/^(?:\/\*[\s\S]*)/,/^(?:<<)/,/^(?:.*>>)/,/^(?:([ \t])*([\n\r]))/,/^(?:.*)/,/^(?:(([1-9]\d{0,2})\/))/,/^(?:([1-9]\d{0,2})[^\d])/,/^(?:(#{1,2}|n|b{1,2}))/,/^(?:[1-7])/,/^(?:,+|'+)/,/^(?:\.+)/,/^(?:( *- *){3})/,/^(?:( *- *))/,/^(?: *~)/,/^(?:[_])/,/^(?:=)/,/^(?:\.)/,/^(?:[0])/,/^(?:<)/,/^(?:>)/,/^(?:\()/,/^(?:\))/,/^(?:\/)/,/^(?:\\)/,/^(?:\|\])/,/^(?:\|\|)/,/^(?:\[\|)/,/^(?:\|:)/,/^(?::\|:)/,/^(?::\|)/,/^(?:\|)/,/^(?:\{)/,/^(?:\})/,/^(?::)/,/^(?:([\n\r]))/,/^(?:([ \t]))/,/^(?:$)/,/^(?:.)/],
	conditions: {"time":{"rules":[8],"inclusive":false},"title":{"rules":[4,5,6],"inclusive":false},"INITIAL":{"rules":[0,1,2,3,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39],"inclusive":true}}
	});
	return lexer;
	})();
	parser.lexer = lexer;
	function Parser () {
	  this.yy = {};
	}
	Parser.prototype = parser;parser.Parser = Parser;
	return new Parser;
	})();
	module.exports = parser

/***/ },
/* 2 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var IS_OBJECT = { 'funtion': true, 'object': true };
	var isObject = function isObject(obj) {
	  return IS_OBJECT[typeof obj === 'undefined' ? 'undefined' : _typeof(obj)] && !!obj;
	};
	
	var objEach = exports.objEach = function objEach(obj, callback) {
	  if (isObject(obj)) {
	    Object.keys(obj).forEach(function (key) {
	      callback(obj[key], key);
	    });
	  }
	};
	
	var extend = exports.extend = function extend(obj, ext) {
	  objEach(ext, function (val, key) {
	    obj[key] = val;
	  });
	  return obj;
	};
	
	var near = exports.near = function near(a, b) {
	  return Math.abs(a - b) < 0.00001;
	};
	
	var isAccessorProperty = function isAccessorProperty(value) {
	  return isObject(value) && (typeof value.get === 'function' || typeof value.set === 'function');
	};
	
	/**
	 * Define ES5 getter/setter properties
	 * @param {Object} obj - The object to be defined.
	 * @param {Object} props - ES5 getter/setter properties.
	 * For example:
	 * ```
	 * {
	 *   name: {
	 *     get: function () {...},
	 *     set: function () {...}
	 *   },
	 *   age: {
	 *      get:...
	 *   }
	 * }
	 * ```
	 */
	var defineProperties = exports.defineProperties = function defineProperties(obj, props) {
	  objEach(props, function (value, prop) {
	    var descriptor;
	    if (isAccessorProperty(value)) {
	      descriptor = value;
	    } else if (typeof value === 'function') {
	      descriptor = { value: value };
	    } else if (isObject(value) && value.constant) {
	      descriptor = { value: value.constant };
	    } else {
	      descriptor = {
	        value: value,
	        writable: true,
	        enumerable: true
	      };
	    }
	    Object.defineProperty(obj, prop, descriptor);
	  });
	};
	
	var toJSONWithDefault = true;
	
	var makeToJSON = exports.makeToJSON = function makeToJSON(values, elName) {
	  return function () {
	    var _this = this;
	
	    if (this.isEmpty) return;
	
	    var result = {};
	
	    objEach(values, function (defaultValue, prop) {
	      if (toJSONWithDefault || _this[prop] !== defaultValue) {
	        result[prop] = _this[prop];
	      }
	    });
	    if (!elName) return result;
	
	    var res = {};
	    res[elName] = result;
	    return res;
	  };
	};

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	var _ScoreHead = __webpack_require__(4);
	
	var _ScoreHead2 = _interopRequireDefault(_ScoreHead);
	
	var _PartwiseParts = __webpack_require__(5);
	
	var _PartwiseParts2 = _interopRequireDefault(_PartwiseParts);
	
	var _TimewiseMeasures = __webpack_require__(21);
	
	var _TimewiseMeasures2 = _interopRequireDefault(_TimewiseMeasures);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @param {Object} score - plain score object.
	 * @mixes PlayerMixin
	 */
	var Score = function () {
	  function Score(score) {
	    _classCallCheck(this, Score);
	
	    this.toJSON = (0, _util.makeToJSON)({
	      head: undefined,
	      parts: undefined
	    });
	
	    (0, _util.extend)(this, score);
	  }
	
	  /**
	   * Head of the score.
	   * @type {ScoreHead}
	   */
	
	
	  _createClass(Score, [{
	    key: 'walkCells',
	
	
	    /**
	     * A cell is identically a measure in a part or a part in a measure.
	     * @param {Function}
	     */
	    value: function walkCells(callback) {
	      this.parts.forEach(function (part, p) {
	        part.measures.forEach(function (cell, m) {
	          callback(cell, m, p);
	        });
	      });
	    }
	
	    /**
	     * Walk each music data.
	     * @param {Function} callback
	     */
	
	  }, {
	    key: 'walkMusicData',
	    value: function walkMusicData(callback) {
	      this.walkCells(function (cell, m, p) {
	        cell.data.forEach(function (data, d) {
	          callback(data, d, m, p);
	        });
	      });
	    }
	
	    /**
	     * Convert score to string.
	     * @return {string} Musje source code.
	     */
	
	  }, {
	    key: 'toString',
	    value: function toString() {
	      return this.head + this.parts.map(function (part) {
	        return part.toString();
	      }).join('\n\n');
	    }
	
	    /**
	     * Custom toJSON method.
	     * @method
	     * @return {Object}
	     */
	
	  }, {
	    key: 'head',
	    get: function get() {
	      return this._head || (this._head = new _ScoreHead2.default());
	    },
	    set: function set(head) {
	      this._head = new _ScoreHead2.default(head);
	    }
	
	    /**
	     * Partwise parts.
	     * - (Getter)
	     * - (Setter)
	     * @type {PartwiseParts}
	     */
	
	  }, {
	    key: 'parts',
	    get: function get() {
	      return this._parts || (this._parts = new _PartwiseParts2.default(this));
	    },
	    set: function set(parts) {
	      this.parts.removeAll();
	      this.parts.addParts(parts);
	      this.measures.fromPartwise();
	    }
	
	    /**
	     * Timewise measures, generated by the initialize function.
	     * @type {TimewiseMeasures}
	     * @readonly
	     */
	
	  }, {
	    key: 'measures',
	    get: function get() {
	      return this._measures || (this._measures = new _TimewiseMeasures2.default(this));
	    }
	  }]);
	
	  return Score;
	}();
	
	exports.default = Score;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Construct head of the score.
	 * @class
	 * @param {Object} head
	 */
	var ScoreHead = function () {
	  function ScoreHead(head) {
	    _classCallCheck(this, ScoreHead);
	
	    this.title = '';
	    this.subtitle = '';
	    this.subsubtitle = '';
	    this.composer = undefined;
	    this.arranger = undefined;
	    this.lyricist = undefined;
	    this.toJSON = (0, _util.makeToJSON)({
	      title: undefined,
	      subtitle: undefined,
	      subsubtitle: undefined,
	      composer: undefined,
	      lyricist: undefined
	    });
	
	    (0, _util.extend)(this, head);
	  }
	
	  /**
	   * Title of the score.
	   * @type {string}
	   * @default ''
	   */
	
	
	  /**
	   * Subtitle of the score.
	   * @type {string}
	   * @default ''
	   */
	
	
	  /**
	   * Subsubtitle of the score.
	   * @type {string}
	   * @default ''
	   */
	
	
	  /**
	   * Composer of the score.
	   * @type {string}
	   */
	
	
	  /**
	   * Arranger of the score.
	   * @type {string}
	   */
	
	
	  /**
	   * Lyricist of the score.
	   * @type {string}
	   */
	
	
	  _createClass(ScoreHead, [{
	    key: 'toString',
	
	
	    /**
	     * Convert score head to string.
	     * @return {string} The converted musje head source code.
	     */
	    value: function toString() {
	      var title = this.title ? '<<' + this.title + '>>' : '';
	      return title + ' ' + (this.composer || '') + '\n';
	    }
	  }, {
	    key: 'isEmpty',
	
	
	    /**
	     * Check if the score head is empty.
	     * @type {boolean}
	     * @readonly
	     */
	    get: function get() {
	      return !this.title && !this.subtitle && !this.subsubtitle && !this.composer && !this.arranger && !this.lyricist;
	    }
	  }]);
	
	  return ScoreHead;
	}();
	
	exports.default = ScoreHead;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _PartwisePart = __webpack_require__(6);
	
	var _PartwisePart2 = _interopRequireDefault(_PartwisePart);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _extendableBuiltin(cls) {
	  function ExtendableBuiltin() {
	    cls.apply(this, arguments);
	  }
	
	  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
	    constructor: {
	      value: cls,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	
	  if (Object.setPrototypeOf) {
	    Object.setPrototypeOf(ExtendableBuiltin, cls);
	  } else {
	    ExtendableBuiltin.__proto__ = cls;
	  }
	
	  return ExtendableBuiltin;
	}
	
	var PartwiseParts = function (_extendableBuiltin2) {
	  _inherits(PartwiseParts, _extendableBuiltin2);
	
	  function PartwiseParts(score) {
	    _classCallCheck(this, PartwiseParts);
	
	    var _this = _possibleConstructorReturn(this, (PartwiseParts.__proto__ || Object.getPrototypeOf(PartwiseParts)).call(this));
	
	    _this._score = score;
	    return _this;
	  }
	
	  /**
	   * Reference to the parent score.
	   * @type {Score}
	   * @readonly
	   */
	
	
	  _createClass(PartwiseParts, [{
	    key: 'addParts',
	
	
	    /**
	     * Add parts.
	     * @param {Object}
	     */
	    value: function addParts(parts) {
	      var _this2 = this;
	
	      parts.forEach(function (part) {
	        _this2.append(part);
	      });
	    }
	
	    /**
	     * Append a partwise part.
	     * @param {Object} part - Plain partwise part object.
	     * @override
	     */
	
	  }, {
	    key: 'append',
	    value: function append(part) {
	      var index = this.length;
	      var musjePart = new _PartwisePart2.default(index, this);
	      this.push(musjePart);
	      musjePart.measures = part.measures;
	    }
	
	    /**
	     * Remove all parts.
	     */
	
	  }, {
	    key: 'removeAll',
	    value: function removeAll() {
	      this.length = 0;
	    }
	  }, {
	    key: 'score',
	    get: function get() {
	      return this._score;
	    }
	  }]);
	
	  return PartwiseParts;
	}(_extendableBuiltin(Array));
	
	exports.default = PartwiseParts;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	var _Cell = __webpack_require__(7);
	
	var _Cell2 = _interopRequireDefault(_Cell);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @class
	 * @param part {Object}
	 * @param index {number} - Index of this part in the parts.
	 * @param parts {PartwiseParts}
	 */
	var PartwisePart = function () {
	  function PartwisePart(index, parts) {
	    _classCallCheck(this, PartwisePart);
	
	    this.toJSON = (0, _util.makeToJSON)({
	      measures: undefined
	    });
	
	    this._index = index;
	    this._parts = parts;
	  }
	
	  // head: { $ref: '#/objects/PartHead' },
	
	  /**
	   * Reference to the parent parts instance.
	   * @type {PartwiseParts}
	   * @readonly
	   */
	
	
	  _createClass(PartwisePart, [{
	    key: 'toString',
	
	
	    /**
	     * Convert a partwise part to sting.
	     * @return {string} Musje partwise part source code.
	     */
	    value: function toString() {
	      return this.measures.map(function (cell) {
	        return cell;
	      }).join(' ');
	    }
	
	    /**
	     * Custom toJSON method.
	     * @return {Object}
	     */
	
	  }, {
	    key: 'parts',
	    get: function get() {
	      return this._parts;
	    }
	
	    /**
	     * Measure in a partwise part is cells.
	     * @type {Array.<Cell>}
	     */
	
	  }, {
	    key: 'measures',
	    get: function get() {
	      return this._measures || (this._measures = []);
	    },
	    set: function set(measures) {
	      var p = this._index;
	      var score = this.parts.score;
	
	      var mea = this._measures = [];
	      measures.forEach(function (cell, m) {
	        mea.push(new _Cell2.default(cell, m, p, score));
	      });
	    }
	  }]);
	
	  return PartwisePart;
	}();
	
	exports.default = PartwisePart;

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _snapsvg = __webpack_require__(8);
	
	var _Time = __webpack_require__(9);
	
	var _Time2 = _interopRequireDefault(_Time);
	
	var _Bar = __webpack_require__(11);
	
	var _Bar2 = _interopRequireDefault(_Bar);
	
	var _Note = __webpack_require__(12);
	
	var _Note2 = _interopRequireDefault(_Note);
	
	var _Rest = __webpack_require__(17);
	
	var _Rest2 = _interopRequireDefault(_Rest);
	
	var _Chord = __webpack_require__(18);
	
	var _Chord2 = _interopRequireDefault(_Chord);
	
	var _Voice = __webpack_require__(19);
	
	var _Voice2 = _interopRequireDefault(_Voice);
	
	var _Beam = __webpack_require__(20);
	
	var _Beam2 = _interopRequireDefault(_Beam);
	
	var _util = __webpack_require__(2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Classes = { time: _Time2.default, bar: _Bar2.default, note: _Note2.default, rest: _Rest2.default, chord: _Chord2.default, voice: _Voice2.default };
	var Bar = _Bar2.default;
	
	/**
	 * Cell is either a measure in a partwise part, or
	 * a part in a timewise measure.
	 * @param cell {Object}
	 * @param mIndex {number} - Measure index of this cell.
	 * @param pIndex {number} - Part index of this cell.
	 */
	
	var Cell = function () {
	  function Cell(cell, mIndex, pIndex, score) {
	    _classCallCheck(this, Cell);
	
	    this.toJSON = (0, _util.makeToJSON)({
	      data: undefined
	    });
	
	    this._mIndex = mIndex;
	    this._pIndex = pIndex;
	    this._score = score;
	    (0, _util.extend)(this, cell);
	    makeBeams(this, 1);
	  }
	
	  /**
	   * Reference to the root score instance.
	   * @type {Score}
	   * @readonly
	   */
	
	
	  _createClass(Cell, [{
	    key: 'append',
	
	
	    /**
	     * Append a music data to the cell.
	     * @param  {Object} musicData - Music data
	     */
	    value: function append(musicData) {
	      var type = Object.keys(musicData)[0]; // musicData has only one key
	      var instance = new Classes[type](musicData[type]);
	      instance._cell = this;
	      instance._index = this.data.length;
	      this.data.push(instance);
	    }
	
	    /**
	     * Width
	     * - (Getter) Get the cell width.
	     * - (Setter) Set the cell width, and this will cause the cell to reflow.
	     * @type {number}
	     */
	
	  }, {
	    key: 'flow',
	
	
	    /**
	     * Flow the cell.
	     */
	    value: function flow() {
	      var _layout = this.layout,
	          defs = _layout.defs,
	          options = _layout.options;
	      var musicDataSep = options.musicDataSep;
	
	      var x = 0;
	      var minHeight = void 0;
	
	      this.data.forEach(function (data) {
	        var def = data.def = defs.get(data);
	        data.x = x;
	        data.y = 0;
	        x += def.width + musicDataSep;
	        minHeight = Math.min(minHeight, def.height);
	      });
	
	      this.minWidth = x;
	      this.minHeight = minHeight;
	    }
	
	    /**
	     * Draw box of the cell.
	     * @return {Element} The box SVG rect element.
	     */
	
	  }, {
	    key: 'drawBox',
	    value: function drawBox() {
	      this._boxEl = this.el.rect(0, -this.height, this.width, this.height).addClass('bbox');
	      return this._boxEl;
	    }
	
	    /**
	     * Clear the box SVG element.
	     */
	
	  }, {
	    key: 'clearBox',
	    value: function clearBox() {
	      this._boxEl.remove();
	      this._boxEl = undefined;
	    }
	
	    /**
	     * Convert cell to string.
	     * @return {string} Converted cell in musje source code.
	     */
	
	  }, {
	    key: 'toString',
	    value: function toString() {
	      return this.data.map(function (musicData) {
	        return musicData.toString();
	      }).join(' ');
	    }
	  }, {
	    key: 'score',
	    get: function get() {
	      return this._score;
	    }
	
	    /**
	     * Music data
	     * @type {Array.<MusicDataMixin>}
	     */
	
	  }, {
	    key: 'data',
	    get: function get() {
	      return this._data || (this._data = []);
	    },
	    set: function set(data) {
	      var _this = this;
	
	      this.length = 0;
	      data.forEach(function (datum) {
	        _this.append(datum);
	      });
	    }
	
	    /**
	     * Reference to the parent measures.
	     * @type {TimewiseMeasures}
	     * @readonly
	     */
	
	  }, {
	    key: 'measures',
	    get: function get() {
	      return this.score.measures;
	    }
	
	    /**
	     * Reference to the parent measure.
	     * @type {TimewiseMeasure}
	     * @readonly
	     */
	
	  }, {
	    key: 'measure',
	    get: function get() {
	      return this.measures[this._mIndex];
	    }
	
	    /**
	     * Reference to the parent parts.
	     * @type {PartwiseParts}
	     * @readonly
	     */
	
	  }, {
	    key: 'parts',
	    get: function get() {
	      return this.score.parts;
	    }
	
	    /**
	     * Reference to the parent part.
	     * @type {PartwisePart}
	     * @readonly
	     */
	
	  }, {
	    key: 'part',
	    get: function get() {
	      return this.parts[this._pIndex];
	    }
	
	    /**
	     * Previous cell in the part.
	     * @type {Cell|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'prev',
	    get: function get() {
	      return this.part.measures[this._mIndex - 1];
	    }
	
	    /**
	     * Next cell in the part.
	     * @type {Cell|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'next',
	    get: function get() {
	      return this.part.measures[this._mIndex + 1];
	    }
	
	    /**
	     * The first music data in the cell.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'firstData',
	    get: function get() {
	      return this.data[0];
	    }
	
	    /**
	     * The last music data in the cell.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'lastData',
	    get: function get() {
	      return this.data[this.data.length - 1];
	    }
	
	    /**
	     * The left bar of this cell.
	     * @type {Bar|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'barLeft',
	    get: function get() {
	      var firstData = this.firstData;
	
	      if (firstData && firstData.$type === 'bar') return firstData;
	
	      // Take from the previous measure.
	      var prevCell = this.prev;
	      if (prevCell) return prevCell.barRight;
	    }
	
	    /**
	     * The right bar of this cell.
	     * @type {Bar|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'barRight',
	    get: function get() {
	      var lastData = this.lastData;
	
	      if (lastData && lastData.$type === 'bar') return lastData;
	    }
	  }, {
	    key: 'width',
	    get: function get() {
	      return this._w;
	    },
	    set: function set(w) {
	      this._w = w;
	      reflow(this);
	    }
	  }, {
	    key: 'height',
	    get: function get() {
	      return this.layout.options.partHeight;
	    }
	
	    /**
	     * The x position of the cell in parent timewise measure.
	     * - Set the x value will cause the cell element translate.
	     * @type {number}
	     */
	
	  }, {
	    key: 'x',
	    get: function get() {
	      return this._x;
	    },
	    set: function set(x) {
	      this._x = x;
	      this.el.transform((0, _snapsvg.matrix)().translate(x, this.y2));
	    }
	
	    /**
	     * The y2 position of the cell in parent timewise measure.
	     * - Set the y2 value will cause the cell element translate.
	     * @type {number}
	     */
	
	  }, {
	    key: 'y2',
	    get: function get() {
	      var _layout$options = this.layout.options,
	          partHeight = _layout$options.partHeight,
	          partSep = _layout$options.partSep;
	
	      var p = this._pIndex;
	
	      return p ? (p + 1) * partHeight + p * partSep : partHeight;
	    }
	
	    /**
	     * The left bar of this cell.
	     * - barLeft at first measure of a system:
	     * ```
	     * |]  -> |
	     * :|  -> |
	     * :|: -> |:
	     * ```
	     * @type {Bar}
	     * @readonly
	     */
	
	  }, {
	    key: 'barLeftInSystem',
	    get: function get() {
	      var bar = this.barLeft;
	      if (!bar) return { width: 0, height: 0 };
	
	      // First measure in the system.
	      if (this.measure.inSystemBegin) {
	        if (bar.value === 'end' || bar.value === 'repeat-end') {
	          bar = new Bar('single');
	        } else if (bar.value === 'repeat-both') {
	          bar = new Bar('repeat-begin');
	        }
	      }
	      bar.def = this.layout.defs.get(bar);
	      return bar;
	    }
	
	    /**
	     * The right bar of this cell.
	     * - barRight at last measure of a system:
	     * ```
	     *  |: ->  |
	     * :|: -> :|
	     * ```
	     * @type {musje.Bar}
	     * @readonly
	     */
	
	  }, {
	    key: 'barRightInSystem',
	    get: function get() {
	      var system = this.measure.system;
	
	      var bar = this.barRight;
	
	      if (!bar) return { width: 0, height: 0 };
	
	      // Last measure in the system.
	      if (system && this.measure.inSystemEnd) {
	        if (bar.value === 'repeat-begin') {
	          bar = new Bar('single');
	        } else if (bar.value === 'repeat-both') {
	          bar = new Bar('repeat-end');
	        }
	      }
	      bar.def = this.layout.defs.get(bar);
	      return bar;
	    }
	  }]);
	
	  return Cell;
	}();
	
	// Reflow the cell.
	
	
	function reflow(that) {
	  that.data.forEach(function (data) {
	    data.x *= that.width / that.minWidth;
	  });
	}
	
	/**
	 * Make beams automatically in group by the groupDur.
	 * @param {number} groupDur - Duration of a beam group in quarter.
	 */
	function makeBeams(that, groupDur) {
	
	  getBeamGroups(that, groupDur).forEach(function (group) {
	    var beamLevel = {}; // it starts from 0, while underbar starts from 1
	
	    var nextHasSameBeamlevel = function nextHasSameBeamlevel(index, level) {
	      var next = group[index + 1];
	      return next && next.duration.underbar > level;
	    };
	
	    group.forEach(function (data, i) {
	      var underbar = data.duration.underbar;
	
	
	      for (var level = 0; level < underbar; level++) {
	        if (nextHasSameBeamlevel(i, level)) {
	
	          /**
	           * Beams of the note.
	           * - Produced by the {@link Cell#makeBeams} method.
	           * - The above method is call in {@link Score#prepareCells}.
	           * @memberof Note#
	           * @alias beams
	           * @type {Array.<Beam>}
	           */
	          data.beams = data.beams || [];
	
	          if (beamLevel[level]) {
	            data.beams[level] = new _Beam2.default('continue', level, data);
	          } else {
	            beamLevel[level] = true;
	            data.beams[level] = new _Beam2.default('begin', level, data);
	          }
	        } else {
	          if (beamLevel[level]) {
	            data.beams = data.beams || [];
	            data.beams[level] = new _Beam2.default('end', level, data);
	            delete beamLevel[level];
	          }
	        }
	      }
	    });
	  });
	}
	
	function getBeamGroups(that, groupDur) {
	  var groups = [];
	  var group = [];
	  var counter = 0;
	
	  var inGroup = function inGroup() {
	    return counter < groupDur && !(0, _util.near)(counter, groupDur);
	  };
	  var putGroup = function putGroup() {
	    if (group.length > 1) groups.push(group);
	    group = [];
	  };
	
	  that.data.forEach(function (musicData) {
	    if (musicData.$type !== 'note' && musicData.$type !== 'rest') return;
	
	    var duration = musicData.duration;
	
	    var dur = duration.quarter;
	
	    counter += dur;
	
	    if (inGroup()) {
	      if (duration.underbar) group.push(musicData);
	    } else if ((0, _util.near)(counter, groupDur)) {
	      group.push(musicData);
	      putGroup();
	      counter = 0;
	    } else {
	      putGroup();
	      counter %= groupDur;
	    }
	  });
	
	  putGroup();
	
	  return groups;
	}
	
	exports.default = Cell;

/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_8__;

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	var _MusicData2 = __webpack_require__(10);
	
	var _MusicData3 = _interopRequireDefault(_MusicData2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * Time signature.
	 * @class
	 * @param time {Object}
	 * @mixes MusicDataMixin
	 * @mixes MusicDataLayoutMixin
	 */
	var Time = function (_MusicData) {
	  _inherits(Time, _MusicData);
	
	  function Time(time) {
	    _classCallCheck(this, Time);
	
	    var _this = _possibleConstructorReturn(this, (Time.__proto__ || Object.getPrototypeOf(Time)).call(this));
	
	    _this.$type = 'time';
	    _this.beats = 4;
	    _this.beatType = 4;
	    _this.toJSON = (0, _util.makeToJSON)({
	      beats: 4,
	      beatType: 4
	    }, 'time');
	
	    (0, _util.extend)(_this, time);
	    return _this;
	  }
	
	  /**
	   * Type of time.
	   * @constant
	   * @default time
	   */
	
	
	  /**
	   * How many beats per measure.
	   * @type {number}
	   * @default
	   */
	
	
	  /**
	   * Beat type
	   * @type {number}
	   * @default
	   */
	
	
	  _createClass(Time, [{
	    key: 'toString',
	
	
	    /**
	     * Convert to musje source code.
	     * @return {string} Musje source code.
	     */
	    value: function toString() {
	      return this.beats + '/' + this.beatType;
	    }
	  }, {
	    key: 'defId',
	
	
	    /**
	     * Def id used in the SVG <defs> element.
	     * ```
	     * id := 't' beats '-' beatType
	     * ```
	     * E.g. `t3-4`
	     * @type {string}
	     * @readonly
	     */
	    get: function get() {
	      return 't' + this.beats + '-' + this.beatType;
	    }
	  }]);
	
	  return Time;
	}(_MusicData3.default);
	
	exports.default = Time;

/***/ },
/* 10 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var MusicData = function () {
	  function MusicData() {
	    _classCallCheck(this, MusicData);
	  }
	
	  _createClass(MusicData, [{
	    key: 'cell',
	
	
	    /**
	     * Reference to the parent cell.
	     * @type {Cell}
	     */
	    get: function get() {
	      return this._cell;
	    }
	
	    /**
	     * The ascendant system of the music data.
	     * @type {SystemLayout}
	     * @readonly
	     */
	
	  }, {
	    key: 'system',
	    get: function get() {
	      return this.cell.measure.system;
	    }
	
	    /**
	     * Previous music data.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'prev',
	    get: function get() {
	      return this.cell.data[this._index - 1];
	    }
	
	    /**
	     * Next music data.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'next',
	    get: function get() {
	      return this.cell.data[this._index + 1];
	    }
	
	    /**
	     * Previous music data in part, across measure.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'prevInPart',
	    get: function get() {
	      var prev = this.prev,
	          cell = this.cell;
	
	      while (!prev && cell.prev) {
	        if (!prev) {
	          cell = cell.prev;
	          prev = cell.lastData;
	        }
	      }
	      return prev;
	    }
	
	    /**
	     * Next music data in part, across measure.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'nextInPart',
	    get: function get() {
	      var next = this.next,
	          cell = this.cell;
	
	      while (!next && cell.next) {
	        if (!next) {
	          cell = cell.next;
	          next = cell.firstData;
	        }
	      }
	      return next;
	    }
	
	    /**
	     * Previous music data which has a duration.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'prevDurable',
	    get: function get() {
	      var prev = this.prev;
	
	      while (prev && !prev.duration) {
	        prev = prev.prev;
	      }return prev;
	    }
	
	    /**
	     * Next music data which has a duration.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'nextDurable',
	    get: function get() {
	      var next = this.next;
	
	      while (next && !next.duration) {
	        next = next.next;
	      }return next;
	    }
	
	    /**
	     * Previous music data which has a duration in part, across measure.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'prevDurableInPart',
	    get: function get() {
	      var prev = this.prevInPart;
	      while (prev && !prev.duration) {
	        prev = prev.prevInPart;
	      }return prev;
	    }
	
	    /**
	     * Next music data which has a duration in part, across measure.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'nextDurableInPart',
	    get: function get() {
	      var next = this.nextInPart;
	      while (next && !next.duration) {
	        next = next.nextInPart;
	      }return next;
	    }
	
	    /**
	     * The x position of the music data in the cell.
	     * @type {number}
	     */
	
	  }, {
	    key: 'x',
	    get: function get() {
	      return this._x;
	    },
	    set: function set(x) {
	      this._x = x;
	      if (this.el) this.el.attr('x', x);
	    }
	
	    /**
	     * The y position of the music data in the cell.
	     * @type {number}
	     */
	
	  }, {
	    key: 'y',
	    get: function get() {
	      return this._y;
	    },
	    set: function set(y) {
	      this._y = y;
	      if (this.el) this.el.attr('y', y);
	    }
	
	    /**
	     * The x position of the music data in the system.
	     * @type {number}
	     */
	
	  }, {
	    key: 'systemX',
	    get: function get() {
	      return this.x + this.cell.x + this.cell.measure.x;
	    }
	
	    /**
	     * The width of the music data.
	     * @type {number}
	     * @readonly
	     */
	
	  }, {
	    key: 'width',
	    get: function get() {
	      return this.def.width;
	    }
	  }]);
	
	  return MusicData;
	}();
	
	exports.default = MusicData;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _MusicData2 = __webpack_require__(10);
	
	var _MusicData3 = _interopRequireDefault(_MusicData2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var BAR_TO_STRING = {
	  single: '|', double: '||', end: '|]',
	  'repeat-begin': '|:', 'repeat-end': ':|', 'repeat-both': ':|:'
	};
	var BAR_TO_ID = {
	  single: 'bs', double: 'bd', end: 'be',
	  'repeat-begin': 'brb', 'repeat-end': 'bre', 'repeat-both': 'brbe'
	};
	
	/**
	 * @param {string} bar - The bar value, which can be either of
	 * - 'single' - `|`
	 * - 'double' - `||`
	 * - 'end' - `|]`
	 * - 'repeat-begin' - `|:`
	 * - 'repeat-end' - `:|`
	 * - 'repeat-both' - `:|:`
	 */
	
	var Bar = function (_MusicData) {
	  _inherits(Bar, _MusicData);
	
	  function Bar(bar) {
	    _classCallCheck(this, Bar);
	
	    var _this = _possibleConstructorReturn(this, (Bar.__proto__ || Object.getPrototypeOf(Bar)).call(this));
	
	    _this.$type = 'bar';
	
	    _this._value = bar;
	    return _this;
	  }
	
	  /**
	   * Type of bar.
	   * @constant
	   * @readonly
	   * @default bar
	   */
	
	
	  _createClass(Bar, [{
	    key: 'toString',
	
	
	    /**
	     * Convert bar to string.
	     * @return {string} Converted string of the barline in musje source code.
	     */
	    value: function toString() {
	      return BAR_TO_STRING[this.value];
	    }
	
	    /**
	     * [toJSON description]
	     * @return {Object} { bar: value }
	     */
	
	  }, {
	    key: 'toJSON',
	    value: function toJSON() {
	      return { bar: this.value };
	    }
	  }, {
	    key: 'value',
	
	
	    /**
	     * Value of the bar, which is the same as the bar parameter in the constructor.
	     * @type {string}
	     * @default single
	     * @readonly
	     */
	    get: function get() {
	      return this._value || (this._value = 'single');
	    }
	
	    /**
	     * Def id used in the SVG <defs> element.
	     * ```
	     * defId    Bar value
	     * ----------------------
	     * 'bs'   - single
	     * 'bd'   - double
	     * 'be'   - repeat-end
	     * 'brb'  - repeat-begin
	     * 'bre'  - repeat-end
	     * 'brbe' - repeat-both
	     * ```
	     * @type {string}
	     * @readonly
	     */
	
	  }, {
	    key: 'defId',
	    get: function get() {
	      return BAR_TO_ID[this.value];
	    }
	  }]);
	
	  return Bar;
	}(_MusicData3.default);
	
	exports.default = Bar;

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	var _MusicData2 = __webpack_require__(10);
	
	var _MusicData3 = _interopRequireDefault(_MusicData2);
	
	var _Pitch = __webpack_require__(13);
	
	var _Pitch2 = _interopRequireDefault(_Pitch);
	
	var _Duration = __webpack_require__(14);
	
	var _Duration2 = _interopRequireDefault(_Duration);
	
	var _Tie = __webpack_require__(15);
	
	var _Tie2 = _interopRequireDefault(_Tie);
	
	var _Slur = __webpack_require__(16);
	
	var _Slur2 = _interopRequireDefault(_Slur);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * @class
	 * @param {Object} note
	 * @mixes MusicDataMixin
	 * @mixes MusicDataLayoutMixin
	 */
	var Note = function (_MusicData) {
	  _inherits(Note, _MusicData);
	
	  function Note(note) {
	    _classCallCheck(this, Note);
	
	    var _this = _possibleConstructorReturn(this, (Note.__proto__ || Object.getPrototypeOf(Note)).call(this));
	
	    _this.$type = 'note';
	    _this.toJSON = (0, _util.makeToJSON)({
	      pitch: undefined,
	      duration: undefined,
	      tie: undefined,
	      slur: undefined
	    }, 'note');
	
	    (0, _util.extend)(_this, note);
	    return _this;
	  }
	
	  /**
	   * Type of note.
	   * @constant
	   * @default note
	   */
	
	
	  _createClass(Note, [{
	    key: 'toString',
	
	
	    /** @method */
	    value: function toString() {
	      return this.slur.begin + this.pitch + this.duration + this.slur.end + this.tie.value;
	    }
	  }, {
	    key: 'defId',
	
	
	    /**
	     * Unique def id of the note used in the SVG <defs> element.
	     * ```
	     * defId := 'n' accidental step octave type dot
	     * ```
	     * E.g.
	     * ```
	     * Note     defId
	     * ------------------
	     * 1        n1040
	     * b3-      nb3020
	     * #5'_.    ns5181
	     * 6,,      n6-2
	     * ```
	     * @type {string}
	     * @readonly
	     */
	    get: function get() {
	      var _pitch = this.pitch,
	          accidental = _pitch.accidental,
	          step = _pitch.step,
	          octave = _pitch.octave;
	      var _duration = this.duration,
	          type = _duration.type,
	          dot = _duration.dot;
	
	      return 'n' + accidental.replace(/#/g, 's') + step + octave + type + dot;
	    }
	
	    /**
	     * Pitch of the note.
	     * @type {musje.Pitch}
	     */
	
	  }, {
	    key: 'pitch',
	    get: function get() {
	      return this._pitch || (this._pitch = new _Pitch2.default(this));
	    },
	    set: function set(pitch) {
	      this._pitch = new _Pitch2.default(this, pitch);
	    }
	
	    /**
	     * Duration of the note.
	     * @type {musje.Duration}
	     */
	
	  }, {
	    key: 'duration',
	    get: function get() {
	      return this._duration || (this._duration = new _Duration2.default());
	    },
	    set: function set(duration) {
	      this._duration = new _Duration2.default(duration);
	    }
	  }, {
	    key: 'beams',
	    get: function get() {
	      return this._beams || (this._beams = []);
	    },
	    set: function set(beams) {
	      this._beams = beams;
	    }
	
	    /**
	     * Tie
	     * @type {musje.Tie}
	     */
	
	  }, {
	    key: 'tie',
	    get: function get() {
	      return this._tie || (this._tie = new _Tie2.default(this));
	    },
	    set: function set(tie) {
	      /**
	       * Value of the tie.
	       * @memberof Tie#
	       * @alias value
	       * @type {boolean}
	       */
	      this.tie.value = tie;
	    }
	
	    /**
	     * Slur
	     * @type {Slur}
	     */
	
	  }, {
	    key: 'slur',
	    get: function get() {
	      return this._slur || (this._slur = new _Slur2.default(this));
	    },
	    set: function set(slur) {
	      (0, _util.extend)(this.slur, slur);
	    }
	  }]);
	
	  return Note;
	}(_MusicData3.default);
	
	exports.default = Note;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var A4_FREQUENCY = 440;
	var A4_MIDI_NUMBER = 69;
	var STEP_TO_MIDI_NUMBER = [undefined, 0, 2, 4, 5, 7, 9, 11];
	var ACCIDENTAL_TO_ALTER = { '#': 1, '##': 2, n: 0, b: -1, bb: -2 };
	
	var chars = function chars(ch, num) {
	  return new Array(num + 1).join(ch);
	};
	var octaveString = function octaveString(octave) {
	  return octave > 0 ? chars('\'', octave) : octave < 0 ? chars(',', -octave) : '';
	};
	
	// /**
	//  * Step is a value of `1`, `2`, `3`, `4`, `5`, `6`, or `7`.
	//  * @type {number}
	//  * @default
	//  */
	// step = 1
	
	// /**
	//  * Octave is an integer value from `-5` to `5` inclusive.
	//  * @type {number}
	//  * @default
	//  */
	// octave = 0
	
	// /**
	//  * Accidental is either of
	//  * - `'#'` - sharp
	//  * - `'##'` - double sharp
	//  * - `'b'` - flat
	//  * - `'bb'` - double flat
	//  * - `'n'` - natural
	//  * - `''` - (none)
	//  * @type {string}
	//  */
	// accidental = ''
	
	/**
	 * @class
	 * @param parent {Note|Chord}
	 * @param pitch {Object}
	 */
	
	var Pitch = function () {
	  function Pitch(parent, _ref) {
	    var _ref$step = _ref.step,
	        step = _ref$step === undefined ? 1 : _ref$step,
	        _ref$octave = _ref.octave,
	        octave = _ref$octave === undefined ? 0 : _ref$octave,
	        _ref$accidental = _ref.accidental,
	        accidental = _ref$accidental === undefined ? '' : _ref$accidental;
	
	    _classCallCheck(this, Pitch);
	
	    this.toJSON = (0, _util.makeToJSON)({
	      step: 1,
	      octave: 0,
	      accidental: ''
	    });
	
	    this._parent = parent;
	    (0, _util.extend)(this, { step: step, octave: octave, accidental: accidental });
	  }
	
	  /**
	   * Reference to the parent parent.
	   * @type {Note|Chord}
	   * @readonly
	   */
	
	
	  _createClass(Pitch, [{
	    key: 'toString',
	
	
	    /**
	     * Convert to musje source code string.
	     * @return {string} Converted musje source code string.
	     */
	    value: function toString() {
	      return this.accidental + this.step + octaveString(this.octave);
	    }
	  }, {
	    key: 'parent',
	    get: function get() {
	      return this._parent;
	    }
	
	    /**
	     * Def id used in the SVG <defs> element.
	     * ```
	     * defId := 'p' accidental step octave
	     * ```
	     * @type {string}
	     * @readonly
	     */
	
	  }, {
	    key: 'defId',
	    get: function get() {
	      return 'p' + this.accidental.replace(/#/g, 's') + this.step + this.octave;
	    }
	
	    /**
	     * Alter (from -2 to 2 inclusive).
	     *
	     * If no accidental in this pitch, it might be affected by a previous note in the same cell (the same part and the same measure).
	     * @type {number}
	     * @readonly
	     */
	
	  }, {
	    key: 'alter',
	    get: function get() {
	      if (this.accidental) return ACCIDENTAL_TO_ALTER[this.accidental];
	      var alterLink = this.alterLink;
	
	      return alterLink ? alterLink.alter : 0;
	    }
	
	    /**
	     * Pitch linked that will affect the alter in this pitch.
	     * @type {Pitch|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'alterLink',
	    get: function get() {
	      var prevData = this.parent.prev;
	
	      while (prevData) {
	        if (prevData.$type === 'note' && prevData.pitch.step === this.step && prevData.pitch.accidental) {
	          return prevData.pitch;
	        }
	        prevData = prevData.prev;
	      }
	    }
	
	    /**
	     * The MIDI note number of the pitch
	     * @type {number}
	     */
	
	  }, {
	    key: 'midiNumber',
	    get: function get() {
	      return (this.octave + 5) * 12 + STEP_TO_MIDI_NUMBER[this.step] + this.alter;
	    }
	
	    /**
	     * Frequency of the pitch
	     * @type {number}
	     * @readonly
	     */
	
	  }, {
	    key: 'frequency',
	    get: function get() {
	      return A4_FREQUENCY * Math.pow(2, (this.midiNumber - A4_MIDI_NUMBER) / 12);
	    }
	  }]);
	
	  return Pitch;
	}();
	
	exports.default = Pitch;

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var TYPE_TO_STRING = {
	  1: ' - - - ', 2: ' - ', 4: '', 8: '_', 16: '=', 32: '=_',
	  64: '==', 128: '==_', 256: '===', 512: '===_', 1024: '===='
	};
	var TYPE_TO_UNDERBAR = {
	  1: 0, 2: 0, 4: 0, 8: 1, 16: 2, 32: 3,
	  64: 4, 128: 5, 256: 6, 512: 7, 1024: 8
	};
	var DOT_TO_STRING = ['', '.', '..'];
	
	// /**
	//  * Beat type
	//  * @type {number}
	//  * @default
	//  */
	// type = 4
	
	// *
	//  * Dot with value of 0, 1, or 2.
	//  * @type {number}
	//  * @default
	
	// dot = 0
	
	var Duration = function () {
	  function Duration() {
	    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        _ref$type = _ref.type,
	        type = _ref$type === undefined ? 4 : _ref$type,
	        _ref$dot = _ref.dot,
	        dot = _ref$dot === undefined ? 0 : _ref$dot;
	
	    _classCallCheck(this, Duration);
	
	    this.$type = 'duration';
	    this.toJSON = (0, _util.makeToJSON)({
	      type: 4,
	      dot: 0
	    });
	
	    (0, _util.extend)(this, { type: type, dot: dot });
	  }
	
	  /**
	   * Type of duration.
	   * @constant
	   * @default duration
	   */
	
	
	  _createClass(Duration, [{
	    key: 'toString',
	
	
	    /**
	     * @return {string}
	     */
	    value: function toString() {
	      return TYPE_TO_STRING[this.type] + DOT_TO_STRING[this.dot];
	    }
	
	    /**
	     * [toJSON description]
	     * @return {Object}
	     */
	
	  }, {
	    key: 'defId',
	
	
	    /**
	     * Def id used in the SVG <defs> element.
	     * ```
	     * defId := 'd' type dot
	     * ```
	     * *E.g.*
	     * ```
	     * Note     defId
	     * ----------------
	     * 1.       d41
	     * 1_       d80
	     * 1=       d160
	     * 1-..     d22
	     * ```
	     * @type {string}
	     * @readonly
	     */
	    get: function get() {
	      return 'd' + this.type + this.dot;
	    }
	
	    /**
	     * `(Getter)` Duration measured in quarter note.
	     * @type {number}
	     */
	
	  }, {
	    key: 'quarter',
	    get: function get() {
	      var d = 4 / this.type;
	      return this.dot === 0 ? d : this.dot === 1 ? d * 1.5 : d * 1.75;
	    }
	
	    /**
	     * `(Getter)` Duration in second
	     * Affected by the tempo.
	     * @type {number}
	     * @readonly
	     */
	
	  }, {
	    key: 'second',
	    get: function get() {
	      return this.quarter * 60 / 80; // / TEMPO;
	    }
	
	    /**
	     * `(Getter)` Number of underbars in the beam.
	     * @type {number}
	     * @readonly
	     */
	
	  }, {
	    key: 'underbar',
	    get: function get() {
	      return TYPE_TO_UNDERBAR[this.type] || 0;
	    }
	  }]);
	
	  return Duration;
	}();
	
	exports.default = Duration;

/***/ },
/* 15 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Tie of the note.
	 * @param parent {Note|Chord}
	 */
	var Tie = function () {
	  function Tie(parent) {
	    _classCallCheck(this, Tie);
	
	    this.value = '';
	
	    this._parent = parent;
	  }
	
	  _createClass(Tie, [{
	    key: 'toJSON',
	    value: function toJSON() {
	      return this.value;
	    }
	  }, {
	    key: 'parent',
	    get: function get() {
	      return this._parent;
	    }
	  }, {
	    key: 'begin',
	    get: function get() {
	      return this.value;
	    }
	  }, {
	    key: 'end',
	    get: function get() {
	      return this.prevParent;
	    }
	
	    /**
	     * The previous durable music data in part, if it is a tie begin.
	     * @type {Durable|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'prevParent',
	    get: function get() {
	      var prev = this.parent.prevDurableInPart;
	      return prev && prev.tie && prev.tie.value && prev;
	    }
	
	    /**
	     * The next durable music data in part.
	     * @type {Durable|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'nextParent',
	    get: function get() {
	      return this.value && this.parent.nextDurableInPart;
	    }
	
	    /**
	     * If previous durable music data in part has error.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'prevHasError',
	    get: function get() {
	      var prev = this.prevParent;
	      if (!prev || !prev.pitch) return true;
	      return prev.pitch && prev.pitch.midiNumber !== this.parent.pitch.midiNumber;
	    }
	
	    /**
	     * If next durable music data in part has error.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'nextHasError',
	    get: function get() {
	      var next = this.nextParent;
	      if (!next || !next.pitch) return true;
	      return next.pitch.midiNumber !== this.parent.pitch.midiNumber;
	    }
	  }]);
	
	  return Tie;
	}();
	
	exports.default = Tie;

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Slur
	 * @class
	 * @param parent {Note|Chord}
	 */
	var Slur = function () {
	  function Slur(parent) {
	    _classCallCheck(this, Slur);
	
	    this.begin = '';
	    this.end = '';
	    this.toJSON = (0, _util.makeToJSON)({
	      begin: undefined,
	      end: undefined
	    });
	
	    this._parent = parent;
	  }
	
	  _createClass(Slur, [{
	    key: 'parent',
	
	
	    /**
	     * Parent music data.
	     * @type {Note|Chord}
	     * @readonly
	     */
	    get: function get() {
	      return this._parent;
	    }
	
	    /**
	     * Previous slurred parent.
	     * @type {Note|Chord}
	     * @readonly
	     */
	
	  }, {
	    key: 'prevParent',
	    get: function get() {
	      if (!this.end) return;
	
	      var prev = this.parent.prevInPart;
	      while (prev) {
	        if (prev.slur && !prev.slur.isEmpty) return prev;
	        prev = prev.prevInPart;
	      }
	    }
	
	    /**
	     * Next Slurred parent.
	     * @type {Note|Chord}
	     * @readonly
	     */
	
	  }, {
	    key: 'nextParent',
	    get: function get() {
	      if (!this.begin) return;
	
	      var next = this.parent.nextInPart;
	      while (next) {
	        if (next.slur && !next.slur.isEmpty) return next;
	        next = next.nextInPart;
	      }
	    }
	
	    /**
	     * @todo Nested tie in slur.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'prevCrossTie',
	    get: function get() {}
	
	    /**
	     * @todo Nested tie in slur.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'nextCrossTie',
	    get: function get() {}
	
	    /**
	     * If the previous slur has error.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'prevHasError',
	    get: function get() {
	      var prevParent = this.prevParent;
	
	      return !prevParent || !prevParent.slur.begin;
	    }
	
	    /**
	     * If the next slur has error.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'nextHasError',
	    get: function get() {
	      var nextParent = this.nextParent;
	
	      return !nextParent || !nextParent.slur.end;
	    }
	
	    /**
	     * If the slur is empty.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'isEmpty',
	    get: function get() {
	      return !(this.begin || this.end);
	    }
	
	    /**
	     * Convert the slur to JSON object.
	     * @method
	     * @return {Object} JSON object.
	     */
	
	  }]);
	
	  return Slur;
	}();
	
	exports.default = Slur;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	var _MusicData2 = __webpack_require__(10);
	
	var _MusicData3 = _interopRequireDefault(_MusicData2);
	
	var _Duration = __webpack_require__(14);
	
	var _Duration2 = _interopRequireDefault(_Duration);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * @class
	 * @param {rest} rest
	 * @mixes MusicDataMixin
	 * @mixes MusicDataLayoutMixin
	 */
	var Rest = function (_MusicData) {
	  _inherits(Rest, _MusicData);
	
	  function Rest(rest) {
	    _classCallCheck(this, Rest);
	
	    var _this = _possibleConstructorReturn(this, (Rest.__proto__ || Object.getPrototypeOf(Rest)).call(this));
	
	    _this.$type = 'rest';
	    _this.toJSON = (0, _util.makeToJSON)({
	      duration: undefined
	    }, 'rest');
	
	    (0, _util.extend)(_this, rest);
	    return _this;
	  }
	
	  /**
	   * Type of rest.
	   * @constant
	   * @default rest
	   */
	
	
	  _createClass(Rest, [{
	    key: 'toString',
	
	
	    /**
	     * Convert the rest to musje source code string.
	     * @return {string} Converted musje source code.
	     */
	    value: function toString() {
	      return '0' + this.duration;
	    }
	  }, {
	    key: 'defId',
	
	
	    /**
	     * Unique def id of the rest used in the SVG <defs> element.
	     * ```
	     * defId := 'r' type dot
	     * ```
	     * E.g.
	     * ```
	     * Rest     defId
	     * ----------------
	     * 0        r40
	     * 0 -      r20
	     * 0=.      r161
	     * ```
	     * @type {string}
	     * @readonly
	     */
	    get: function get() {
	      var _duration = this.duration,
	          type = _duration.type,
	          dot = _duration.dot;
	
	      return 'r' + type + dot;
	    }
	
	    /**
	     * Duration of the rest.
	     * @type {Duration}
	     */
	
	  }, {
	    key: 'duration',
	    get: function get() {
	      return this._duration || (this._duration = new _Duration2.default());
	    },
	    set: function set(duration) {
	      this._duration = new _Duration2.default(duration);
	    }
	  }, {
	    key: 'beams',
	    get: function get() {
	      return this._beams || (this._beams = []);
	    },
	    set: function set(beams) {
	      this._beams = beams;
	    }
	  }]);
	
	  return Rest;
	}(_MusicData3.default);
	
	exports.default = Rest;

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	var _MusicData2 = __webpack_require__(10);
	
	var _MusicData3 = _interopRequireDefault(_MusicData2);
	
	var _Pitch = __webpack_require__(13);
	
	var _Pitch2 = _interopRequireDefault(_Pitch);
	
	var _Duration = __webpack_require__(14);
	
	var _Duration2 = _interopRequireDefault(_Duration);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * @class
	 * @param {Object} chord
	 * @mixes MusicDataMixin
	 * @mixes MusicDataLayoutMixin
	 */
	var Chord = function (_MusicData) {
	  _inherits(Chord, _MusicData);
	
	  function Chord(chord) {
	    _classCallCheck(this, Chord);
	
	    var _this = _possibleConstructorReturn(this, (Chord.__proto__ || Object.getPrototypeOf(Chord)).call(this));
	
	    _this.$type = 'chord';
	    _this.toJSON = (0, _util.makeToJSON)({
	      pitches: undefined,
	      duration: undefined
	    }, 'chord');
	
	    (0, _util.extend)(_this, chord);
	    return _this;
	  }
	
	  /**
	   * Type of chord.
	   * @constant
	   * @default chord
	   */
	
	
	  _createClass(Chord, [{
	    key: 'toString',
	
	
	    /**
	     * Convert chord to the musje source code string.
	     * @return {string} Converted musje source code of the chord.
	     */
	    value: function toString() {
	      return '<' + this.pitches.map(function (pitch) {
	        return pitch.toString();
	      }).join('') + '>' + this.duration;
	    }
	  }, {
	    key: 'pitches',
	
	
	    /**
	     * Pitches in the chord.
	     * @type {Array.<Pitch>}
	     */
	    get: function get() {
	      return this._pitches || (this._pitches = []);
	    },
	    set: function set(pitches) {
	      this._pitches = pitches.map(function (pitch) {
	        return new _Pitch2.default(pitch);
	      });
	    }
	
	    /**
	     * Duration of the chord.
	     * @type {Duration}
	     */
	
	  }, {
	    key: 'duration',
	    get: function get() {
	      return this._duration || (this._duration = new _Duration2.default());
	    },
	    set: function set(duration) {
	      this._duration = new _Duration2.default(duration);
	    }
	  }]);
	
	  return Chord;
	}(_MusicData3.default);
	
	exports.default = Chord;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	var _MusicData2 = __webpack_require__(10);
	
	var _MusicData3 = _interopRequireDefault(_MusicData2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * @class
	 * @param {Object} voice
	 */
	var Voice = function (_MusicData) {
	  _inherits(Voice, _MusicData);
	
	  function Voice(voice) {
	    _classCallCheck(this, Voice);
	
	    var _this = _possibleConstructorReturn(this, (Voice.__proto__ || Object.getPrototypeOf(Voice)).call(this));
	
	    _this.$type = 'voice';
	
	    (0, _util.extend)(_this, voice);
	    return _this;
	  }
	
	  /**
	   * Type of voice.
	   * @constant
	   * @default voice
	   */
	
	
	  _createClass(Voice, [{
	    key: 'toString',
	
	
	    /**
	     * Convert the voice to musje source code string.
	     * @return {string} Converted musje source code string.
	     */
	    value: function toString() {}
	  }]);
	
	  return Voice;
	}(_MusicData3.default);
	
	exports.default = Voice;

/***/ },
/* 20 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * A [beam][wiki] is a horizontal or diagonal line used to connect multiple consecutive notes (and occasionally rests) in order to indicate rhythmic grouping. Only eighth notes (quavers) or shorter can be beamed.
	 *
	 * [wiki]: https://en.wikipedia.org/wiki/Beam_(music)
	 *
	 * Beam is created by {@link Cell#makeBeams} and
	 * attached to {@link Durable} in {@link Durable#beams}[level]
	 * @class
	 * @param {string} value - Beam value: `'begin'`, `'continue'` or `'end'`.
	 * @param {number} level - Beam level starting from 0 to up.
	 * @param {Durable} parent - The parent durable music data.
	 */
	var Beam = function () {
	  function Beam(value, level, parent) {
	    _classCallCheck(this, Beam);
	
	    this._value = value;
	    this._level = level;
	    this._parent = parent;
	  }
	
	  /**
	   * Parent
	   * @type {Note|Rest|Chord}
	   * @readonly
	   */
	
	
	  _createClass(Beam, [{
	    key: 'parent',
	    get: function get() {
	      return this._parent;
	    }
	
	    /**
	     * Beam value: `'begin'`, `'continue'` or `'end'`.
	     * @type {string}
	     * @readonly
	     */
	
	  }, {
	    key: 'value',
	    get: function get() {
	      return this._value;
	    }
	
	    /**
	     * Beam level starting from 0 to up.
	     * @type {number}
	     * @readonly
	     */
	
	  }, {
	    key: 'level',
	    get: function get() {
	      return this._level;
	    }
	
	    /**
	     * The end parent music data of the beam group.
	     * @type {MusicDataMixin}
	     */
	
	  }, {
	    key: 'endDurable',
	    get: function get() {
	      var nextData = this.parent.next;
	      while (nextData && nextData.beams[this.level].value !== 'end') {
	        nextData = nextData.next;
	      }
	      return nextData;
	    }
	  }]);
	
	  return Beam;
	}();
	
	exports.default = Beam;

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _TimewiseMeasure = __webpack_require__(22);
	
	var _TimewiseMeasure2 = _interopRequireDefault(_TimewiseMeasure);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _extendableBuiltin(cls) {
	  function ExtendableBuiltin() {
	    cls.apply(this, arguments);
	  }
	
	  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
	    constructor: {
	      value: cls,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	
	  if (Object.setPrototypeOf) {
	    Object.setPrototypeOf(ExtendableBuiltin, cls);
	  } else {
	    ExtendableBuiltin.__proto__ = cls;
	  }
	
	  return ExtendableBuiltin;
	}
	
	/**
	 * Construct timewise score measures.
	 * @class
	 * @classdesc Timewise score measures.
	 * @param score {Score}
	 * @augments {Array}
	 */
	var TimewiseMeasures = function (_extendableBuiltin2) {
	  _inherits(TimewiseMeasures, _extendableBuiltin2);
	
	  function TimewiseMeasures(score) {
	    _classCallCheck(this, TimewiseMeasures);
	
	    var _this = _possibleConstructorReturn(this, (TimewiseMeasures.__proto__ || Object.getPrototypeOf(TimewiseMeasures)).call(this));
	
	    _this._score = score;
	    return _this;
	  }
	
	  /**
	   * Reference to the parent score.
	   * @type {Score}
	   * @readonly
	   */
	
	
	  _createClass(TimewiseMeasures, [{
	    key: 'fromPartwise',
	
	
	    /**
	     * Make timewise score measures from the partwise parts.
	     */
	    value: function fromPartwise() {
	      var _this2 = this;
	
	      this.removeAll();
	      this.score.walkCells(function (cell, m) {
	        if (m === _this2.length && !_this2[m]) _this2.push(new _TimewiseMeasure2.default(m, _this2));
	        _this2[m].parts.push(cell);
	      });
	    }
	
	    /**
	     * Remove all measures.
	     */
	
	  }, {
	    key: 'removeAll',
	    value: function removeAll() {
	      this.length = 0;
	    }
	  }, {
	    key: 'score',
	    get: function get() {
	      return this._score;
	    }
	  }]);
	
	  return TimewiseMeasures;
	}(_extendableBuiltin(Array));
	
	exports.default = TimewiseMeasures;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _snapsvg = __webpack_require__(8);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @class
	 * @param measure {Object}
	 * @mixes TimewiseMeasureLayoutMixin
	 */
	var TimewiseMeasure = function () {
	  function TimewiseMeasure(index, measures) {
	    _classCallCheck(this, TimewiseMeasure);
	
	    // this._index = index
	    this._measures = measures;
	  }
	
	  /**
	   * Reference to the parent measures instance.
	   * @member {TimewiseMeasures}
	   */
	
	
	  _createClass(TimewiseMeasure, [{
	    key: 'flow',
	
	
	    /**
	     * Flow the measure.
	     */
	    value: function flow() {
	      var _this = this;
	
	      this.parts.forEach(function (cell) {
	
	        /**
	         * Cell SVG group element.
	         * @memberof CellLayout#
	         * @alias el
	         * @type {Snap.Element}
	         * @readonly
	         */
	        cell.el = _this.el.g().addClass('mus-cell');
	
	        cell.x = _this.outerWidthLeft;
	
	        // cell.drawBox()
	      });
	    }
	
	    /**
	     * Draw box of the cell.
	     * @return {Snap.Element} The box SVG rect element.
	     */
	
	  }, {
	    key: 'drawBox',
	    value: function drawBox() {
	      this._boxEl = this.el.rect(0, 0, this.width, this.height).attr({ stroke: 'green', fill: 'none' });
	    }
	
	    /**
	     * Clear the box SVG element.
	     */
	
	  }, {
	    key: 'clearBox',
	    value: function clearBox() {
	      this._boxEl.remove();
	      this._boxEl = undefined;
	    }
	  }, {
	    key: 'measures',
	    get: function get() {
	      return this._measures;
	    }
	
	    /**
	     * Parts in timewise measure.
	     * @type {Array.<Cell>}
	     */
	
	  }, {
	    key: 'parts',
	    get: function get() {
	      return this._parts || (this._parts = []);
	    },
	    set: function set(parts) {
	      this._parts = parts;
	    }
	
	    /**
	     * Left bar of the measure.
	     * @type {Bar}
	     * @readonly
	     */
	
	  }, {
	    key: 'barLeft',
	    get: function get() {
	      return this.parts[0].barLeft;
	    }
	
	    /**
	     * Right bar of the measure.
	     * @type {Bar}
	     * @readonly
	     */
	
	  }, {
	    key: 'barRight',
	    get: function get() {
	      return this.parts[0].barRight;
	    }
	
	    /**
	     * Measure SVG group element.
	     * @type {Snap.Element}
	     * @readonly
	     */
	
	  }, {
	    key: 'el',
	    get: function get() {
	      return this._el;
	    }
	
	    /**
	     * Minimun width of the measure.
	     * @type {number}
	     */
	
	  }, {
	    key: 'minWidth',
	    get: function get() {
	      var minWidth = 0;
	      this.parts.forEach(function (cell) {
	        minWidth = Math.max(minWidth, cell.minWidth);
	      });
	      return minWidth + this.padding;
	    }
	
	    /**
	     * Reference to the parent system of this measure.
	     * - (Getter)
	     * - (Setter) The measure el will be created, and the height of the measure will be set.
	     * @type {SystemLayout}
	     */
	
	  }, {
	    key: 'system',
	    get: function get() {
	      return this._s;
	    },
	    set: function set(system) {
	      this._s = system;
	      this._el = system.el.g().addClass('mus-measure');
	    }
	  }, {
	    key: 'padding',
	    get: function get() {
	      var lo = this.layout.options;
	      return lo.measurePaddingRight + lo.measurePaddingLeft;
	    }
	  }, {
	    key: 'outerWidth',
	    get: function get() {
	      return this.outerWidthLeft + this.outerWidthRight;
	    }
	  }, {
	    key: 'outerWidthLeft',
	    get: function get() {
	      return this.layout.options.measurePaddingLeft + this.barLeftInSystem.width / 2;
	    }
	  }, {
	    key: 'outerWidthRight',
	    get: function get() {
	      return this.layout.options.measurePaddingRight + this.barRightInSystem.width / 2;
	    }
	
	    /**
	     * Width of the measure.
	     * @type {number}
	     */
	
	  }, {
	    key: 'width',
	    get: function get() {
	      return this._w || (this._w = this.minWidth);
	    },
	    set: function set(w) {
	      var _this2 = this;
	
	      this._w = w;
	      this.parts.forEach(function (cell) {
	        cell.width = w - _this2.outerWidth;
	      });
	    }
	  }, {
	    key: 'height',
	    get: function get() {
	      return this.system.height;
	    }
	  }, {
	    key: 'minHeight',
	    get: function get() {
	      var partSep = this.layout.options.partSep;
	
	      var minHeight = 0;
	
	      this.parts.forEach(function (cell) {
	        minHeight += cell.height + partSep;
	      });
	      return minHeight ? minHeight - partSep : 0;
	    }
	
	    /**
	     * The x position of the measure in the system.
	     * - (Getter)
	     * - (Setter) Set x cause the measure element to translate.
	     * @type {number}
	     */
	
	  }, {
	    key: 'x',
	    get: function get() {
	      return this._x;
	    },
	    set: function set(x) {
	      this._x = x;
	      this.el.transform(Snap.matrix().translate(x, 0));
	    }
	
	    /**
	     * If the measure in the beginning of the system.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'inSystemBegin',
	    get: function get() {
	      return this._sIndex === 0;
	    }
	
	    /**
	     * If the measure in the end of the system.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'inSystemEnd',
	    get: function get() {
	      return this._sIndex === this.system.measures.length - 1;
	    }
	
	    /**
	     * Left bar of the measure in system.
	     * @type {musje.Bar}
	     * @readonly
	     */
	
	  }, {
	    key: 'barLeftInSystem',
	    get: function get() {
	      return this.parts[0].barLeftInSystem;
	    }
	
	    /**
	     * Right bar of the measure in system.
	     * @type {Bar}
	     * @readonly
	     */
	
	  }, {
	    key: 'barRightInSystem',
	    get: function get() {
	      return this.parts[0].barRightInSystem;
	    }
	  }]);
	
	  return TimewiseMeasure;
	}();
	
	exports.default = TimewiseMeasure;

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _snapsvg = __webpack_require__(8);
	
	var _util = __webpack_require__(2);
	
	var _Layout = __webpack_require__(24);
	
	var _Layout2 = _interopRequireDefault(_Layout);
	
	var _renderBar = __webpack_require__(38);
	
	var _renderBar2 = _interopRequireDefault(_renderBar);
	
	var _renderDuration = __webpack_require__(39);
	
	var _renderDuration2 = _interopRequireDefault(_renderDuration);
	
	var _renderCurve = __webpack_require__(40);
	
	var _renderCurve2 = _interopRequireDefault(_renderCurve);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Renderer = function () {
	  function Renderer(svg, lo) {
	    _classCallCheck(this, Renderer);
	
	    this._lo = (0, _util.extend)(_Layout2.default.options, lo);
	    this.layout = new _Layout2.default(svg, this._lo);
	  }
	
	  _createClass(Renderer, [{
	    key: 'render',
	    value: function render(score) {
	      this._score = score;
	      this.layout.flow(score);
	      this.renderHeader();
	      this.renderContent();
	    }
	  }, {
	    key: 'renderHeader',
	    value: function renderHeader() {
	      var lo = this._lo;
	      var header = this.layout.header;
	      var el = header.el,
	          width = header.width;
	
	
	      el.text(width / 2, lo.titleFontSize, this._score.head.title).attr({
	        fontSize: lo.titleFontSize * 2,
	        fontWeight: lo.titleFontWeight,
	        textAnchor: 'middle'
	      });
	
	      el.text(width, lo.titleFontSize * 1.5, this._score.head.composer).attr({
	        fontSize: lo.composerFontSize,
	        fontWeight: lo.composerFontWeight,
	        textAnchor: 'end'
	      });
	
	      header.height = el.getBBox().height;
	    }
	  }, {
	    key: 'renderContent',
	    value: function renderContent() {
	      var lo = this._lo;
	
	      this.layout.content.systems.forEach(function (system) {
	        var measures = system.measures;
	
	        measures.forEach(function (measure) {
	          (0, _renderBar2.default)(measure, lo);
	          measure.parts.forEach(function (cell) {
	            renderCell(cell, lo);
	          });
	        });
	      });
	    }
	  }]);
	
	  return Renderer;
	}();
	
	function renderNote(note, cell, lo) {
	  note.el = cell.el.g().transform((0, _snapsvg.matrix)().translate(note.x, note.y));
	  note.el.use(note.def.pitchDef.el);
	  (0, _renderDuration2.default)(note, lo);
	}
	
	function renderCell(cell, lo) {
	  cell.data.forEach(function (data) {
	    switch (data.$type) {
	      case 'rest':
	        renderNote(data, cell, lo);
	        break;
	      case 'note':
	        renderNote(data, cell, lo);
	        (0, _renderCurve2.default)('tie', data);
	        (0, _renderCurve2.default)('slur', data);
	        break;
	      case 'time':
	        data.el = cell.el.use(data.def.el).attr({ x: data.x, y: data.y });
	        break;
	      default:
	    }
	  });
	}
	
	exports.default = Renderer;

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _layoutOptions = __webpack_require__(25);
	
	var _layoutOptions2 = _interopRequireDefault(_layoutOptions);
	
	var _Defs = __webpack_require__(26);
	
	var _Defs2 = _interopRequireDefault(_Defs);
	
	var _SvgLayout = __webpack_require__(33);
	
	var _SvgLayout2 = _interopRequireDefault(_SvgLayout);
	
	var _BodyLayout = __webpack_require__(34);
	
	var _BodyLayout2 = _interopRequireDefault(_BodyLayout);
	
	var _HeaderLayout = __webpack_require__(35);
	
	var _HeaderLayout2 = _interopRequireDefault(_HeaderLayout);
	
	var _ContentLayout = __webpack_require__(36);
	
	var _ContentLayout2 = _interopRequireDefault(_ContentLayout);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @class
	 * @param svg {string}
	 * @param options {Object} Layout options
	 */
	var Layout = function () {
	  function Layout(svg, options) {
	    _classCallCheck(this, Layout);
	
	    this.options = options;
	    this.svg = svg;
	
	    this.svg = new _SvgLayout2.default(this);
	    this.body = new _BodyLayout2.default(this);
	    this.header = new _HeaderLayout2.default(this);
	    this.content = new _ContentLayout2.default(this);
	
	    this.defs = new _Defs2.default(this);
	  }
	
	  /**
	   * @param  {Score} score
	   */
	
	
	  _createClass(Layout, [{
	    key: 'flow',
	    value: function flow(score) {
	      init(this, score);
	      this.content.flow(score.measures);
	    }
	  }]);
	
	  return Layout;
	}();
	
	Layout.options = _layoutOptions2.default;
	
	function init(that, score) {
	  var measures = score.measures;
	
	  measures.forEach(function (measure, m) {
	    measure = measures[m];
	    measure.layout = that;
	    measure.parts.forEach(function (cell) {
	      cell.layout = that;
	      cell.flow();
	    });
	  });
	}
	
	exports.default = Layout;

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _util = __webpack_require__(2);
	
	var layoutOptions = {
	  mode: 'block', // inline | block | paper
	  // width: 650,
	  // height: 600,
	  marginTop: 25,
	  marginRight: 30,
	  marginBottom: 25,
	  marginLeft: 30,
	
	  fontSize: 20,
	  fontFamily: 'Helvetica, Arial, Sans Serif',
	
	  titleFontSize: '110%',
	  // titleFontFamily
	  titleFontWeight: 'bold',
	  composerFontSize: '90%',
	  // composerFontFamily:
	  composerFontWeight: 'bold',
	  // composerFontStyle,
	  timeFontSize: '95%',
	  timeFontWeight: 'bold',
	
	  headerSep: '100%',
	  systemSep: '180%',
	  musicDataSep: '20%',
	
	  partHeight: '120%',
	  partSep: '80%',
	
	  measurePaddingLeft: '50%',
	  measurePaddingRight: '50%',
	
	  barlineHeight: '120%',
	  thinBarlineWidth: '4%',
	  thickBarlineWidth: '16%',
	  barlineSep: '18%',
	  barlineDotRadius: '7.5%',
	  barlineDotSep: '22%',
	
	  accidentalFontSize: '95%',
	  accidentalShift: '10%',
	
	  octaveRadius: '6.6%',
	  octaveOffset: '0%',
	  octaveSep: '23%',
	
	  stepBaselineShift: '12%', // for step without lower octave and underline
	
	  typeStrokeWidth: '5%',
	  typebarOffset: '30%', // 1 - - -
	  typebarLength: '55%', // off len sep len sep len (dot) ext
	  typebarSep: '45%', // 1 -
	  typebarExt: '20%', // off len (dot) ext
	  underbarSep: '17%',
	
	  dotOffset: '60%', // for type = 2
	  dotRadius: '6.6%', // 1 - . .
	  dotSep: '60%', // off len dotOff . dotSep . ext
	  t4DotOffset: '30%',
	  t4DotSep: '50%',
	  t4DotExt: '25%',
	  t4DotBaselineShift: '20%'
	};
	
	var fontSize = layoutOptions.fontSize;
	
	
	(0, _util.objEach)(layoutOptions, function (value, key) {
	  if (typeof value !== 'string') return;
	
	  var unit = value.replace(/[\d\.]+/, '');
	  value = +value.replace(/[^\d\.]+/, '');
	
	  switch (unit) {
	    case '%':
	      layoutOptions[key] = fontSize * value / 100;
	      break;
	    case '':
	    // fall through
	    case 'px':
	      layoutOptions[key] = value;
	      break;
	    case 'others to be implemented':
	      break;
	    default:
	  }
	});
	
	exports.default = layoutOptions;

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _AccidentalDef = __webpack_require__(27);
	
	var _AccidentalDef2 = _interopRequireDefault(_AccidentalDef);
	
	var _BarDef = __webpack_require__(29);
	
	var _BarDef2 = _interopRequireDefault(_BarDef);
	
	var _DurationDef = __webpack_require__(30);
	
	var _DurationDef2 = _interopRequireDefault(_DurationDef);
	
	var _PitchDef = __webpack_require__(31);
	
	var _PitchDef2 = _interopRequireDefault(_PitchDef);
	
	var _TimeDef = __webpack_require__(32);
	
	var _TimeDef2 = _interopRequireDefault(_TimeDef);
	
	var _Note = __webpack_require__(12);
	
	var _Note2 = _interopRequireDefault(_Note);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @class
	 * @param {Layout} layout
	 */
	var Defs = function () {
	  function Defs(layout) {
	    _classCallCheck(this, Defs);
	
	    this._layout = layout;
	  }
	
	  /**
	   * Get the svg def of the music data.
	   * @param  musicData {MusicDataMixin} music data
	   * @return {Def}
	   */
	
	
	  _createClass(Defs, [{
	    key: 'get',
	    value: function get(musicData) {
	      var id = musicData.defId;
	      return this[id] || (this[id] = makeDef(id, musicData, this));
	    }
	  }, {
	    key: 'getAccidental',
	    value: function getAccidental(accidental) {
	      var id = 'a' + accidental.replace(/#/g, 's');
	      return this[id] || (this[id] = new _AccidentalDef2.default(id, accidental, this._layout));
	    }
	  }, {
	    key: '_getPitch',
	    value: function _getPitch(id, note) {
	      return this[id] || (this[id] = new _PitchDef2.default(id, note, this));
	    }
	  }]);
	
	  return Defs;
	}();
	
	function makeDef(id, musicData, defs) {
	  switch (musicData.$type) {
	    case 'bar':
	      return new _BarDef2.default(id, musicData, defs._layout);
	    case 'time':
	      return new _TimeDef2.default(id, musicData, defs._layout);
	    case 'note':
	      return makeNoteDef(musicData, defs);
	    case 'rest':
	      return makeRestDef(musicData, defs);
	    case 'duration':
	      return new _DurationDef2.default(id, musicData, defs._layout);
	    default:
	      return { width: 0, height: 0 };
	  }
	}
	
	function makeNoteDef(note, defs) {
	  var underbar = note.duration.underbar;
	  var pitchId = note.pitch.defId + underbar;
	  var pitchDef = defs._getPitch(pitchId, note);
	  var durationDef = defs.get(note.duration);
	  return {
	    pitchDef: pitchDef,
	    durationDef: durationDef,
	    height: pitchDef.height,
	    width: pitchDef.width + durationDef.width * 1
	    // (underbar ? pitchDef.scale.x : 1)
	  };
	}
	
	function makeRestDef(rest, defs) {
	  var restNote = new _Note2.default({ pitch: { step: 0 }, duration: rest.duration });
	  return makeNoteDef(restNote, defs);
	}
	
	exports.default = Defs;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _snapsvg = __webpack_require__(8);
	
	var _snapsvg2 = _interopRequireDefault(_snapsvg);
	
	var _svgPaths = __webpack_require__(28);
	
	var _svgPaths2 = _interopRequireDefault(_svgPaths);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * SVG definition for accidental.
	 * @class
	 * @param {string} id         [description]
	 * @param {string} accidental [description]
	 * @param {Layout} layout     [description]
	 */
	function AccidentalDef(id, accidental, layout) {
	  var _layout$options = layout.options,
	      accidentalShift = _layout$options.accidentalShift,
	      accidentalFontSize = _layout$options.accidentalFontSize;
	
	  var el = this.el = layout.svg.el.g().attr('id', id);
	  var accKey = accidental.replace(/bb/, 'b'); // double flat to be synthesized
	  var pathData = _svgPaths2.default[accKey];
	  var ratio = _svgPaths2.default.ACCIDENTAL_RATIOS[accKey];
	  var shift = _svgPaths2.default.ACCIDENTAL_SHIFTS[accKey];
	  var path = el.path(pathData);
	  var bb = el.getBBox();
	
	  path.transform(_snapsvg2.default.matrix().translate(0.1 * accidentalShift, -accidentalShift).scale(ratio * accidentalFontSize).translate(-bb.x, shift - bb.y2));
	
	  // Combine two flat to be double flat.
	  if (accidental === 'bb') {
	    el.use(path).attr('x', accidentalFontSize * 0.24);
	    el.transform('scale(0.9,1)');
	  }
	
	  bb = el.getBBox();
	  this.width = bb.width * 1.2;
	
	  el.toDefs();
	}
	
	exports.default = AccidentalDef;

/***/ },
/* 28 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var svgPaths = {
	  // https://upload.wikimedia.org/wikipedia/commons/a/a6/Sharp.svg
	  '#': 'M6.102,7.457V2.753L8.102,2.201V6.881L6.102,7.457zM10.04,6.319L8.665,6.713V2.033L10.04,1.649V-0.295L8.665,0.089V-4.69277H8.102V0.234L6.102,0.809V-3.84077H5.571V0.986L4.196,1.371V3.319L5.571,2.935V7.606L4.196,7.989V9.929L5.571,9.545V14.299L6.102,14.29977V9.375L8.102,8.825V13.45077H8.665V8.651L10.04,8.266V6.319z',
	
	  // https://upload.wikimedia.org/wikipedia/commons/3/3a/DoubleSharp.svg
	  '##': 'M5.009,8.30721C4.27443,8.19192 3.52769,8.19209 2.7858,8.19294C2.77007,7.65011 2.85674,7.0729 2.6415,6.56343C2.49821,6.22426 2.22532,5.95665 1.98269,5.68155C1.59552,6.0278 1.27751,6.48475 1.24704,7.01638C1.21706,7.40767 1.23902,7.80085 1.2322,8.19294C0.4904,8.20416-0.25918,8.16828-0.991,8.314C-0.84988,7.5863-0.88195,6.84171-0.86917,6.1048C-0.3043,6.08953 0.30023,6.17101 0.82484,5.92526C1.13441,5.78023 1.39653,5.55295 1.6591,5.33676C1.3173,4.94965 0.87346,4.60861 0.33665,4.57651C-0.06427,4.54485-0.46734,4.56793-0.86917,4.56097C-0.89434,3.82949-0.80895,3.08855-0.96079,2.3663C-0.23733,2.49697 0.50065,2.46343 1.2322,2.47284C1.24306,2.99383 1.18483,3.53381 1.33191,4.0355C1.44414,4.41838 1.74978,4.71293 2.0051,5.01521C2.36553,4.70111 2.69057,4.30706 2.75011,3.81412C2.804,3.36793 2.76123,2.91977 2.7858,2.47284C3.52263,2.45348 4.28215,2.54713 4.99535,2.314C4.88891,3.05711 4.87889,3.81152 4.88717,4.56097C4.36127,4.57582 3.80954,4.51747 3.30955,4.69457C2.92975,4.8291 2.63114,5.12341 2.32869,5.38325C2.65661,5.71867 3.0516,6.02802 3.5403,6.07368C3.98834,6.11554 4.43829,6.09658 4.88717,6.1048C4.89828,6.83958 4.86193,7.5825 5.009,8.30721z',
	
	  // https://upload.wikimedia.org/wikipedia/commons/b/ba/Flat.svg
	  b: 'M8.166,3.657C8.166,4.232 7.950425,4.78273 7.359,5.52188C6.732435,6.30494 6.205,6.75313 5.51,7.28013V3.848C5.668,3.449 5.901,3.126 6.21,2.878C6.518,2.631 6.83,2.507 7.146,2.507C7.668,2.507 7.999,2.803 8.142,3.393C8.158,3.441 8.166,3.529 8.166,3.657zM8.091,1.257C7.66,1.257 7.222,1.376 6.776,1.615C6.33,1.853 5.908,2.172 5.51,2.569V-4.70267H4.947 V7.75213C4.947,8.10413 5.043,8.28013 5.235,8.28013C5.346,8.28013 5.483913,8.18713 5.69,8.06413C6.27334,7.71598 6.636935,7.48332 7.032,7.23788C7.482617,6.95792 7.99,6.631 8.661,5.991C9.124,5.526 9.459,5.057 9.667,4.585C9.874,4.112 9.978,3.644 9.978,3.179C9.978,2.491 9.795,2.002 9.429,1.713C9.015,1.409 8.568,1.257 8.091,1.257z',
	
	  // https://upload.wikimedia.org/wikipedia/commons/f/f4/Music-natural.svg
	  n: 'M 0,14.112V41.52h-1.248V31.248l-6.672,1.728V5.232h1.2v10.704l6.72,-1.824zm-6.72,6.432v7.536l5.472,-1.44v-7.536l-5.472,1.44z',
	
	  ACCIDENTAL_RATIOS: { '#': 0.043, 'n': 0.023, '##': 0.062, b: 0.057 },
	  ACCIDENTAL_SHIFTS: { '#': 1, 'n': 2, '##': -4, b: 0 }
	};
	
	exports.default = svgPaths;

/***/ },
/* 29 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * SVG definition for barline.
	 * @class
	 * @param {string} id     [description]
	 * @param {Bar} bar    [description]
	 * @param {Layout} layout [description]
	 */
	function BarDef(id, bar, layout) {
	  var _layout$options = layout.options,
	      thinBarlineWidth = _layout$options.thinBarlineWidth,
	      thickBarlineWidth = _layout$options.thickBarlineWidth,
	      barlineSep = _layout$options.barlineSep,
	      barlineDotSep = _layout$options.barlineDotSep,
	      barlineDotRadius = _layout$options.barlineDotRadius;
	
	  var x = 0;
	  var lineWidth = void 0;
	  this.el = layout.svg.el.g().attr('id', id).toDefs();
	
	  switch (bar.value) {
	    case 'single':
	      lineWidth = thinBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth;
	      break;
	    case 'double':
	      lineWidth = thinBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth + barlineSep;
	      addBarline(this, x, lineWidth);
	      x += lineWidth;
	      break;
	    case 'end':
	      lineWidth = thinBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth + barlineSep;
	      lineWidth = thickBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth;
	      break;
	    case 'repeat-begin':
	      lineWidth = thickBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth + barlineSep;
	      lineWidth = thinBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth + barlineDotSep + barlineDotRadius;
	      break;
	    case 'repeat-end':
	      x = barlineDotSep + barlineDotRadius;
	      lineWidth = thinBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth + barlineSep;
	      lineWidth = thickBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth;
	      break;
	    case 'repeat-both':
	      x = barlineDotSep + barlineDotRadius;
	      lineWidth = thinBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth + barlineSep;
	      lineWidth = thickBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth + barlineSep;
	      lineWidth = thinBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth + barlineDotSep + barlineDotRadius;
	      break;
	    default:
	  }
	  this.width = x;
	}
	
	function addBarline(that, x, width) {
	  that.el.rect(x, 0, width, 1);
	}
	
	exports.default = BarDef;

/***/ },
/* 30 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * SVG definition for duration.
	 * @class
	 * @param {string} id       [description]
	 * @param {Duration} duration [description]
	 * @param {Layout} layout   [description]
	 */
	function DurationDef(id, duration, layout) {
	  this._id = id;
	  this._layout = layout;
	
	  // only make def el for:
	  // id = d10, d11, d12, d20, d21, d20, d41, d40
	  switch (duration.type) {
	    case 1:
	      // whole note
	      makeEl(this);
	      makeType1(this, id, duration.dot);
	      break;
	    case 2:
	      // half note
	      makeEl(this);
	      makeType2(this, id, duration.dot);
	      break;
	    default:
	      // other note types type quarter note def
	      if (duration.dot === 0) {
	        this.width = 0;
	      } else {
	        makeEl(this);
	        makeType4(this, id, duration.dot);
	      }
	  }
	}
	
	function makeType1(that, id, dot) {
	  var _that$_layout$options = that._layout.options,
	      typebarLength = _that$_layout$options.typebarLength,
	      typebarSep = _that$_layout$options.typebarSep,
	      typebarOffset = _that$_layout$options.typebarOffset;
	
	  var x = typebarOffset;
	
	  addLine(that, x);
	  x += typebarLength + typebarSep;
	  addLine(that, x);
	  x += typebarLength + typebarSep;
	  addLine(that, x);
	  x += typebarLength;
	
	  that.width = addDot(that, x, dot, 1);
	}
	
	function makeType2(that, id, dot) {
	  var _that$_layout$options2 = that._layout.options,
	      typebarOffset = _that$_layout$options2.typebarOffset,
	      typebarLength = _that$_layout$options2.typebarLength;
	
	  var x = typebarOffset;
	
	  addLine(that, typebarOffset);
	  x += typebarLength;
	  that.width = addDot(that, x, dot, 2);
	}
	
	function makeType4(that, id, dot) {
	  var _that$_layout$options3 = that._layout.options,
	      t4DotOffset = _that$_layout$options3.t4DotOffset,
	      t4DotBaselineShift = _that$_layout$options3.t4DotBaselineShift,
	      t4DotSep = _that$_layout$options3.t4DotSep,
	      t4DotExt = _that$_layout$options3.t4DotExt,
	      dotRadius = _that$_layout$options3.dotRadius;
	
	  var x = t4DotOffset;
	
	  that.el.circle(x, -t4DotBaselineShift, dotRadius);
	
	  if (dot > 1) {
	    x += t4DotSep;
	    that.el.circle(x, -t4DotBaselineShift, dotRadius);
	  }
	  that.width = x + t4DotExt;
	}
	
	function makeEl(that) {
	  that.el = that._layout.svg.el.g().attr('id', that._id).toDefs();
	}
	
	function addLine(that, x) {
	  var _that$_layout$options4 = that._layout.options,
	      typeStrokeWidth = _that$_layout$options4.typeStrokeWidth,
	      typebarLength = _that$_layout$options4.typebarLength;
	
	  that.el.rect(x, -typeStrokeWidth, typebarLength, typeStrokeWidth);
	}
	
	// Add dot for type 1 (whole) or type 2 (half) note.
	function addDot(that, x, dot, type) {
	  var _that$_layout$options5 = that._layout.options,
	      dotOffset = _that$_layout$options5.dotOffset,
	      dotSep = _that$_layout$options5.dotSep,
	      dotRadius = _that$_layout$options5.dotRadius,
	      typebarExt = _that$_layout$options5.typebarExt;
	
	
	  if (dot > 0) {
	    x += dotOffset * (type === 1 ? 1.2 : 1);
	    that.el.circle(x, 0, dotRadius);
	  }
	  if (dot > 1) {
	    x += dotSep * (type === 1 ? 1.2 : 1);
	    that.el.circle(x, 0, dotRadius);
	  }
	  return x + typebarExt;
	}
	
	exports.default = DurationDef;

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _snapsvg = __webpack_require__(8);
	
	var _snapsvg2 = _interopRequireDefault(_snapsvg);
	
	var _util = __webpack_require__(2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * SVG definition for pitch.
	 * The `PitchDef` is defined by properties: a s o u
	 * accidental step octave underbar
	 * @class
	 * @param id {string}     [description]
	 * @param pitch {Pitch}   [description]
	 * @param layout {Layout} [description]
	 */
	function PitchDef(id, note, defs) {
	  var layout = this._layout = defs._layout;
	  var _note$pitch = note.pitch,
	      accidental = _note$pitch.accidental,
	      octave = _note$pitch.octave;
	  // const scale = getScale(accidental, octave, underbar)
	
	  var el = this.el = layout.svg.el.g().attr({
	    id: id,
	    stroke: 'black',
	    strokeWidth: 0.1
	  });
	  var matrix = void 0,
	      sbbox = void 0,
	      pbbox = void 0;
	
	  this._defs = defs;
	  addAccidental(this, accidental);
	  addStep(this, note.pitch.step);
	  addOctave(this, octave, note.duration.underbar);
	
	  matrix = getMatrix(this, octave);
	  el.transform(matrix);
	
	  // 此处的_sbbox就是加了step的bounding box，是addStep和addOctave创建和修改的
	  sbbox = this._sbbox;
	  sbbox = getBBoxAfterTransform(this.el, sbbox, matrix);
	
	  pbbox = el.getBBox();
	  el.toDefs();
	
	  (0, _util.extend)(this, {
	    matrix: matrix,
	    width: pbbox.width,
	    height: -pbbox.y,
	    stepCx: sbbox.cx,
	    stepY: sbbox.y,
	    stepCy: sbbox.cy,
	    stepY2: sbbox.y2,
	    stepTop: octave > 0 ? pbbox.y : sbbox.y + layout.options.fontSize * 0.2
	  });
	}
	
	function addAccidental(that, accidental) {
	  if (!accidental) {
	    that._accidentalX2 = 0;
	    return;
	  }
	  var accDef = that._defs.getAccidental(accidental);
	  that.el.use(accDef.el).attr('y', -that._layout.options.accidentalShift);
	  that._accidentalX2 = accDef.width;
	}
	
	// step在这里就是音阶的数字
	function addStep(that, step) {
	  that._sbbox = that.el.text(that._accidentalX2, 0, '' + step).attr('font-size', that._layout.options.fontSize).getBBox();
	}
	
	function addOctave(that, octave, underbar) {
	  if (!octave) return;
	
	  var _that$_layout$options = that._layout.options,
	      octaveRadius = _that$_layout$options.octaveRadius,
	      octaveOffset = _that$_layout$options.octaveOffset,
	      octaveSep = _that$_layout$options.octaveSep;
	
	  var octaveEl = that.el.g();
	
	  // 加上八度和音的点
	  if (octave > 0) {
	    for (var i = 0; i < octave; i++) {
	      octaveEl.circle(that._sbbox.cx, that._sbbox.y + octaveOffset - octaveSep * i, octaveRadius);
	    }
	  } else {
	
	    for (var _i = 0; _i > octave; _i--) {
	      octaveEl.circle(that._sbbox.cx, that._sbbox.y2 - octaveOffset - octaveSep * _i - underbar ? underbar * that._layout.options.underbarSep : 0, octaveRadius);
	    }
	  }
	  that.el.add(octaveEl);
	}
	
	// Transform the pitch to be in a good baseline position and
	// scale it to be more square.
	function getMatrix(that, octave) {
	  var _that$_layout$options2 = that._layout.options,
	      stepBaselineShift = _that$_layout$options2.stepBaselineShift,
	      underbarSep = _that$_layout$options2.underbarSep;
	
	  var pbbox = that.el.getBBox();
	
	  // 关键：如果octave大于等于0，同时下面也没有线，dy就是-stepBaselineShift, 否则
	  // 就是0，还要加上underBar * underBarSep
	  // const dy = (octave >= 0 && underbar === 0 ? -stepBaselineShift : 0) -
	  //                         underbar * underbarSep
	  return _snapsvg2.default.matrix();
	  // .translate(-pbbox.x, 0)
	  // .translate(0, near(pbbox.y2, that._sbbox.y2) ? 0 : -pbbox.y2)
	}
	
	// 将bounding box平移到合适位置
	function getBBoxAfterTransform(container, bbox, matrix) {
	  var rect = container.rect(bbox.x, bbox.y, bbox.width, bbox.height);
	  var g = container.g(rect);
	  rect.transform(matrix);
	  bbox = g.getBBox();
	  g.remove();
	  return bbox;
	}
	
	function getScale(hasAccidental, octave, underbar) {
	  var absOctave = Math.abs(octave);
	  return {
	    x: Math.pow(0.97, absOctave + underbar + (hasAccidental ? 2 : 0)),
	    y: Math.pow(0.95, absOctave + underbar + (hasAccidental ? 1 : 0))
	  };
	}
	
	exports.default = PitchDef;

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _snapsvg = __webpack_require__(8);
	
	var _snapsvg2 = _interopRequireDefault(_snapsvg);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * SVG definition for time signature.
	 * @class
	 * @param {string} id     [description]
	 * @param {Time} time   [description]
	 * @param {Layout} layout [description]
	 */
	function TimeDef(id, time, layout) {
	  var _layout$options = layout.options,
	      fontSize = _layout$options.timeFontSize,
	      fontWeight = _layout$options.timeFontWeight;
	
	  var lineExtend = fontSize * 0.1;
	  var el = this.el = layout.svg.el.g().attr({
	    id: id,
	    fontSize: fontSize,
	    fontWeight: fontWeight,
	    textAnchor: 'middle'
	  });
	  var lineY = -0.85 * fontSize;
	  var bb = void 0;
	
	  el.text(0, -1 * fontSize, time.beats);
	  el.text(0, 0, time.beatType); // baseline y = 0
	  bb = el.getBBox();
	  el.line(bb.x - lineExtend, lineY, bb.x2 + lineExtend, lineY);
	  el.transform(_snapsvg2.default.matrix().scale(1, 0.8).translate(lineExtend - bb.x, 0));
	
	  bb = el.getBBox();
	  el.toDefs();
	
	  this.width = bb.width;
	  this.height = -bb.y;
	}
	
	exports.default = TimeDef;

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _snapsvg = __webpack_require__(8);
	
	var _snapsvg2 = _interopRequireDefault(_snapsvg);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @class
	 * @param layout {Layout}
	 */
	var SvgLayout = function () {
	  function SvgLayout(layout) {
	    _classCallCheck(this, SvgLayout);
	
	    this._layout = layout;
	    var _layout$options = layout.options,
	        fontFamily = _layout$options.fontFamily,
	        width = _layout$options.width;
	
	    this._el = (0, _snapsvg2.default)(layout.svg).attr({ fontFamily: fontFamily }).addClass('musje');
	    this.el.clear();
	    this.width = width;
	  }
	
	  _createClass(SvgLayout, [{
	    key: 'el',
	    get: function get() {
	      return this._el;
	    }
	
	    /**
	     * Width of the svg.
	     * @type {number}
	     */
	
	  }, {
	    key: 'width',
	    get: function get() {
	      return this._w;
	    },
	    set: function set(w) {
	      this._w = w;
	      this.el.attr('width', w);
	      var body = this._layout.body;
	
	      if (body) body.width = w;
	    }
	
	    /**
	     * Height of the svg.
	     * @type {number}
	     */
	
	  }, {
	    key: 'height',
	    get: function get() {
	      return this._h;
	    },
	    set: function set(h) {
	      this._h = h;
	      this.el.attr('height', h);
	    }
	  }]);
	
	  return SvgLayout;
	}();
	
	exports.default = SvgLayout;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _snapsvg = __webpack_require__(8);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Body
	 * @class
	 * @param {Layout} layout
	 */
	var BodyLayout = function () {
	  function BodyLayout(layout) {
	    _classCallCheck(this, BodyLayout);
	
	    this._layout = layout;
	    var svg = layout.svg,
	        options = layout.options;
	    var marginTop = options.marginTop,
	        marginRight = options.marginRight,
	        marginLeft = options.marginLeft,
	        width = options.width;
	
	    this._el = svg.el.g().transform((0, _snapsvg.matrix)().translate(marginLeft, marginTop)).addClass('mus-body');
	    this.width = width - marginLeft - marginRight;
	  }
	
	  _createClass(BodyLayout, [{
	    key: 'el',
	    get: function get() {
	      return this._el;
	    }
	
	    /**
	     * Width of the body.
	     * - (Getter) Get the body width.
	     * - (Setter) Set the body width and this also induces setting the
	     * header and content width if one exists.
	     * @type {number}
	     */
	
	  }, {
	    key: 'width',
	    get: function get() {
	      return this._w;
	    },
	    set: function set(w) {
	      this._w = w;
	      var layout = this._layout;
	      if (layout.header) layout.header.width = w;
	      if (layout.content) layout.content.width = w;
	    }
	
	    /**
	     * Height of the body.
	     * - (Getter) Get the body height.
	     * - (Setter) Set the body height and this will also cause the height of svg to vary.
	     * @type {number}
	     */
	
	  }, {
	    key: 'height',
	    get: function get() {
	      return this._h;
	    },
	    set: function set(h) {
	      var layout = this._layout;
	      var _layout$options = layout.options,
	          marginTop = _layout$options.marginTop,
	          marginBottom = _layout$options.marginBottom;
	
	      layout.svg.height = h + marginTop + marginBottom;
	      this._h = h;
	    }
	  }]);
	
	  return BodyLayout;
	}();
	
	exports.default = BodyLayout;

/***/ },
/* 35 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Header layout.
	 * @param {Layout} layout
	 */
	var HeaderLayout = function () {
	  function HeaderLayout(layout) {
	    _classCallCheck(this, HeaderLayout);
	
	    this._layout = layout;
	    this.el = layout.body.el.g().addClass('mus-header');
	    this.width = layout.body.width;
	  }
	
	  /**
	   * Width of the header.
	   * @type {number}
	   */
	
	
	  _createClass(HeaderLayout, [{
	    key: 'width',
	    get: function get() {
	      return this._w;
	    },
	    set: function set(w) {
	      this._w = w;
	    }
	
	    /**
	     * Height of the header.
	     * @type {number}
	     */
	
	  }, {
	    key: 'height',
	    get: function get() {
	      return this._h;
	    },
	    set: function set(h) {
	      this._h = h;
	      var _layout = this._layout,
	          content = _layout.content,
	          options = _layout.options;
	
	      content.y = h ? h + options.headerSep : 0;
	    }
	  }]);
	
	  return HeaderLayout;
	}();
	
	exports.default = HeaderLayout;

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _snapsvg = __webpack_require__(8);
	
	var _SystemLayout = __webpack_require__(37);
	
	var _SystemLayout2 = _interopRequireDefault(_SystemLayout);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @class
	 * @param {Object} layout - Reference to the parent layout instance.
	 */
	var ContentLayout = function () {
	  function ContentLayout(layout) {
	    _classCallCheck(this, ContentLayout);
	
	    this.layout = layout;
	    this.el = layout.body.el.g().addClass('mus-content');
	    this.width = layout.body.width;
	  }
	
	  _createClass(ContentLayout, [{
	    key: 'flow',
	
	
	    /**
	     * @param scoreMeasure {musje.TimewiseMeasures} The timewise score measure.
	     */
	    value: function flow(scoreMeasures) {
	      makeSystems(this, scoreMeasures);
	      balanceSystems(this);
	      this.systems.forEach(function (system) {
	        system.flow();
	      });
	    }
	  }, {
	    key: 'y',
	    get: function get() {
	      return this._y;
	    },
	    set: function set(y) {
	      this._y = y;
	      this.el.transform((0, _snapsvg.matrix)().translate(0, y));
	      resizeBody(this);
	    }
	  }, {
	    key: 'width',
	    get: function get() {
	      return this._w;
	    },
	    set: function set(w) {
	      this._w = w;
	    }
	  }, {
	    key: 'height',
	    get: function get() {
	      var last = this.systems[this.systems.length - 1];
	      return last ? last.y + last.height : 0;
	    }
	  }]);
	
	  return ContentLayout;
	}();
	
	function resizeBody(that) {
	  var layout = that.layout;
	  var hHeight = layout.header.height;
	
	  layout.body.height = that.height + (hHeight ? hHeight + layout.options.headerSep : 0);
	}
	
	/**
	 * Divide measures in timewise score into the systems.
	 * @param scoreMeasure {musje.TimewiseMeasures} The timewise score measure.
	 */
	function makeSystems(that, scoreMeasures) {
	  var layout = that.layout;
	  var _layout$options = layout.options,
	      measurePaddingRight = _layout$options.measurePaddingRight,
	      measurePaddingLeft = _layout$options.measurePaddingLeft;
	
	  var measurePadding = measurePaddingLeft + measurePaddingRight;
	  var systems = that.systems = [];
	  var system = new _SystemLayout2.default(layout, 0);
	  systems.push(system);
	
	  scoreMeasures.forEach(function (measure) {
	    var minWidth = measure.minWidth + measurePadding + (measure.barLeftInSystem.width + measure.barRightInSystem.width) / 2;
	
	    // Continue put this measure in the system.
	    if (system.minWidth + minWidth < that.width) {
	      system.measures.push(measure);
	
	      // New system
	    } else {
	      system = new _SystemLayout2.default(layout, systems.length);
	      systems.push(system);
	      system.measures.push(measure);
	    }
	  });
	}
	
	function getMaxLengthSystem(that) {
	  var maxLength = 0;
	  var system = void 0;
	
	  that.systems.forEach(function (system) {
	    maxLength = Math.max(maxLength, system.measures.length);
	  });
	
	  // Find the first max length system backward.
	  for (var i = that.systems.length - 1; i >= 0; i--) {
	    system = that.systems[i];
	    if (system.measures.length === maxLength) return system;
	  }
	}
	
	function isNotBalancable(that) {
	  var systems = that.systems,
	      width = that.width;
	  var length = systems.length;
	
	  return length === 1 || // only 1 system
	  length === 2 && systems[1].minWidth < width * 0.4; // 1 2/5 systems
	}
	
	function balanceSystems(that) {
	  if (isNotBalancable(that)) return;
	
	  var systems = that.systems;
	
	  var last = systems[systems.length - 1];
	  var system = getMaxLengthSystem(that);
	  var next = void 0,
	      prev = void 0;
	
	  // Move measures down to balance the last system.
	  while (last.measures.length < system.measures.length - 1) {
	
	    // Move a measure tail-to-head downward to the last measure.
	    while (true) {
	      next = system.next;
	      if (!next) break;
	      next.measures.unshift(system.measures.pop());
	      system = next;
	    }
	    system = getMaxLengthSystem(that);
	  }
	
	  // Move back measures if the system exceeds the content width.
	  system = last;
	  while (system) {
	    prev = system.prev;
	    while (system.minWidth > that.width) {
	      prev.measures.push(system.measures.shift());
	    }
	    system = prev;
	  }
	}
	
	exports.default = ContentLayout;

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _snapsvg = __webpack_require__(8);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @class
	 * @param {number} index
	 * @param {Layout} layout
	 */
	var SystemLayout = function () {
	  function SystemLayout(layout, index) {
	    _classCallCheck(this, SystemLayout);
	
	    this._index = index;
	    this._layout = layout;
	    this._el = layout.content.el.g().addClass('mus-system');
	  }
	
	  _createClass(SystemLayout, [{
	    key: 'flow',
	    value: function flow() {
	      var _this = this;
	
	      var minHeight = 0;
	      var x = 0;
	
	      tuneMeasuresWidths(this);
	
	      this.measures.forEach(function (measure, m) {
	        measure.system = _this;
	        measure._sIndex = m;
	        measure.flow();
	        measure.x = x;
	        x += measure.width;
	        minHeight = Math.max(minHeight, measure.minHeight);
	      });
	
	      var prev = this.prev;
	
	      this.y = prev ? prev.y + prev.height + this._layout.options.systemSep : 0;
	      this.height = minHeight;
	    }
	  }, {
	    key: 'el',
	    get: function get() {
	      return this._el;
	    }
	
	    /**
	     * Measures in a system.
	     * @type {Array.<TimewiseMeasure>}
	     * @readonly
	     */
	
	  }, {
	    key: 'measures',
	    get: function get() {
	      return this._measures || (this._measures = []);
	    }
	
	    /**
	     * Previous system.
	     * @type {SystemLayout}
	     */
	
	  }, {
	    key: 'prev',
	    get: function get() {
	      return this._layout.content.systems[this._index - 1];
	    }
	
	    /**
	     * Next system.
	     * @type {SystemLayout}
	     */
	
	  }, {
	    key: 'next',
	    get: function get() {
	      return this._layout.content.systems[this._index + 1];
	    }
	  }, {
	    key: 'y',
	    get: function get() {
	      return this._y;
	    },
	    set: function set(y) {
	      this._y = y;
	      this.el.transform((0, _snapsvg.matrix)().translate(0, y));
	    }
	  }, {
	    key: 'width',
	    get: function get() {
	      return this._layout.content.width;
	    }
	  }, {
	    key: 'minWidth',
	    get: function get() {
	      var min = 0;
	      this.measures.forEach(function (measure) {
	        min += measure.minWidth;
	      });
	      return min;
	    }
	  }, {
	    key: 'content',
	    get: function get() {
	      return this._layout.content;
	    }
	  }, {
	    key: 'systems',
	    get: function get() {
	      return this.content.systems;
	    }
	  }]);
	
	  return SystemLayout;
	}();
	
	function tuneMeasuresWidths(that) {
	  if (!isTunable(that)) return;
	
	  var pairs = getPairs(that.measures);
	  var length = pairs.length;
	  var widthLeft = that.width;
	  var itemLeft = length;
	  var i = 0; // i + itemLeft === length
	  var width;
	
	  while (i < length) {
	    if (widthLeft >= pairs[i].width * itemLeft) {
	      width = widthLeft / itemLeft;
	      do {
	        pairs[i].measure.width = width;
	        i++;
	      } while (i < length);
	      break;
	    } else {
	      width = pairs[i].width;
	      pairs[i].measure.width = width;
	      widthLeft -= width;
	      i++;
	      itemLeft--;
	    }
	  }
	}
	
	function isTunable(that) {
	  var ctWidth = that.content.width;
	  var s = that._index;
	  var ssLen = that.systems.length;
	  return ssLen > 2 || ssLen === 1 && that.minWidth > ctWidth * 0.7 || ssLen === 2 && (s === 0 || s === 1 && that.minWidth > ctWidth * 0.4);
	}
	
	var descendingSort = function descendingSort(a, b) {
	  return b.width - a.width;
	};
	
	var getPairs = function getPairs(measures) {
	  return measures.map(function (measure) {
	    return {
	      width: measure.minWidth,
	      measure: measure
	    };
	  }).sort(descendingSort);
	};
	
	exports.default = SystemLayout;

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = renderBar;
	
	var _snapsvg = __webpack_require__(8);
	
	function renderDots(el, x, radius, measureHeight) {
	  var cy = measureHeight / 2;
	  var dy = measureHeight * 0.15;
	
	  el.circle(x, cy - dy, radius);
	  el.circle(x, cy + dy, radius);
	}
	
	function render(bar, measure, lo) {
	  var barlineDotRadius = lo.barlineDotRadius;
	  var height = measure.height;
	
	  var el = measure.el.g().addClass('mus-barline');
	  el.use(bar.def.el).transform((0, _snapsvg.matrix)().scale(1, height));
	
	  switch (bar.value) {
	    case 'repeat-begin':
	      renderDots(el, bar.width - barlineDotRadius, barlineDotRadius, height);
	      break;
	    case 'repeat-end':
	      renderDots(el, barlineDotRadius, barlineDotRadius, height);
	      break;
	    case 'repeat-both':
	      renderDots(el, bar.width - barlineDotRadius, barlineDotRadius, height);
	      renderDots(el, barlineDotRadius, barlineDotRadius, height);
	      break;
	    default:
	  }
	
	  return el;
	}
	
	var translate = function translate(el, x) {
	  el.transform((0, _snapsvg.matrix)().translate(x, 0));
	};
	
	// @param m {number} Measure index in measures.
	// @param len {number} Length of measures.
	function renderBar(measure, lo) {
	  var bar = measure.barRightInSystem;
	  var el = void 0;
	
	  if (bar.def) {
	    el = render(bar, measure, lo);
	
	    // Align end in system end.
	    if (measure.inSystemEnd) translate(el, measure.width - bar.width);
	    // Others align middle.
	    else translate(el, measure.width - bar.width / 2);
	  }
	
	  // Render right bar and align begin in system begin.
	  if (measure.inSystemBegin) {
	    bar = measure.barLeftInSystem;
	    if (bar.def) render(bar, measure, lo);
	  }
	}

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _snapsvg = __webpack_require__(8);
	
	function renderDuration(note, lo) {
	  var _note$def = note.def,
	      durationDef = _note$def.durationDef,
	      pitchDef = _note$def.pitchDef;
	  var underbar = note.duration.underbar;
	
	  var y = 0;
	
	  // Whole and half notes
	  if (note.duration.type < 4) {
	    note.el.use(durationDef.el).attr({
	      x: pitchDef.width,
	      y: pitchDef.stepCy
	    });
	
	    // Quarter or shorter notes
	  } else {
	
	    // Add underbars for eigth or shorter notes
	    if (underbar) {
	      for (var i = 0; i < underbar; i++) {
	
	        // Only render beam for the begin one.
	        if (note.beams[i]) {
	          if (note.beams[i].value === 'begin') {
	
	            // render the bar from the beginning note to the ending note associated
	            // with the beginning note. Y stands for the starting height.
	            renderUnderbar(note, note.beams[i].endDurable, y, lo);
	          }
	
	          // Unbeamed underbar
	        } else {
	          //renders single note
	          renderUnderbar(note, note, y, lo);
	        }
	        y -= lo.underbarSep;
	      }
	    }
	
	    // Add dots
	    if (note.duration.dot) {
	      note.el.g().transform((0, _snapsvg.matrix)().translate(pitchDef.width, 0)).use(durationDef.el).transform(pitchDef.matrix);
	    }
	  }
	}
	
	function renderUnderbar(note1, note2, y, lo) {
	  note1.el.line(0, y, note2.x - note1.x + note2.width, y).attr('stroke-width', lo.typeStrokeWidth);
	}
	
	exports.default = renderDuration;

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = renderCurve;
	
	var _snapsvg = __webpack_require__(8);
	
	function getCurvePath(x1, y1, x2, y2) {
	  var dx = x2 - x1;
	  var dy = y2 - y1;
	  var c1x = 0; //-0.1 * dx
	  var c1y = 0; //-0.1 * dy
	  var c2x = dx; //1.1 * dx
	  var c2y = dy; //1.1 * dy
	
	  return (0, _snapsvg.format)('M{x1},{y1}c{c1x},{c1y} {c2x},{c2y} {dx},{dy}c{c3x},{c3y} {c4x},{c4y} {negDx},{negDy}', {
	    x1: x1,
	    y1: y1,
	    c1x: c1x,
	    c1y: c1y - 8,
	    c2x: c2x,
	    c2y: c2y - 8,
	    dx: dx,
	    dy: dy,
	    c3x: -c1x,
	    c3y: -c1y - 10,
	    c4x: -c2x,
	    c4y: -c2y - 10,
	    negDx: -dx,
	    negDy: -dy
	  });
	}
	
	function renderEndCurve(note, error) {
	  var _note$def$pitchDef = note.def.pitchDef,
	      x1 = _note$def$pitchDef.stepCx,
	      y1 = _note$def$pitchDef.stepTop;
	
	  var x2 = -note.systemX - 3;
	  var el = note.el.path(getCurvePath(x1, y1, x2, y1 - 3));
	
	  if (error) el.addClass('mus-error');
	  return el;
	}
	
	function renderBeginCurve(note, error) {
	  var _note$def$pitchDef2 = note.def.pitchDef,
	      x1 = _note$def$pitchDef2.stepCx,
	      y1 = _note$def$pitchDef2.stepTop;
	
	  var x2 = note.system.width - note.systemX + 3;
	  var el = note.el.path(getCurvePath(x1, y1, x2, y1 - 3));
	
	  if (error) el.addClass('mus-error');
	  return el;
	}
	
	function renderCompleteCurve(note1, note2, error) {
	  var _note1$def$pitchDef = note1.def.pitchDef,
	      x1 = _note1$def$pitchDef.stepCx,
	      y1 = _note1$def$pitchDef.stepTop;
	  var _note2$def$pitchDef = note2.def.pitchDef,
	      x2 = _note2$def$pitchDef.stepCx,
	      y2 = _note2$def$pitchDef.stepTop;
	
	  var noteDx = note2.systemX - note1.systemX;
	  var el = note1.el.path(getCurvePath(x1, y1, noteDx + x2, y2));
	
	  if (error) el.addClass('mus-error');
	  return el;
	}
	
	function renderCurve(type, note) {
	  if (note[type].end) {
	    var prev = note[type].prevParent;
	    var prevHasError = note[type].prevHasError;
	
	
	    if (!prev || prev.system !== note.system) renderEndCurve(note, prevHasError);else if (prevHasError) renderCompleteCurve(note, prev, prevHasError);
	  }
	
	  if (note[type].begin) {
	    var next = note[type].nextParent;
	    var nextHasError = note[type].nextHasError;
	
	
	    if (!next || next.system !== note.system) renderBeginCurve(note, nextHasError);else renderCompleteCurve(note, next, nextHasError);
	  }
	}

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _MIDI = __webpack_require__(42);
	
	var _MIDI2 = _interopRequireDefault(_MIDI);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var timeouts = [];
	
	var PlayerMixin = {
	
	  /**
	   * Start playing the song.
	   */
	  play: function play() {
	    var measures = this.parts[0].measures;
	
	    var time = 0; //audioCtx.currentTime
	
	    measures.forEach(function (cell) {
	      cell.data.forEach(function (data) {
	        switch (data.$type) {
	          case 'note':
	            // playNote(time, dur, freq)
	            timeouts.push(midiPlayNote(data, time));
	            time += data.duration.second;
	            break;
	          case 'rest':
	            time += data.duration.second;
	            break;
	          default:
	        }
	      });
	    });
	  },
	
	
	  /**
	   * Stop playing the song.
	   */
	  stop: function stop() {
	    timeouts.forEach(function (timeout) {
	      clearTimeout(timeout);
	    });
	    timeouts.length = 0;
	  }
	};
	
	// if (window.AudioContext) {
	//   var audioCtx = new window.AudioContext()
	//   var gainNode = audioCtx.createGain()
	//   gainNode.connect(audioCtx.destination)
	//   gainNode.gain.value = 0.5  // set the volume
	// }
	
	// // var oscillator = audioCtx.createOscillator()
	// // oscillator.connect(gainNode)
	// // oscillator.type = 'square' // sine | square | sawtooth | triangle | custom
	
	// function playNote(time, dur, freq) {
	//   if (!audioCtx) { return }
	
	//   var oscillator = audioCtx.createOscillator()
	//   oscillator.type = 'sine'
	//   oscillator.connect(audioCtx.destination)
	//   oscillator.frequency.value = freq
	//   oscillator.start(time)
	//   oscillator.stop(time + dur - 0.05)
	// }
	
	function midiPlayNote(note, time) {
	  var midiNumber = note.pitch.midiNumber;
	
	  var dur = note.duration.second;
	
	  function play() {
	    if (!note.tie.prevParent || note.tie.prevHasError) {
	      _MIDI2.default.noteOn(0, midiNumber, 100, 0);
	    }
	    if (!note.tie.nextParent || note.tie.nextHasError) {
	      _MIDI2.default.noteOff(0, midiNumber, dur);
	    }
	    note.el.addClass('mus-playing');
	    setTimeout(function () {
	      note.el.removeClass('mus-playing');
	    }, dur * 800 + 100);
	    console.log('Play: ' + note, time, dur, midiNumber);
	  }
	
	  return setTimeout(play, time * 800);
	}
	
	exports.default = PlayerMixin;

/***/ },
/* 42 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_42__;

/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA4NjQ0NTVkMzhjYmQ3N2UxZWIwYSIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGFyc2VyL3BhcnNlci5qaXNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvU2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVsL1Njb3JlSGVhZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvUGFydHdpc2VQYXJ0cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvUGFydHdpc2VQYXJ0LmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbC9DZWxsLmpzIiwid2VicGFjazovLy9leHRlcm5hbCB7XCJyb290XCI6XCJTbmFwXCIsXCJjb21tb25qczJcIjpcInNuYXBzdmdcIixcImNvbW1vbmpzXCI6XCJzbmFwc3ZnXCIsXCJhbWRcIjpcInNuYXBzdmdcIn0iLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVsL1RpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVsL011c2ljRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvQmFyLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbC9Ob3RlLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbC9QaXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvRHVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVsL1RpZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvU2x1ci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvUmVzdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvQ2hvcmQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVsL1ZvaWNlLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbC9CZWFtLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbC9UaW1ld2lzZU1lYXN1cmVzLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbC9UaW1ld2lzZU1lYXN1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlcmVyL1JlbmRlcmVyL1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXJlci9MYXlvdXQvTGF5b3V0LmpzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXJlci9MYXlvdXQvbGF5b3V0T3B0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvZGVmcy9EZWZzLmpzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXJlci9kZWZzL0FjY2lkZW50YWxEZWYuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlcmVyL3N2Z1BhdGhzLmpzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXJlci9kZWZzL0JhckRlZi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvZGVmcy9EdXJhdGlvbkRlZi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvZGVmcy9QaXRjaERlZi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvZGVmcy9UaW1lRGVmLmpzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXJlci9MYXlvdXQvU3ZnTGF5b3V0LmpzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXJlci9MYXlvdXQvQm9keUxheW91dC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvTGF5b3V0L0hlYWRlckxheW91dC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvTGF5b3V0L0NvbnRlbnRMYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlcmVyL0xheW91dC9TeXN0ZW1MYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlcmVyL1JlbmRlcmVyL3JlbmRlckJhci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvUmVuZGVyZXIvcmVuZGVyRHVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlcmVyL1JlbmRlcmVyL3JlbmRlckN1cnZlLmpzIiwid2VicGFjazovLy8uL3NyYy9wbGF5ZXIvUGxheWVyTWl4aW4uanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiTUlESVwiIl0sIm5hbWVzIjpbInByb3RvdHlwZSIsInJlbmRlciIsInN2ZyIsImxvIiwicGFyc2UiLCJpbnB1dCIsIlNjb3JlIiwiSVNfT0JKRUNUIiwiaXNPYmplY3QiLCJvYmoiLCJvYmpFYWNoIiwiY2FsbGJhY2siLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImV4dGVuZCIsImV4dCIsInZhbCIsIm5lYXIiLCJhIiwiYiIsIk1hdGgiLCJhYnMiLCJpc0FjY2Vzc29yUHJvcGVydHkiLCJ2YWx1ZSIsImdldCIsInNldCIsImRlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsInByb3AiLCJkZXNjcmlwdG9yIiwiY29uc3RhbnQiLCJ3cml0YWJsZSIsImVudW1lcmFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsInRvSlNPTldpdGhEZWZhdWx0IiwibWFrZVRvSlNPTiIsInZhbHVlcyIsImVsTmFtZSIsImlzRW1wdHkiLCJyZXN1bHQiLCJkZWZhdWx0VmFsdWUiLCJyZXMiLCJzY29yZSIsInRvSlNPTiIsImhlYWQiLCJ1bmRlZmluZWQiLCJwYXJ0cyIsInBhcnQiLCJwIiwibWVhc3VyZXMiLCJjZWxsIiwibSIsIndhbGtDZWxscyIsImRhdGEiLCJkIiwibWFwIiwidG9TdHJpbmciLCJqb2luIiwiX2hlYWQiLCJfcGFydHMiLCJyZW1vdmVBbGwiLCJhZGRQYXJ0cyIsImZyb21QYXJ0d2lzZSIsIl9tZWFzdXJlcyIsIlNjb3JlSGVhZCIsInRpdGxlIiwic3VidGl0bGUiLCJzdWJzdWJ0aXRsZSIsImNvbXBvc2VyIiwiYXJyYW5nZXIiLCJseXJpY2lzdCIsIlBhcnR3aXNlUGFydHMiLCJfc2NvcmUiLCJhcHBlbmQiLCJpbmRleCIsImxlbmd0aCIsIm11c2plUGFydCIsInB1c2giLCJBcnJheSIsIlBhcnR3aXNlUGFydCIsIl9pbmRleCIsIm1lYSIsIkNsYXNzZXMiLCJ0aW1lIiwiYmFyIiwibm90ZSIsInJlc3QiLCJjaG9yZCIsInZvaWNlIiwiQmFyIiwiQ2VsbCIsIm1JbmRleCIsInBJbmRleCIsIl9tSW5kZXgiLCJfcEluZGV4IiwibWFrZUJlYW1zIiwibXVzaWNEYXRhIiwidHlwZSIsImluc3RhbmNlIiwiX2NlbGwiLCJsYXlvdXQiLCJkZWZzIiwib3B0aW9ucyIsIm11c2ljRGF0YVNlcCIsIngiLCJtaW5IZWlnaHQiLCJkZWYiLCJ5Iiwid2lkdGgiLCJtaW4iLCJoZWlnaHQiLCJtaW5XaWR0aCIsIl9ib3hFbCIsImVsIiwicmVjdCIsImFkZENsYXNzIiwicmVtb3ZlIiwiX2RhdGEiLCJkYXR1bSIsImZpcnN0RGF0YSIsIiR0eXBlIiwicHJldkNlbGwiLCJwcmV2IiwiYmFyUmlnaHQiLCJsYXN0RGF0YSIsIl93IiwidyIsInJlZmxvdyIsInBhcnRIZWlnaHQiLCJfeCIsInRyYW5zZm9ybSIsInRyYW5zbGF0ZSIsInkyIiwicGFydFNlcCIsImJhckxlZnQiLCJtZWFzdXJlIiwiaW5TeXN0ZW1CZWdpbiIsInN5c3RlbSIsImluU3lzdGVtRW5kIiwidGhhdCIsImdyb3VwRHVyIiwiZ2V0QmVhbUdyb3VwcyIsImJlYW1MZXZlbCIsIm5leHRIYXNTYW1lQmVhbWxldmVsIiwibGV2ZWwiLCJuZXh0IiwiZ3JvdXAiLCJkdXJhdGlvbiIsInVuZGVyYmFyIiwiaSIsImJlYW1zIiwiZ3JvdXBzIiwiY291bnRlciIsImluR3JvdXAiLCJwdXRHcm91cCIsImR1ciIsInF1YXJ0ZXIiLCJUaW1lIiwiYmVhdHMiLCJiZWF0VHlwZSIsIk11c2ljRGF0YSIsInByZXZJblBhcnQiLCJuZXh0SW5QYXJ0IiwiYXR0ciIsIl95IiwiQkFSX1RPX1NUUklORyIsInNpbmdsZSIsImRvdWJsZSIsImVuZCIsIkJBUl9UT19JRCIsIl92YWx1ZSIsIk5vdGUiLCJwaXRjaCIsInRpZSIsInNsdXIiLCJiZWdpbiIsImFjY2lkZW50YWwiLCJzdGVwIiwib2N0YXZlIiwiZG90IiwicmVwbGFjZSIsIl9waXRjaCIsIl9kdXJhdGlvbiIsIl9iZWFtcyIsIl90aWUiLCJfc2x1ciIsIkE0X0ZSRVFVRU5DWSIsIkE0X01JRElfTlVNQkVSIiwiU1RFUF9UT19NSURJX05VTUJFUiIsIkFDQ0lERU5UQUxfVE9fQUxURVIiLCJuIiwiYmIiLCJjaGFycyIsImNoIiwibnVtIiwib2N0YXZlU3RyaW5nIiwiUGl0Y2giLCJwYXJlbnQiLCJfcGFyZW50IiwiYWx0ZXJMaW5rIiwiYWx0ZXIiLCJwcmV2RGF0YSIsInBvdyIsIm1pZGlOdW1iZXIiLCJUWVBFX1RPX1NUUklORyIsIlRZUEVfVE9fVU5ERVJCQVIiLCJET1RfVE9fU1RSSU5HIiwiRHVyYXRpb24iLCJUaWUiLCJwcmV2UGFyZW50IiwicHJldkR1cmFibGVJblBhcnQiLCJuZXh0RHVyYWJsZUluUGFydCIsIm5leHRQYXJlbnQiLCJTbHVyIiwiUmVzdCIsIkNob3JkIiwicGl0Y2hlcyIsIl9waXRjaGVzIiwiVm9pY2UiLCJCZWFtIiwiX2xldmVsIiwibmV4dERhdGEiLCJUaW1ld2lzZU1lYXN1cmVzIiwiVGltZXdpc2VNZWFzdXJlIiwiZyIsIm91dGVyV2lkdGhMZWZ0Iiwic3Ryb2tlIiwiZmlsbCIsIl9lbCIsIm1heCIsInBhZGRpbmciLCJfcyIsIm1lYXN1cmVQYWRkaW5nUmlnaHQiLCJtZWFzdXJlUGFkZGluZ0xlZnQiLCJvdXRlcldpZHRoUmlnaHQiLCJiYXJMZWZ0SW5TeXN0ZW0iLCJiYXJSaWdodEluU3lzdGVtIiwib3V0ZXJXaWR0aCIsIlNuYXAiLCJtYXRyaXgiLCJfc0luZGV4IiwiUmVuZGVyZXIiLCJfbG8iLCJmbG93IiwicmVuZGVySGVhZGVyIiwicmVuZGVyQ29udGVudCIsImhlYWRlciIsInRleHQiLCJ0aXRsZUZvbnRTaXplIiwiZm9udFNpemUiLCJmb250V2VpZ2h0IiwidGl0bGVGb250V2VpZ2h0IiwidGV4dEFuY2hvciIsImNvbXBvc2VyRm9udFNpemUiLCJjb21wb3NlckZvbnRXZWlnaHQiLCJnZXRCQm94IiwiY29udGVudCIsInN5c3RlbXMiLCJyZW5kZXJDZWxsIiwicmVuZGVyTm90ZSIsInVzZSIsInBpdGNoRGVmIiwiTGF5b3V0IiwiYm9keSIsImluaXQiLCJsYXlvdXRPcHRpb25zIiwibW9kZSIsIm1hcmdpblRvcCIsIm1hcmdpblJpZ2h0IiwibWFyZ2luQm90dG9tIiwibWFyZ2luTGVmdCIsImZvbnRGYW1pbHkiLCJ0aW1lRm9udFNpemUiLCJ0aW1lRm9udFdlaWdodCIsImhlYWRlclNlcCIsInN5c3RlbVNlcCIsImJhcmxpbmVIZWlnaHQiLCJ0aGluQmFybGluZVdpZHRoIiwidGhpY2tCYXJsaW5lV2lkdGgiLCJiYXJsaW5lU2VwIiwiYmFybGluZURvdFJhZGl1cyIsImJhcmxpbmVEb3RTZXAiLCJhY2NpZGVudGFsRm9udFNpemUiLCJhY2NpZGVudGFsU2hpZnQiLCJvY3RhdmVSYWRpdXMiLCJvY3RhdmVPZmZzZXQiLCJvY3RhdmVTZXAiLCJzdGVwQmFzZWxpbmVTaGlmdCIsInR5cGVTdHJva2VXaWR0aCIsInR5cGViYXJPZmZzZXQiLCJ0eXBlYmFyTGVuZ3RoIiwidHlwZWJhclNlcCIsInR5cGViYXJFeHQiLCJ1bmRlcmJhclNlcCIsImRvdE9mZnNldCIsImRvdFJhZGl1cyIsImRvdFNlcCIsInQ0RG90T2Zmc2V0IiwidDREb3RTZXAiLCJ0NERvdEV4dCIsInQ0RG90QmFzZWxpbmVTaGlmdCIsInVuaXQiLCJEZWZzIiwiX2xheW91dCIsImlkIiwiZGVmSWQiLCJtYWtlRGVmIiwibWFrZU5vdGVEZWYiLCJtYWtlUmVzdERlZiIsInBpdGNoSWQiLCJfZ2V0UGl0Y2giLCJkdXJhdGlvbkRlZiIsInJlc3ROb3RlIiwiQWNjaWRlbnRhbERlZiIsImFjY0tleSIsInBhdGhEYXRhIiwicmF0aW8iLCJBQ0NJREVOVEFMX1JBVElPUyIsInNoaWZ0IiwiQUNDSURFTlRBTF9TSElGVFMiLCJwYXRoIiwic2NhbGUiLCJ0b0RlZnMiLCJzdmdQYXRocyIsIkJhckRlZiIsImxpbmVXaWR0aCIsImFkZEJhcmxpbmUiLCJEdXJhdGlvbkRlZiIsIl9pZCIsIm1ha2VFbCIsIm1ha2VUeXBlMSIsIm1ha2VUeXBlMiIsIm1ha2VUeXBlNCIsImFkZExpbmUiLCJhZGREb3QiLCJjaXJjbGUiLCJQaXRjaERlZiIsInN0cm9rZVdpZHRoIiwic2Jib3giLCJwYmJveCIsIl9kZWZzIiwiYWRkQWNjaWRlbnRhbCIsImFkZFN0ZXAiLCJhZGRPY3RhdmUiLCJnZXRNYXRyaXgiLCJfc2Jib3giLCJnZXRCQm94QWZ0ZXJUcmFuc2Zvcm0iLCJzdGVwQ3giLCJjeCIsInN0ZXBZIiwic3RlcEN5IiwiY3kiLCJzdGVwWTIiLCJzdGVwVG9wIiwiX2FjY2lkZW50YWxYMiIsImFjY0RlZiIsImdldEFjY2lkZW50YWwiLCJvY3RhdmVFbCIsImFkZCIsImNvbnRhaW5lciIsImJib3giLCJnZXRTY2FsZSIsImhhc0FjY2lkZW50YWwiLCJhYnNPY3RhdmUiLCJUaW1lRGVmIiwibGluZUV4dGVuZCIsImxpbmVZIiwibGluZSIsIngyIiwiU3ZnTGF5b3V0IiwiY2xlYXIiLCJfaCIsImgiLCJCb2R5TGF5b3V0IiwiSGVhZGVyTGF5b3V0IiwiQ29udGVudExheW91dCIsInNjb3JlTWVhc3VyZXMiLCJtYWtlU3lzdGVtcyIsImJhbGFuY2VTeXN0ZW1zIiwicmVzaXplQm9keSIsImxhc3QiLCJoSGVpZ2h0IiwibWVhc3VyZVBhZGRpbmciLCJnZXRNYXhMZW5ndGhTeXN0ZW0iLCJtYXhMZW5ndGgiLCJpc05vdEJhbGFuY2FibGUiLCJ1bnNoaWZ0IiwicG9wIiwiU3lzdGVtTGF5b3V0IiwidHVuZU1lYXN1cmVzV2lkdGhzIiwiaXNUdW5hYmxlIiwicGFpcnMiLCJnZXRQYWlycyIsIndpZHRoTGVmdCIsIml0ZW1MZWZ0IiwiY3RXaWR0aCIsInMiLCJzc0xlbiIsImRlc2NlbmRpbmdTb3J0Iiwic29ydCIsInJlbmRlckJhciIsInJlbmRlckRvdHMiLCJyYWRpdXMiLCJtZWFzdXJlSGVpZ2h0IiwiZHkiLCJyZW5kZXJEdXJhdGlvbiIsInJlbmRlclVuZGVyYmFyIiwiZW5kRHVyYWJsZSIsIm5vdGUxIiwibm90ZTIiLCJyZW5kZXJDdXJ2ZSIsImdldEN1cnZlUGF0aCIsIngxIiwieTEiLCJkeCIsImMxeCIsImMxeSIsImMyeCIsImMyeSIsImMzeCIsImMzeSIsImM0eCIsImM0eSIsIm5lZ0R4IiwibmVnRHkiLCJyZW5kZXJFbmRDdXJ2ZSIsImVycm9yIiwic3lzdGVtWCIsInJlbmRlckJlZ2luQ3VydmUiLCJyZW5kZXJDb21wbGV0ZUN1cnZlIiwibm90ZUR4IiwicHJldkhhc0Vycm9yIiwibmV4dEhhc0Vycm9yIiwidGltZW91dHMiLCJQbGF5ZXJNaXhpbiIsInBsYXkiLCJtaWRpUGxheU5vdGUiLCJzZWNvbmQiLCJzdG9wIiwiY2xlYXJUaW1lb3V0IiwidGltZW91dCIsIm5vdGVPbiIsIm5vdGVPZmYiLCJzZXRUaW1lb3V0IiwicmVtb3ZlQ2xhc3MiLCJjb25zb2xlIiwibG9nIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdENBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7Ozs7QUFFQTs7Ozs7OztBQU9BLGlCQUFNQSxTQUFOLENBQWdCQyxNQUFoQixHQUF5QixVQUFVQyxHQUFWLEVBQWVDLEVBQWYsRUFBbUI7QUFDMUMsMEJBQWFELEdBQWIsRUFBa0JDLEVBQWxCLEVBQXNCRixNQUF0QixDQUE2QixJQUE3QjtBQUNELEVBRkQ7O0FBSUEsNkJBQWlCLGdCQUFNRCxTQUF2Qjs7QUFFQTs7Ozs7QUFLTyxLQUFNSSx3QkFBUSxTQUFSQSxLQUFRLENBQUNDLEtBQUQsRUFBVztBQUM5QixVQUFPLGlCQUFPRCxLQUFQLENBQWFDLEtBQWIsQ0FBUDtBQUNBO0FBQ0E7QUFDRCxFQUpNOztTQU1FQyxLOzs7Ozs7QUM5QlQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVU7QUFDVjtBQUNBLGdCQUFlLGtDQUFrQztBQUNqRCxrQkFBaUIsa0NBQWtDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQixJQUFJO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0pBQW1KO0FBQ25KLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLHNCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QixXQUFXLFlBQVksSUFBSSxXQUFXLFNBQVM7QUFDdkUsZUFBYyx5QkFBeUIsRUFBRTtBQUN6QyxPQUFNO0FBQ04sWUFBVyxpaUJBQWlpQix1QkFBdUIsdUhBQXVIO0FBQzFyQixjQUFhLDRPQUE0TyxPQUFPLCtFQUErRTtBQUMvVTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0I7QUFDQTtBQUNBO0FBQ0EsZ0I7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLGdDO0FBQ2pCO0FBQ0E7QUFDQSx1QztBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxZQUFXLGdCO0FBQ1g7QUFDQTtBQUNBLGFBQVksb0M7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxZQUFXLG1CQUFtQix5QkFBeUIsZ0JBQWdCLEU7QUFDdkU7QUFDQTtBQUNBLG9CO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQiwrQkFBK0IsZ0JBQWdCLEVBQUU7QUFDcEU7QUFDQTtBQUNBLG9CQUFtQiwrQkFBK0IsZ0JBQWdCLEVBQUUsZ0JBQWdCLFdBQVc7QUFDL0Y7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0Esb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUI7QUFDbkI7QUFDQTtBQUNBLFdBQVUsUUFBUSxtQkFBbUI7QUFDckM7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0Esb0JBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZixRQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZixRQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZixRQUFPOztBQUVQO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0Esb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUI7QUFDbkI7QUFDQTtBQUNBLFdBQVUsUUFBUSxzQ0FBc0M7QUFDeEQ7QUFDQTtBQUNBLEVBQUM7QUFDRCxVQUFTLGtPQUFrTyxFQUFFLE1BQU0sRUFBRSxTQUFTLFlBQVksS0FBSyxHQUFHLFFBQVEsNEJBQTRCLGtMQUFrTCxFQUFFLFNBQVMsWUFBWSxLQUFLLEdBQUcsU0FBUyxlQUFlLFVBQVUsR0FBRyx5REFBeUQsb0NBQW9DLEtBQUssZ0JBQWdCLGlHQUFpRyxpR0FBaUcsS0FBSyxnQkFBZ0IsVUFBVSxhQUFhLCtDQUErQyx5Q0FBeUMsK0NBQStDLEdBQUcsNkNBQTZDLEVBQUUsZ0JBQWdCLEVBQUUsVUFBVSw0Q0FBNEMsMEJBQTBCLGVBQWUsVUFBVSxHQUFHLFVBQVUsRUFBRSxRQUFRLEVBQUUsbU5BQW1OLEVBQUUsU0FBUyxlQUFlLGFBQWEsMkJBQTJCLEtBQUssR0FBRywwSEFBMEgsWUFBWSxLQUFLLGdCQUFnQixhQUFhLDRDQUE0QyxVQUFVLDRDQUE0QyxvQkFBb0IsNENBQTRDLFVBQVUsYUFBYSwrQ0FBK0MsR0FBRyxVQUFVLEVBQUUsb0JBQW9CLGdCQUFnQiw4QkFBOEIsMkNBQTJDLFVBQVUsR0FBRyxRQUFRLDBDQUEwQyxvSEFBb0gsR0FBRyx5REFBeUQsZUFBZSxhQUFhLDRDQUE0QyxvQkFBb0IsOEJBQThCLFVBQVUsaUJBQWlCLDBFQUEwRSx5REFBeUQsaUdBQWlHLDZDQUE2QyxVQUFVLEVBQUUsVUFBVSxFQUFFLDBEQUEwRCxFQUFFLFVBQVU7QUFDcnZGLGtCQUFpQixxRkFBcUY7QUFDdEc7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNB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QixFQUFrQztBQUFBLE9BQ3hCd0gsVUFEd0IsR0FDVHRILEtBQUt1RixLQURJLENBQ3hCK0IsVUFEd0I7O0FBRWhDLE9BQU1oRCxNQUFNdEUsS0FBSzhELFFBQUwsQ0FBY2tTLE1BQTFCOztBQUVBLFlBQVNGLElBQVQsR0FBZ0I7QUFDZCxTQUFJLENBQUM5VixLQUFLd0YsR0FBTCxDQUFTb0MsVUFBVixJQUF3QjVILEtBQUt3RixHQUFMLENBQVNrUSxZQUFyQyxFQUFtRDtBQUNqRCxzQkFBS1UsTUFBTCxDQUFZLENBQVosRUFBZTlPLFVBQWYsRUFBMkIsR0FBM0IsRUFBZ0MsQ0FBaEM7QUFDRDtBQUNELFNBQUksQ0FBQ3RILEtBQUt3RixHQUFMLENBQVN1QyxVQUFWLElBQXdCL0gsS0FBS3dGLEdBQUwsQ0FBU21RLFlBQXJDLEVBQW1EO0FBQ2pELHNCQUFLVSxPQUFMLENBQWEsQ0FBYixFQUFnQi9PLFVBQWhCLEVBQTRCaEQsR0FBNUI7QUFDRDtBQUNEdEUsVUFBSzRCLEVBQUwsQ0FBUUUsUUFBUixDQUFpQixhQUFqQjtBQUNBd1UsZ0JBQVcsWUFBTTtBQUFFdFcsWUFBSzRCLEVBQUwsQ0FBUTJVLFdBQVIsQ0FBb0IsYUFBcEI7QUFBb0MsTUFBdkQsRUFBeURqUyxNQUFNLEdBQU4sR0FBWSxHQUFyRTtBQUNBa1MsYUFBUUMsR0FBUixDQUFZLFdBQVd6VyxJQUF2QixFQUE2QkYsSUFBN0IsRUFBbUN3RSxHQUFuQyxFQUF3Q2dELFVBQXhDO0FBQ0Q7O0FBRUQsVUFBT2dQLFdBQVdSLElBQVgsRUFBaUJoVyxPQUFPLEdBQXhCLENBQVA7QUFDRDs7bUJBRWMrVixXOzs7Ozs7QUNoRmYsaUQiLCJmaWxlIjoibXVzamUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJzbmFwc3ZnXCIpLCByZXF1aXJlKFwiTUlESVwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJzbmFwc3ZnXCIsIFwiTUlESVwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJtdXNqZVwiXSA9IGZhY3RvcnkocmVxdWlyZShcInNuYXBzdmdcIiksIHJlcXVpcmUoXCJNSURJXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJtdXNqZVwiXSA9IGZhY3Rvcnkocm9vdFtcIlNuYXBcIl0sIHJvb3RbXCJNSURJXCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfOF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzQyX18pIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgODY0NDU1ZDM4Y2JkNzdlMWViMGEiLCJpbXBvcnQgcGFyc2VyIGZyb20gJy4vcGFyc2VyL3BhcnNlci5qaXNvbidcbmltcG9ydCBTY29yZSBmcm9tICcuL21vZGVsL1Njb3JlJ1xuaW1wb3J0IFJlbmRlcmVyIGZyb20gJy4vcmVuZGVyZXIvUmVuZGVyZXIvUmVuZGVyZXInXG5pbXBvcnQgeyBkZWZpbmVQcm9wZXJ0aWVzIH0gZnJvbSAnLi91dGlsJ1xuaW1wb3J0IFBsYXllck1peGluIGZyb20gJy4vcGxheWVyL1BsYXllck1peGluJ1xuXG4vKipcbiAqIFJlbmRlciB0aGUgc2NvcmUgaW4gamlhbnB1IChudW1iZXJlZCBtdXNpY2FsIG5vdGF0aW9uKS5cbiAqIEBtZW1iZXJcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHN2Z1xuICogQHBhcmFtIHtPYmplY3R9IGxvIC0gTGF5b3V0IG9wdGlvbnMuXG4gKi9cblNjb3JlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoc3ZnLCBsbykge1xuICBuZXcgUmVuZGVyZXIoc3ZnLCBsbykucmVuZGVyKHRoaXMpXG59XG5cbmRlZmluZVByb3BlcnRpZXMoU2NvcmUucHJvdG90eXBlLCBQbGF5ZXJNaXhpbilcblxuLyoqXG4gKiBQYXJzZSBzb3VyY2UgbXVzamUgc3RyaW5nIHRvIGJlIGEgU2NvcmUgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgLSBJbnB1dCBvZiB0aGUgbXVzamUgc291cmNlIGNvZGUuXG4gKiBAcmV0dXJuIHtTY29yZX0gLSBBIGBTY29yZWAgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBjb25zdCBwYXJzZSA9IChpbnB1dCkgPT4ge1xuICByZXR1cm4gcGFyc2VyLnBhcnNlKGlucHV0KVxuICAvLyB2YXIgcGxhaW5TY29yZSA9IHBhcnNlci5wYXJzZShpbnB1dCk7XG4gIC8vIHJldHVybiBuZXcgU2NvcmUocGxhaW5TY29yZSk7XG59XG5cbmV4cG9ydCB7IFNjb3JlIH1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tYWluLmpzIiwiLyogcGFyc2VyIGdlbmVyYXRlZCBieSBqaXNvbiAwLjQuMTcgKi9cbi8qXG4gIFJldHVybnMgYSBQYXJzZXIgb2JqZWN0IG9mIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlOlxuXG4gIFBhcnNlcjoge1xuICAgIHl5OiB7fVxuICB9XG5cbiAgUGFyc2VyLnByb3RvdHlwZToge1xuICAgIHl5OiB7fSxcbiAgICB0cmFjZTogZnVuY3Rpb24oKSxcbiAgICBzeW1ib2xzXzoge2Fzc29jaWF0aXZlIGxpc3Q6IG5hbWUgPT0+IG51bWJlcn0sXG4gICAgdGVybWluYWxzXzoge2Fzc29jaWF0aXZlIGxpc3Q6IG51bWJlciA9PT4gbmFtZX0sXG4gICAgcHJvZHVjdGlvbnNfOiBbLi4uXSxcbiAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB5eSwgeXlzdGF0ZSwgJCQsIF8kKSxcbiAgICB0YWJsZTogWy4uLl0sXG4gICAgZGVmYXVsdEFjdGlvbnM6IHsuLi59LFxuICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCksXG4gICAgcGFyc2U6IGZ1bmN0aW9uKGlucHV0KSxcblxuICAgIGxleGVyOiB7XG4gICAgICAgIEVPRjogMSxcbiAgICAgICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoKSxcbiAgICAgICAgc2V0SW5wdXQ6IGZ1bmN0aW9uKGlucHV0KSxcbiAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCksXG4gICAgICAgIHVucHV0OiBmdW5jdGlvbihzdHIpLFxuICAgICAgICBtb3JlOiBmdW5jdGlvbigpLFxuICAgICAgICBsZXNzOiBmdW5jdGlvbihuKSxcbiAgICAgICAgcGFzdElucHV0OiBmdW5jdGlvbigpLFxuICAgICAgICB1cGNvbWluZ0lucHV0OiBmdW5jdGlvbigpLFxuICAgICAgICBzaG93UG9zaXRpb246IGZ1bmN0aW9uKCksXG4gICAgICAgIHRlc3RfbWF0Y2g6IGZ1bmN0aW9uKHJlZ2V4X21hdGNoX2FycmF5LCBydWxlX2luZGV4KSxcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oKSxcbiAgICAgICAgbGV4OiBmdW5jdGlvbigpLFxuICAgICAgICBiZWdpbjogZnVuY3Rpb24oY29uZGl0aW9uKSxcbiAgICAgICAgcG9wU3RhdGU6IGZ1bmN0aW9uKCksXG4gICAgICAgIF9jdXJyZW50UnVsZXM6IGZ1bmN0aW9uKCksXG4gICAgICAgIHRvcFN0YXRlOiBmdW5jdGlvbigpLFxuICAgICAgICBwdXNoU3RhdGU6IGZ1bmN0aW9uKGNvbmRpdGlvbiksXG5cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgcmFuZ2VzOiBib29sZWFuICAgICAgICAgICAob3B0aW9uYWw6IHRydWUgPT0+IHRva2VuIGxvY2F0aW9uIGluZm8gd2lsbCBpbmNsdWRlIGEgLnJhbmdlW10gbWVtYmVyKVxuICAgICAgICAgICAgZmxleDogYm9vbGVhbiAgICAgICAgICAgICAob3B0aW9uYWw6IHRydWUgPT0+IGZsZXgtbGlrZSBsZXhpbmcgYmVoYXZpb3VyIHdoZXJlIHRoZSBydWxlcyBhcmUgdGVzdGVkIGV4aGF1c3RpdmVseSB0byBmaW5kIHRoZSBsb25nZXN0IG1hdGNoKVxuICAgICAgICAgICAgYmFja3RyYWNrX2xleGVyOiBib29sZWFuICAob3B0aW9uYWw6IHRydWUgPT0+IGxleGVyIHJlZ2V4ZXMgYXJlIHRlc3RlZCBpbiBvcmRlciBhbmQgZm9yIGVhY2ggbWF0Y2hpbmcgcmVnZXggdGhlIGFjdGlvbiBjb2RlIGlzIGludm9rZWQ7IHRoZSBsZXhlciB0ZXJtaW5hdGVzIHRoZSBzY2FuIHdoZW4gYSB0b2tlbiBpcyByZXR1cm5lZCBieSB0aGUgYWN0aW9uIGNvZGUpXG4gICAgICAgIH0sXG5cbiAgICAgICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24oeXksIHl5XywgJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucywgWVlfU1RBUlQpLFxuICAgICAgICBydWxlczogWy4uLl0sXG4gICAgICAgIGNvbmRpdGlvbnM6IHthc3NvY2lhdGl2ZSBsaXN0OiBuYW1lID09PiBzZXR9LFxuICAgIH1cbiAgfVxuXG5cbiAgdG9rZW4gbG9jYXRpb24gaW5mbyAoQCQsIF8kLCBldGMuKToge1xuICAgIGZpcnN0X2xpbmU6IG4sXG4gICAgbGFzdF9saW5lOiBuLFxuICAgIGZpcnN0X2NvbHVtbjogbixcbiAgICBsYXN0X2NvbHVtbjogbixcbiAgICByYW5nZTogW3N0YXJ0X251bWJlciwgZW5kX251bWJlcl0gICAgICAgKHdoZXJlIHRoZSBudW1iZXJzIGFyZSBpbmRleGVzIGludG8gdGhlIGlucHV0IHN0cmluZywgcmVndWxhciB6ZXJvLWJhc2VkKVxuICB9XG5cblxuICB0aGUgcGFyc2VFcnJvciBmdW5jdGlvbiByZWNlaXZlcyBhICdoYXNoJyBvYmplY3Qgd2l0aCB0aGVzZSBtZW1iZXJzIGZvciBsZXhlciBhbmQgcGFyc2VyIGVycm9yczoge1xuICAgIHRleHQ6ICAgICAgICAobWF0Y2hlZCB0ZXh0KVxuICAgIHRva2VuOiAgICAgICAodGhlIHByb2R1Y2VkIHRlcm1pbmFsIHRva2VuLCBpZiBhbnkpXG4gICAgbGluZTogICAgICAgICh5eWxpbmVubylcbiAgfVxuICB3aGlsZSBwYXJzZXIgKGdyYW1tYXIpIGVycm9ycyB3aWxsIGFsc28gcHJvdmlkZSB0aGVzZSBtZW1iZXJzLCBpLmUuIHBhcnNlciBlcnJvcnMgZGVsaXZlciBhIHN1cGVyc2V0IG9mIGF0dHJpYnV0ZXM6IHtcbiAgICBsb2M6ICAgICAgICAgKHl5bGxvYylcbiAgICBleHBlY3RlZDogICAgKHN0cmluZyBkZXNjcmliaW5nIHRoZSBzZXQgb2YgZXhwZWN0ZWQgdG9rZW5zKVxuICAgIHJlY292ZXJhYmxlOiAoYm9vbGVhbjogVFJVRSB3aGVuIHRoZSBwYXJzZXIgaGFzIGEgZXJyb3IgcmVjb3ZlcnkgcnVsZSBhdmFpbGFibGUgZm9yIHRoaXMgcGFydGljdWxhciBlcnJvcilcbiAgfVxuKi9cbnZhciBwYXJzZXIgPSAoZnVuY3Rpb24oKXtcbnZhciBvPWZ1bmN0aW9uKGssdixvLGwpe2ZvcihvPW98fHt9LGw9ay5sZW5ndGg7bC0tO29ba1tsXV09dik7cmV0dXJuIG99LCRWMD1bMSwxMV0sJFYxPVsxLDE1XSwkVjI9WzEsMTZdLCRWMz1bMSwxN10sJFY0PVsxLDE4XSwkVjU9WzEsMTldLCRWNj1bMSwyMF0sJFY3PVsxLDIzXSwkVjg9WzEsMjddLCRWOT1bMSwzNF0sJFZhPVsxLDM1XSwkVmI9WzEsMzNdLCRWYz1bMSwyOF0sJFZkPVsxLDI5XSwkVmU9WzUsOSwxMCwxNCwyMSwyMiwyMywyNCwyNSwyNiwyOSwzNCwzOSw0MSw0OCw1MSw1OF0sJFZmPVsyLDhdLCRWZz1bNSw5LDEwLDIxLDIyLDIzLDI0LDI1LDI2LDI5LDM0LDM5LDQxLDQ4LDUxLDU4XSwkVmg9WzUsMjEsMjIsMjMsMjQsMjUsMjZdLCRWaT1bMiw0N10sJFZqPVsxLDQ4XSwkVms9WzEsNDldLCRWbD1bMSw1MF0sJFZtPVsxLDUxXSwkVm49WzEsNTJdLCRWbz1bNSw5LDEwLDIxLDIyLDIzLDI0LDI1LDI2LDI4LDI5LDM0LDM1LDM5LDQxLDQ4LDUxLDUzLDU4XSwkVnA9WzUsOSwxMCwyMSwyMiwyMywyNCwyNSwyNiwyOCwyOSwzNCwzNSwzOSw0MSw0Myw0NCw0NSw0Niw0Nyw0OCw1MSw1Myw1OF0sJFZxPVs1LDksMTAsMjEsMjIsMjMsMjQsMjUsMjYsMjgsMjksMzQsMzUsMzksNDEsNDMsNDQsNDUsNDYsNDcsNDgsNTAsNTEsNTMsNThdLCRWcj1bMSw2M10sJFZzPVsxLDY0XSwkVnQ9WzUsMjEsMjIsMjMsMjQsMjUsMjYsMjksMzQsMzksNDEsNDgsNTEsNThdLCRWdT1bNSw5LDEwLDIxLDIyLDIzLDI0LDI1LDI2LDI4LDI5LDM0LDM1LDM5LDQxLDQzLDQ4LDUxLDUzLDU4XSwkVnY9WzUsOSwxMCwyMSwyMiwyMywyNCwyNSwyNiwyOCwyOSwzNCwzOSw0MSw0OCw1MSw1Myw1OF0sJFZ3PVszOSw0MSw1MF07XG52YXIgcGFyc2VyID0ge3RyYWNlOiBmdW5jdGlvbiB0cmFjZSgpIHsgfSxcbnl5OiB7fSxcbnN5bWJvbHNfOiB7XCIwXCI6MjksXCJlcnJvclwiOjIsXCJlXCI6MyxcIm1heWJlX211c2plXCI6NCxcIkVPRlwiOjUsXCJzcGFjZVwiOjYsXCJtYXliZV9zcGFjZVwiOjcsXCJtdXNqZVwiOjgsXCJTXCI6OSxcIk5MXCI6MTAsXCJzY29yZV9oZWFkXCI6MTEsXCJwYXJ0X2xpc3RcIjoxMixcInRpdGxlXCI6MTMsXCJUSVRMRVwiOjE0LFwiQ09NUE9TRVJcIjoxNSxcInBhcnRcIjoxNixcIm1lYXN1cmVfbGlzdFwiOjE3LFwiYmFyXCI6MTgsXCJtZWFzdXJlXCI6MTksXCJtdXNpY19kYXRhXCI6MjAsXCJ8XCI6MjEsXCJ8fFwiOjIyLFwifF1cIjoyMyxcInw6XCI6MjQsXCI6fFwiOjI1LFwiOnw6XCI6MjYsXCJzbHVyYWJsZVwiOjI3LFwiVElFXCI6MjgsXCJtYXliZV9kdXJhdGlvblwiOjMwLFwidm9pY2VcIjozMSxcInRpbWVfc2lnbmF0dXJlXCI6MzIsXCJwaXRjaGZ1bFwiOjMzLFwiKFwiOjM0LFwiKVwiOjM1LFwibm90ZVwiOjM2LFwiY2hvcmRcIjozNyxcInBpdGNoXCI6MzgsXCJTVEVQXCI6MzksXCJPQ1RBVkVcIjo0MCxcIkFDQ0lERU5UQUxcIjo0MSxcInR5cGVfbW9kaWZpZXJcIjo0MixcIkRPVFwiOjQzLFwiX1wiOjQ0LFwiPVwiOjQ1LFwiSEFMRlwiOjQ2LFwiV0hPTEVcIjo0NyxcIjxcIjo0OCxcInBpdGNoX2xpc3RcIjo0OSxcIj5cIjo1MCxcIntcIjo1MSxcInZvaWNlX2xpc3RcIjo1MixcIn1cIjo1MyxcInZvaWNlX2RhdGFfbGlzdFwiOjU0LFwiOlwiOjU1LFwidm9pY2VfZGF0YVwiOjU2LFwicmVzdHNsdXJhYmxlX2xpc3RcIjo1NyxcIkJFQVRTXCI6NTgsXCJCRUFUX1RZUEVcIjo1OSxcIiRhY2NlcHRcIjowLFwiJGVuZFwiOjF9LFxudGVybWluYWxzXzogezI6XCJlcnJvclwiLDU6XCJFT0ZcIiw5OlwiU1wiLDEwOlwiTkxcIiwxNDpcIlRJVExFXCIsMTU6XCJDT01QT1NFUlwiLDIxOlwifFwiLDIyOlwifHxcIiwyMzpcInxdXCIsMjQ6XCJ8OlwiLDI1OlwiOnxcIiwyNjpcIjp8OlwiLDI4OlwiVElFXCIsMjk6XCIwXCIsMzQ6XCIoXCIsMzU6XCIpXCIsMzk6XCJTVEVQXCIsNDA6XCJPQ1RBVkVcIiw0MTpcIkFDQ0lERU5UQUxcIiw0MzpcIkRPVFwiLDQ0OlwiX1wiLDQ1OlwiPVwiLDQ2OlwiSEFMRlwiLDQ3OlwiV0hPTEVcIiw0ODpcIjxcIiw1MDpcIj5cIiw1MTpcIntcIiw1MzpcIn1cIiw1NDpcInZvaWNlX2RhdGFfbGlzdFwiLDU1OlwiOlwiLDU3OlwicmVzdHNsdXJhYmxlX2xpc3RcIiw1ODpcIkJFQVRTXCIsNTk6XCJCRUFUX1RZUEVcIn0sXG5wcm9kdWN0aW9uc186IFswLFszLDJdLFs0LDBdLFs0LDJdLFs0LDNdLFs0LDFdLFs2LDFdLFs2LDFdLFs3LDBdLFs3LDJdLFs3LDJdLFs4LDFdLFs4LDFdLFs4LDJdLFsxMSwyXSxbMTMsMV0sWzEzLDJdLFsxMiwxXSxbMTYsMV0sWzE2LDNdLFsxNywxXSxbMTcsNF0sWzE3LDNdLFsxOSwyXSxbMTksM10sWzE4LDFdLFsxOCwxXSxbMTgsMV0sWzE4LDFdLFsxOCwxXSxbMTgsMV0sWzIwLDFdLFsyMCwyXSxbMjAsMl0sWzIwLDFdLFsyMCwxXSxbMjcsMl0sWzI3LDNdLFsyNywzXSxbMjcsNF0sWzMzLDFdLFszMywxXSxbMzYsMV0sWzM4LDFdLFszOCwyXSxbMzgsMl0sWzM4LDNdLFszMCwwXSxbMzAsMV0sWzMwLDFdLFszMCwyXSxbNDIsMV0sWzQyLDFdLFs0MiwyXSxbNDIsMl0sWzQyLDNdLFs0MiwzXSxbNDIsMV0sWzQyLDFdLFszNywzXSxbNDksMV0sWzQ5LDJdLFszMSwzXSxbNTIsMV0sWzUyLDNdLFs1NiwxXSxbNTYsMl0sWzMyLDJdXSxcbnBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIGFub255bW91cyh5eXRleHQsIHl5bGVuZywgeXlsaW5lbm8sIHl5LCB5eXN0YXRlIC8qIGFjdGlvblsxXSAqLywgJCQgLyogdnN0YWNrICovLCBfJCAvKiBsc3RhY2sgKi8pIHtcbi8qIHRoaXMgPT0geXl2YWwgKi9cblxudmFyICQwID0gJCQubGVuZ3RoIC0gMTtcbnN3aXRjaCAoeXlzdGF0ZSkge1xuY2FzZSAxOlxuIHJldHVybiAkJFskMC0xXTsgXG5icmVhaztcbmNhc2UgMjogY2FzZSAzOlxuIHRoaXMuJCA9IG51bGw7IFxuYnJlYWs7XG5jYXNlIDQ6IGNhc2UgNTpcbiB0aGlzLiQgPSAkJFskMF07IHJlbW92ZUxhc3RFbXB0eU1lYXN1cmUoJCRbJDBdKTsgXG5icmVhaztcbmNhc2UgMTA6XG4gdGhpcy4kID0gJCRbJDAtMV0gPyAkJFskMC0xXSArIDEgOiAxOyBcbmJyZWFrO1xuY2FzZSAxMTpcbnRoaXMuJCA9IHsgaGVhZDogJCRbJDBdIH07XG5icmVhaztcbmNhc2UgMTI6XG50aGlzLiQgPSB7IHBhcnRzOiAkJFskMF0gfTtcbmJyZWFrO1xuY2FzZSAxMzpcbnRoaXMuJCA9IHsgaGVhZDogJCRbJDAtMV0sIHBhcnRzOiAkJFskMF0gfTtcbmJyZWFrO1xuY2FzZSAxNTpcbiB0aGlzLiQgPSB7IHRpdGxlOiAkJFskMF0gfSBcbmJyZWFrO1xuY2FzZSAxNjpcbiB0aGlzLiQgPSAgeyB0aXRsZTogJCRbJDAtMV0sIGNvbXBvc2VyOiAkJFskMF0gfSBcbmJyZWFrO1xuY2FzZSAxNzogY2FzZSA2MDogY2FzZSA2MzpcbnRoaXMuJCA9IFskJFskMF1dO1xuYnJlYWs7XG5jYXNlIDE4OlxudGhpcy4kID0geyBtZWFzdXJlczogJCRbJDBdIH07XG5icmVhaztcbmNhc2UgMTk6XG4gdGhpcy4kID0geyBtZWFzdXJlczogJCRbJDBdfTsgJCRbJDBdWzBdLmRhdGEudW5zaGlmdCh7IGJhcjogJCRbJDAtMl0gfSk7IFxuYnJlYWs7XG5jYXNlIDIwOlxuIHRoaXMuJCA9IFskJFskMF1dOyBcbmJyZWFrO1xuY2FzZSAyMTpcbiB0aGlzLiQgPSAkJFskMC0zXTsgbGFzdEl0ZW0oJCRbJDAtM10pLmRhdGEucHVzaCh7IGJhcjogJCRbJDAtMl0gfSk7ICQkWyQwLTNdLnB1c2goJCRbJDBdKSBcbmJyZWFrO1xuY2FzZSAyMjpcbiB0aGlzLiQgPSAkJFskMC0yXTsgbGFzdEl0ZW0oJCRbJDAtMl0pLmRhdGEucHVzaCh7IGJhcjogJCRbJDAtMV0gfSk7ICQkWyQwLTJdLnB1c2goeyBkYXRhOiBbXSB9KSBcbmJyZWFrO1xuY2FzZSAyMzpcbnRoaXMuJCA9IHsgZGF0YTogWyQkWyQwLTFdXSB9O1xuYnJlYWs7XG5jYXNlIDI0OlxuIHRoaXMuJCA9ICQkWyQwLTJdOyAkJFskMC0yXS5kYXRhLnB1c2goJCRbJDAtMV0pIFxuYnJlYWs7XG5jYXNlIDI1OlxudGhpcy4kID0gJ3NpbmdsZSc7XG5icmVhaztcbmNhc2UgMjY6XG50aGlzLiQgPSAnZG91YmxlJztcbmJyZWFrO1xuY2FzZSAyNzpcbnRoaXMuJCA9ICdlbmQnO1xuYnJlYWs7XG5jYXNlIDI4OlxudGhpcy4kID0gJ3JlcGVhdC1iZWdpbic7XG5icmVhaztcbmNhc2UgMjk6XG50aGlzLiQgPSAncmVwZWF0LWVuZCc7XG5icmVhaztcbmNhc2UgMzA6XG50aGlzLiQgPSAncmVwZWF0LWJvdGgnO1xuYnJlYWs7XG5jYXNlIDMyOlxuIHRoaXMuJCA9ICQkWyQwLTFdOyBvbmx5UHJvcGVydHkoJCRbJDAtMV0pLnRpZSA9ICd+JyBcbmJyZWFrO1xuY2FzZSAzMzpcbnRoaXMuJCA9IHsgcmVzdDogeyBkdXJhdGlvbjogJCRbJDBdIH0gfTtcbmJyZWFrO1xuY2FzZSAzNDpcbnRoaXMuJCA9IHsgdm9pY2U6ICQkWyQwXSB9O1xuYnJlYWs7XG5jYXNlIDM2OlxuIHRoaXMuJCA9ICQkWyQwLTFdOyBvbmx5UHJvcGVydHkoJCRbJDAtMV0pLmR1cmF0aW9uID0gJCRbJDBdIFxuYnJlYWs7XG5jYXNlIDM3OlxuXG4gICAgICB0aGlzLiQgPSAkJFskMC0xXTtcbiAgICAgIGV4dGVuZChvbmx5UHJvcGVydHkoJCRbJDAtMV0pLCB7XG4gICAgICAgIGR1cmF0aW9uOiAkJFskMF0sXG4gICAgICAgIHNsdXI6IHsgYmVnaW46ICdzb2xpZCcgfVxuICAgICAgfSlcbiAgICBcbmJyZWFrO1xuY2FzZSAzODpcblxuICAgICAgdGhpcy4kID0gJCRbJDAtMl1cbiAgICAgIGV4dGVuZChvbmx5UHJvcGVydHkoJCRbJDAtMl0pLCB7XG4gICAgICAgIGR1cmF0aW9uOiAkJFskMC0xXSxcbiAgICAgICAgc2x1cjogeyBlbmQ6ICdzb2xpZCcgfVxuICAgICAgfSlcbiAgICBcbmJyZWFrO1xuY2FzZSAzOTpcblxuICAgICAgdGhpcy4kID0gJCRbJDAtMl1cbiAgICAgIGV4dGVuZChvbmx5UHJvcGVydHkoJCRbJDAtMl0pLCB7XG4gICAgICAgIGR1cmF0aW9uOiAkJFskMC0xXSxcbiAgICAgICAgc2x1cjogeyBiZWdpbjogJ3NvbGlkJywgZW5kOiAnc29saWQnIH1cbiAgICAgIH0pXG4gICAgXG5icmVhaztcbmNhc2UgNDA6XG50aGlzLiQgPSB7IG5vdGU6ICQkWyQwXSB9O1xuYnJlYWs7XG5jYXNlIDQxOlxudGhpcy4kID0geyBjaG9yZDogJCRbJDBdIH07XG5icmVhaztcbmNhc2UgNDI6XG50aGlzLiQgPSB7IHBpdGNoOiAkJFskMF0gfTtcbmJyZWFrO1xuY2FzZSA0MzpcbnRoaXMuJCA9IHsgc3RlcDogKyQkWyQwXSB9O1xuYnJlYWs7XG5jYXNlIDQ0OlxudGhpcy4kID0geyBzdGVwOiArJCRbJDAtMV0sIG9jdGF2ZTogb2N0YXZlKCQkWyQwXSkgfTtcbmJyZWFrO1xuY2FzZSA0NTpcbnRoaXMuJCA9IHsgYWNjaWRlbnRhbDogJCRbJDAtMV0sIHN0ZXA6ICskJFskMF0gfTtcbmJyZWFrO1xuY2FzZSA0NjpcbnRoaXMuJCA9IHsgYWNjaWRlbnRhbDogJCRbJDAtMl0sIHN0ZXA6ICskJFskMC0xXSwgb2N0YXZlOiBvY3RhdmUoJCRbJDBdKSB9O1xuYnJlYWs7XG5jYXNlIDQ4OlxudGhpcy4kID0geyB0eXBlOiAkJFskMF0gfTtcbmJyZWFrO1xuY2FzZSA0OTpcbnRoaXMuJCA9IHsgdHlwZTogNCwgZG90OiAkJFskMF0ubGVuZ3RoIH07XG5icmVhaztcbmNhc2UgNTA6XG50aGlzLiQgPSB7IHR5cGU6ICQkWyQwLTFdLCBkb3Q6ICQkWyQwXS5sZW5ndGggfTtcbmJyZWFrO1xuY2FzZSA1MTpcbnRoaXMuJCA9IDg7XG5icmVhaztcbmNhc2UgNTI6XG50aGlzLiQgPSAxNjtcbmJyZWFrO1xuY2FzZSA1MzpcbnRoaXMuJCA9IDMyO1xuYnJlYWs7XG5jYXNlIDU0OlxudGhpcy4kID0gNjQ7XG5icmVhaztcbmNhc2UgNTU6XG50aGlzLiQgPSAxMjg7XG5icmVhaztcbmNhc2UgNTY6XG50aGlzLiQgPSAyNTY7XG5icmVhaztcbmNhc2UgNTc6XG50aGlzLiQgPSAyO1xuYnJlYWs7XG5jYXNlIDU4OlxudGhpcy4kID0gMTtcbmJyZWFrO1xuY2FzZSA1OTpcbnRoaXMuJCA9IHsgcGl0Y2hlczogJCRbJDAtMV0gfTtcbmJyZWFrO1xuY2FzZSA2MTogY2FzZSA2NjpcbiB0aGlzLiQgPSAkJFskMC0xXTsgJCRbJDAtMV0ucHVzaCgkJFskMF0pIFxuYnJlYWs7XG5jYXNlIDYyOlxudGhpcy4kID0gJCRbJDAtMV07XG5icmVhaztcbmNhc2UgNjQ6XG4gdGhpcy4kID0gJCRbJDAtMl07ICQkWyQwLTJdLnB1c2goJCRbJDAtMV0pIFxuYnJlYWs7XG5jYXNlIDY3OlxudGhpcy4kID0geyB0aW1lOiB7IGJlYXRzOiArJCRbJDAtMV0sIGJlYXRUeXBlOiArJCRbJDBdIH0gfTtcbmJyZWFrO1xufVxufSxcbnRhYmxlOiBbezM6MSw0OjIsNTpbMiwyXSw2OjMsODo0LDk6WzEsNV0sMTA6WzEsNl0sMTE6NywxMjo4LDEzOjksMTQ6JFYwLDE2OjEwLDE3OjEyLDE4OjEzLDE5OjE0LDIwOjIxLDIxOiRWMSwyMjokVjIsMjM6JFYzLDI0OiRWNCwyNTokVjUsMjY6JFY2LDI3OjIyLDI5OiRWNywzMToyNCwzMjoyNSwzMzoyNiwzNDokVjgsMzY6MzAsMzc6MzEsMzg6MzIsMzk6JFY5LDQxOiRWYSw0ODokVmIsNTE6JFZjLDU4OiRWZH0sezE6WzNdfSx7NTpbMSwzNl19LG8oJFZlLCRWZix7NzozN30pLHs1OlsyLDVdfSxvKCRWZSxbMiw2XSksbygkVmUsWzIsN10pLHs1OlsyLDExXSwxMjozOCwxNjoxMCwxNzoxMiwxODoxMywxOToxNCwyMDoyMSwyMTokVjEsMjI6JFYyLDIzOiRWMywyNDokVjQsMjU6JFY1LDI2OiRWNiwyNzoyMiwyOTokVjcsMzE6MjQsMzI6MjUsMzM6MjYsMzQ6JFY4LDM2OjMwLDM3OjMxLDM4OjMyLDM5OiRWOSw0MTokVmEsNDg6JFZiLDUxOiRWYyw1ODokVmR9LHs1OlsyLDEyXX0sbygkVmcsJFZmLHs3OjM5fSksezU6WzIsMTddfSxvKCRWZyxbMiwxNV0sezE1OlsxLDQwXX0pLHs1OlsyLDE4XSwxODo0MSwyMTokVjEsMjI6JFYyLDIzOiRWMywyNDokVjQsMjU6JFY1LDI2OiRWNn0sbyhbOSwxMCwyOSwzNCwzOSw0MSw0OCw1MSw1OF0sJFZmLHs3OjQyfSksbygkVmgsWzIsMjBdLHsyNzoyMiwzMToyNCwzMjoyNSwzMzoyNiwzNjozMCwzNzozMSwzODozMiwyMDo0MywyOTokVjcsMzQ6JFY4LDM5OiRWOSw0MTokVmEsNDg6JFZiLDUxOiRWYyw1ODokVmR9KSxvKCRWZyxbMiwyNV0pLG8oJFZnLFsyLDI2XSksbygkVmcsWzIsMjddKSxvKCRWZyxbMiwyOF0pLG8oJFZnLFsyLDI5XSksbygkVmcsWzIsMzBdKSxvKCRWZywkVmYsezc6NDR9KSxvKCRWZyxbMiwzMV0sezI4OlsxLDQ1XX0pLG8oJFZnLCRWaSx7MzA6NDYsNDI6NDcsNDM6JFZqLDQ0OiRWayw0NTokVmwsNDY6JFZtLDQ3OiRWbn0pLG8oJFZnLFsyLDM0XSksbygkVmcsWzIsMzVdKSxvKCRWbywkVmksezQyOjQ3LDMwOjUzLDQzOiRWaiw0NDokVmssNDU6JFZsLDQ2OiRWbSw0NzokVm59KSx7MzM6NTQsMzY6MzAsMzc6MzEsMzg6MzIsMzk6JFY5LDQxOiRWYSw0ODokVmJ9LHs1Mjo1NSw1NDpbMSw1Nl19LHs1OTpbMSw1N119LG8oJFZwLFsyLDQwXSksbygkVnAsWzIsNDFdKSxvKCRWcCxbMiw0Ml0pLHszODo1OSwzOTokVjksNDE6JFZhLDQ5OjU4fSxvKCRWcSxbMiw0M10sezQwOlsxLDYwXX0pLHszOTpbMSw2MV19LHsxOlsyLDFdfSx7NTpbMiwzXSw4OjYyLDk6JFZyLDEwOiRWcywxMTo3LDEyOjgsMTM6OSwxNDokVjAsMTY6MTAsMTc6MTIsMTg6MTMsMTk6MTQsMjA6MjEsMjE6JFYxLDIyOiRWMiwyMzokVjMsMjQ6JFY0LDI1OiRWNSwyNjokVjYsMjc6MjIsMjk6JFY3LDMxOjI0LDMyOjI1LDMzOjI2LDM0OiRWOCwzNjozMCwzNzozMSwzODozMiwzOTokVjksNDE6JFZhLDQ4OiRWYiw1MTokVmMsNTg6JFZkfSx7NTpbMiwxM119LG8oJFZ0LFsyLDE0XSx7OTokVnIsMTA6JFZzfSksbygkVmcsWzIsMTZdKSxvKCRWZywkVmYsezc6NjV9KSx7OTokVnIsMTA6JFZzLDE3OjY2LDE5OjE0LDIwOjIxLDI3OjIyLDI5OiRWNywzMToyNCwzMjoyNSwzMzoyNiwzNDokVjgsMzY6MzAsMzc6MzEsMzg6MzIsMzk6JFY5LDQxOiRWYSw0ODokVmIsNTE6JFZjLDU4OiRWZH0sbygkVmcsJFZmLHs3OjY3fSksbygkVnQsWzIsMjNdLHs5OiRWciwxMDokVnN9KSxvKCRWZyxbMiwzMl0pLG8oJFZnLFsyLDMzXSksbygkVm8sWzIsNDhdLHs0MzpbMSw2OF19KSxvKCRWbyxbMiw0OV0pLG8oJFZ1LFsyLDUxXSksbygkVnUsWzIsNTJdLHs0NDpbMSw2OV0sNDU6WzEsNzBdfSksbygkVnUsWzIsNTddKSxvKCRWdSxbMiw1OF0pLG8oJFZ2LFsyLDM2XSx7MzU6WzEsNzFdfSksbygkVm8sJFZpLHs0Mjo0NywzMDo3Miw0MzokVmosNDQ6JFZrLDQ1OiRWbCw0NjokVm0sNDc6JFZufSksezUzOlsxLDczXX0sezUzOlsyLDYzXSw1NTpbMSw3NF19LG8oJFZnLFsyLDY3XSksezM4Ojc2LDM5OiRWOSw0MTokVmEsNTA6WzEsNzVdfSxvKCRWdyxbMiw2MF0pLG8oJFZxLFsyLDQ0XSksbygkVnEsWzIsNDVdLHs0MDpbMSw3N119KSx7NTpbMiw0XX0sbygkVmUsWzIsOV0pLG8oJFZlLFsyLDEwXSksbygkVmgsWzIsMjJdLHsyMDoyMSwyNzoyMiwzMToyNCwzMjoyNSwzMzoyNiwzNjozMCwzNzozMSwzODozMiwxOTo3OCw5OiRWciwxMDokVnMsMjk6JFY3LDM0OiRWOCwzOTokVjksNDE6JFZhLDQ4OiRWYiw1MTokVmMsNTg6JFZkfSksezU6WzIsMTldLDE4OjQxLDIxOiRWMSwyMjokVjIsMjM6JFYzLDI0OiRWNCwyNTokVjUsMjY6JFY2fSxvKCRWdCxbMiwyNF0sezk6JFZyLDEwOiRWc30pLG8oJFZvLFsyLDUwXSksbygkVnUsWzIsNTNdKSxvKCRWdSxbMiw1NF0sezQ0OlsxLDc5XSw0NTpbMSw4MF19KSxvKCRWdixbMiwzOF0pLG8oJFZ2LFsyLDM3XSx7MzU6WzEsODFdfSksbygkVmcsWzIsNjJdKSx7Mjc6ODMsMzM6MjYsMzQ6JFY4LDM2OjMwLDM3OjMxLDM4OjMyLDM5OiRWOSw0MTokVmEsNDg6JFZiLDU2OjgyLDU3OlsxLDg0XX0sbygkVnAsWzIsNTldKSxvKCRWdyxbMiw2MV0pLG8oJFZxLFsyLDQ2XSksbygkVmgsWzIsMjFdLHsyNzoyMiwzMToyNCwzMjoyNSwzMzoyNiwzNjozMCwzNzozMSwzODozMiwyMDo0MywyOTokVjcsMzQ6JFY4LDM5OiRWOSw0MTokVmEsNDg6JFZiLDUxOiRWYyw1ODokVmR9KSxvKCRWdSxbMiw1NV0pLG8oJFZ1LFsyLDU2XSksbygkVnYsWzIsMzldKSx7NTM6WzIsNjRdfSx7NTM6WzIsNjVdfSx7Mjc6ODUsMzM6MjYsMzQ6JFY4LDM2OjMwLDM3OjMxLDM4OjMyLDM5OiRWOSw0MTokVmEsNDg6JFZifSx7NTM6WzIsNjZdfV0sXG5kZWZhdWx0QWN0aW9uczogezQ6WzIsNV0sODpbMiwxMl0sMTA6WzIsMTddLDM2OlsyLDFdLDM4OlsyLDEzXSw2MjpbMiw0XSw4MjpbMiw2NF0sODM6WzIsNjVdLDg1OlsyLDY2XX0sXG5wYXJzZUVycm9yOiBmdW5jdGlvbiBwYXJzZUVycm9yKHN0ciwgaGFzaCkge1xuICAgIGlmIChoYXNoLnJlY292ZXJhYmxlKSB7XG4gICAgICAgIHRoaXMudHJhY2Uoc3RyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmdW5jdGlvbiBfcGFyc2VFcnJvciAobXNnLCBoYXNoKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtc2c7XG4gICAgICAgICAgICB0aGlzLmhhc2ggPSBoYXNoO1xuICAgICAgICB9XG4gICAgICAgIF9wYXJzZUVycm9yLnByb3RvdHlwZSA9IEVycm9yO1xuXG4gICAgICAgIHRocm93IG5ldyBfcGFyc2VFcnJvcihzdHIsIGhhc2gpO1xuICAgIH1cbn0sXG5wYXJzZTogZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsIHN0YWNrID0gWzBdLCB0c3RhY2sgPSBbXSwgdnN0YWNrID0gW251bGxdLCBsc3RhY2sgPSBbXSwgdGFibGUgPSB0aGlzLnRhYmxlLCB5eXRleHQgPSAnJywgeXlsaW5lbm8gPSAwLCB5eWxlbmcgPSAwLCByZWNvdmVyaW5nID0gMCwgVEVSUk9SID0gMiwgRU9GID0gMTtcbiAgICB2YXIgYXJncyA9IGxzdGFjay5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIGxleGVyID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmxleGVyKTtcbiAgICB2YXIgc2hhcmVkU3RhdGUgPSB7IHl5OiB7fSB9O1xuICAgIGZvciAodmFyIGsgaW4gdGhpcy55eSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMueXksIGspKSB7XG4gICAgICAgICAgICBzaGFyZWRTdGF0ZS55eVtrXSA9IHRoaXMueXlba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV4ZXIuc2V0SW5wdXQoaW5wdXQsIHNoYXJlZFN0YXRlLnl5KTtcbiAgICBzaGFyZWRTdGF0ZS55eS5sZXhlciA9IGxleGVyO1xuICAgIHNoYXJlZFN0YXRlLnl5LnBhcnNlciA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiBsZXhlci55eWxsb2MgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbGV4ZXIueXlsbG9jID0ge307XG4gICAgfVxuICAgIHZhciB5eWxvYyA9IGxleGVyLnl5bGxvYztcbiAgICBsc3RhY2sucHVzaCh5eWxvYyk7XG4gICAgdmFyIHJhbmdlcyA9IGxleGVyLm9wdGlvbnMgJiYgbGV4ZXIub3B0aW9ucy5yYW5nZXM7XG4gICAgaWYgKHR5cGVvZiBzaGFyZWRTdGF0ZS55eS5wYXJzZUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucGFyc2VFcnJvciA9IHNoYXJlZFN0YXRlLnl5LnBhcnNlRXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLnBhcnNlRXJyb3I7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcFN0YWNrKG4pIHtcbiAgICAgICAgc3RhY2subGVuZ3RoID0gc3RhY2subGVuZ3RoIC0gMiAqIG47XG4gICAgICAgIHZzdGFjay5sZW5ndGggPSB2c3RhY2subGVuZ3RoIC0gbjtcbiAgICAgICAgbHN0YWNrLmxlbmd0aCA9IGxzdGFjay5sZW5ndGggLSBuO1xuICAgIH1cbiAgICBfdG9rZW5fc3RhY2s6XG4gICAgICAgIHZhciBsZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgICAgICB0b2tlbiA9IGxleGVyLmxleCgpIHx8IEVPRjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBzZWxmLnN5bWJvbHNfW3Rva2VuXSB8fCB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfTtcbiAgICB2YXIgc3ltYm9sLCBwcmVFcnJvclN5bWJvbCwgc3RhdGUsIGFjdGlvbiwgYSwgciwgeXl2YWwgPSB7fSwgcCwgbGVuLCBuZXdTdGF0ZSwgZXhwZWN0ZWQ7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgc3RhdGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdEFjdGlvbnNbc3RhdGVdKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSB0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzeW1ib2wgPT09IG51bGwgfHwgdHlwZW9mIHN5bWJvbCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IGxleCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0aW9uID0gdGFibGVbc3RhdGVdICYmIHRhYmxlW3N0YXRlXVtzeW1ib2xdO1xuICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAndW5kZWZpbmVkJyB8fCAhYWN0aW9uLmxlbmd0aCB8fCAhYWN0aW9uWzBdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVyclN0ciA9ICcnO1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChwIGluIHRhYmxlW3N0YXRlXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50ZXJtaW5hbHNfW3BdICYmIHAgPiBURVJST1IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkLnB1c2goJ1xcJycgKyB0aGlzLnRlcm1pbmFsc19bcF0gKyAnXFwnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxleGVyLnNob3dQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBlcnJTdHIgPSAnUGFyc2UgZXJyb3Igb24gbGluZSAnICsgKHl5bGluZW5vICsgMSkgKyAnOlxcbicgKyBsZXhlci5zaG93UG9zaXRpb24oKSArICdcXG5FeHBlY3RpbmcgJyArIGV4cGVjdGVkLmpvaW4oJywgJykgKyAnLCBnb3QgXFwnJyArICh0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wpICsgJ1xcJyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gJ1BhcnNlIGVycm9yIG9uIGxpbmUgJyArICh5eWxpbmVubyArIDEpICsgJzogVW5leHBlY3RlZCAnICsgKHN5bWJvbCA9PSBFT0YgPyAnZW5kIG9mIGlucHV0JyA6ICdcXCcnICsgKHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCkgKyAnXFwnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VFcnJvcihlcnJTdHIsIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogbGV4ZXIubWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiB0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGxleGVyLnl5bGluZW5vLFxuICAgICAgICAgICAgICAgICAgICBsb2M6IHl5bG9jLFxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvblswXSBpbnN0YW5jZW9mIEFycmF5ICYmIGFjdGlvbi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlIEVycm9yOiBtdWx0aXBsZSBhY3Rpb25zIHBvc3NpYmxlIGF0IHN0YXRlOiAnICsgc3RhdGUgKyAnLCB0b2tlbjogJyArIHN5bWJvbCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChhY3Rpb25bMF0pIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgc3RhY2sucHVzaChzeW1ib2wpO1xuICAgICAgICAgICAgdnN0YWNrLnB1c2gobGV4ZXIueXl0ZXh0KTtcbiAgICAgICAgICAgIGxzdGFjay5wdXNoKGxleGVyLnl5bGxvYyk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGFjdGlvblsxXSk7XG4gICAgICAgICAgICBzeW1ib2wgPSBudWxsO1xuICAgICAgICAgICAgaWYgKCFwcmVFcnJvclN5bWJvbCkge1xuICAgICAgICAgICAgICAgIHl5bGVuZyA9IGxleGVyLnl5bGVuZztcbiAgICAgICAgICAgICAgICB5eXRleHQgPSBsZXhlci55eXRleHQ7XG4gICAgICAgICAgICAgICAgeXlsaW5lbm8gPSBsZXhlci55eWxpbmVubztcbiAgICAgICAgICAgICAgICB5eWxvYyA9IGxleGVyLnl5bGxvYztcbiAgICAgICAgICAgICAgICBpZiAocmVjb3ZlcmluZyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3ZlcmluZy0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gcHJlRXJyb3JTeW1ib2w7XG4gICAgICAgICAgICAgICAgcHJlRXJyb3JTeW1ib2wgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGxlbiA9IHRoaXMucHJvZHVjdGlvbnNfW2FjdGlvblsxXV1bMV07XG4gICAgICAgICAgICB5eXZhbC4kID0gdnN0YWNrW3ZzdGFjay5sZW5ndGggLSBsZW5dO1xuICAgICAgICAgICAgeXl2YWwuXyQgPSB7XG4gICAgICAgICAgICAgICAgZmlyc3RfbGluZTogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAobGVuIHx8IDEpXS5maXJzdF9saW5lLFxuICAgICAgICAgICAgICAgIGxhc3RfbGluZTogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAxXS5sYXN0X2xpbmUsXG4gICAgICAgICAgICAgICAgZmlyc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLmZpcnN0X2NvbHVtbixcbiAgICAgICAgICAgICAgICBsYXN0X2NvbHVtbjogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAxXS5sYXN0X2NvbHVtblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChyYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB5eXZhbC5fJC5yYW5nZSA9IFtcbiAgICAgICAgICAgICAgICAgICAgbHN0YWNrW2xzdGFjay5sZW5ndGggLSAobGVuIHx8IDEpXS5yYW5nZVswXSxcbiAgICAgICAgICAgICAgICAgICAgbHN0YWNrW2xzdGFjay5sZW5ndGggLSAxXS5yYW5nZVsxXVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByID0gdGhpcy5wZXJmb3JtQWN0aW9uLmFwcGx5KHl5dmFsLCBbXG4gICAgICAgICAgICAgICAgeXl0ZXh0LFxuICAgICAgICAgICAgICAgIHl5bGVuZyxcbiAgICAgICAgICAgICAgICB5eWxpbmVubyxcbiAgICAgICAgICAgICAgICBzaGFyZWRTdGF0ZS55eSxcbiAgICAgICAgICAgICAgICBhY3Rpb25bMV0sXG4gICAgICAgICAgICAgICAgdnN0YWNrLFxuICAgICAgICAgICAgICAgIGxzdGFja1xuICAgICAgICAgICAgXS5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIHN0YWNrID0gc3RhY2suc2xpY2UoMCwgLTEgKiBsZW4gKiAyKTtcbiAgICAgICAgICAgICAgICB2c3RhY2sgPSB2c3RhY2suc2xpY2UoMCwgLTEgKiBsZW4pO1xuICAgICAgICAgICAgICAgIGxzdGFjayA9IGxzdGFjay5zbGljZSgwLCAtMSAqIGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMucHJvZHVjdGlvbnNfW2FjdGlvblsxXV1bMF0pO1xuICAgICAgICAgICAgdnN0YWNrLnB1c2goeXl2YWwuJCk7XG4gICAgICAgICAgICBsc3RhY2sucHVzaCh5eXZhbC5fJCk7XG4gICAgICAgICAgICBuZXdTdGF0ZSA9IHRhYmxlW3N0YWNrW3N0YWNrLmxlbmd0aCAtIDJdXVtzdGFja1tzdGFjay5sZW5ndGggLSAxXV07XG4gICAgICAgICAgICBzdGFjay5wdXNoKG5ld1N0YXRlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn19O1xuXG5cbmNvbnN0IGV4dGVuZCA9IHJlcXVpcmUoJy4uL3V0aWwnKS5leHRlbmRcblxuY29uc3QgbGFzdEl0ZW0gPSBhcnIgPT4gYXJyW2Fyci5sZW5ndGggLSAxXVxuXG5jb25zdCBvbmx5UHJvcGVydHkgPSBvYmogPT4gb2JqW09iamVjdC5rZXlzKG9iailbMF1dXG5cbmNvbnN0IG9jdGF2ZSA9IHN0ciA9PiB7XG4gIGNvbnN0IGxlbiA9IHN0ci5sZW5ndGhcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkgPT09ICcsJyA/IC1sZW4gOiBsZW5cbn1cblxuY29uc3QgcmVtb3ZlTGFzdEVtcHR5TWVhc3VyZSA9IHNjb3JlID0+IHtcbiAgY29uc3QgcGFydHMgPSBzY29yZS5wYXJ0c1xuICBpZiAoIXBhcnRzKSByZXR1cm5cblxuICBwYXJ0cy5mb3JFYWNoKHBhcnQgPT4ge1xuICAgIGNvbnN0IGxhc3RNZWFzdXJlID0gbGFzdEl0ZW0ocGFydC5tZWFzdXJlcylcbiAgICBpZiAobGFzdE1lYXN1cmUuZGF0YS5sZW5ndGggPT09IDApIHBhcnQubWVhc3VyZXMucG9wKClcbiAgfSlcbn1cblxuLyogZ2VuZXJhdGVkIGJ5IGppc29uLWxleCAwLjMuNCAqL1xudmFyIGxleGVyID0gKGZ1bmN0aW9uKCl7XG52YXIgbGV4ZXIgPSAoe1xuXG5FT0Y6MSxcblxucGFyc2VFcnJvcjpmdW5jdGlvbiBwYXJzZUVycm9yKHN0ciwgaGFzaCkge1xuICAgICAgICBpZiAodGhpcy55eS5wYXJzZXIpIHtcbiAgICAgICAgICAgIHRoaXMueXkucGFyc2VyLnBhcnNlRXJyb3Ioc3RyLCBoYXNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHIpO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gcmVzZXRzIHRoZSBsZXhlciwgc2V0cyBuZXcgaW5wdXRcbnNldElucHV0OmZ1bmN0aW9uIChpbnB1dCwgeXkpIHtcbiAgICAgICAgdGhpcy55eSA9IHl5IHx8IHRoaXMueXkgfHwge307XG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuX21vcmUgPSB0aGlzLl9iYWNrdHJhY2sgPSB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy55eWxpbmVubyA9IHRoaXMueXlsZW5nID0gMDtcbiAgICAgICAgdGhpcy55eXRleHQgPSB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoID0gJyc7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sgPSBbJ0lOSVRJQUwnXTtcbiAgICAgICAgdGhpcy55eWxsb2MgPSB7XG4gICAgICAgICAgICBmaXJzdF9saW5lOiAxLFxuICAgICAgICAgICAgZmlyc3RfY29sdW1uOiAwLFxuICAgICAgICAgICAgbGFzdF9saW5lOiAxLFxuICAgICAgICAgICAgbGFzdF9jb2x1bW46IDBcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gWzAsMF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4vLyBjb25zdW1lcyBhbmQgcmV0dXJucyBvbmUgY2hhciBmcm9tIHRoZSBpbnB1dFxuaW5wdXQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2ggPSB0aGlzLl9pbnB1dFswXTtcbiAgICAgICAgdGhpcy55eXRleHQgKz0gY2g7XG4gICAgICAgIHRoaXMueXlsZW5nKys7XG4gICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgIHRoaXMubWF0Y2ggKz0gY2g7XG4gICAgICAgIHRoaXMubWF0Y2hlZCArPSBjaDtcbiAgICAgICAgdmFyIGxpbmVzID0gY2gubWF0Y2goLyg/Olxcclxcbj98XFxuKS4qL2cpO1xuICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsaW5lbm8rKztcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLmxhc3RfbGluZSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4rKztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2VbMV0rKztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2lucHV0ID0gdGhpcy5faW5wdXQuc2xpY2UoMSk7XG4gICAgICAgIHJldHVybiBjaDtcbiAgICB9LFxuXG4vLyB1bnNoaWZ0cyBvbmUgY2hhciAob3IgYSBzdHJpbmcpIGludG8gdGhlIGlucHV0XG51bnB1dDpmdW5jdGlvbiAoY2gpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNoLmxlbmd0aDtcbiAgICAgICAgdmFyIGxpbmVzID0gY2guc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcblxuICAgICAgICB0aGlzLl9pbnB1dCA9IGNoICsgdGhpcy5faW5wdXQ7XG4gICAgICAgIHRoaXMueXl0ZXh0ID0gdGhpcy55eXRleHQuc3Vic3RyKDAsIHRoaXMueXl0ZXh0Lmxlbmd0aCAtIGxlbik7XG4gICAgICAgIC8vdGhpcy55eWxlbmcgLT0gbGVuO1xuICAgICAgICB0aGlzLm9mZnNldCAtPSBsZW47XG4gICAgICAgIHZhciBvbGRMaW5lcyA9IHRoaXMubWF0Y2guc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcbiAgICAgICAgdGhpcy5tYXRjaCA9IHRoaXMubWF0Y2guc3Vic3RyKDAsIHRoaXMubWF0Y2gubGVuZ3RoIC0gMSk7XG4gICAgICAgIHRoaXMubWF0Y2hlZCA9IHRoaXMubWF0Y2hlZC5zdWJzdHIoMCwgdGhpcy5tYXRjaGVkLmxlbmd0aCAtIDEpO1xuXG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGluZW5vIC09IGxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHIgPSB0aGlzLnl5bGxvYy5yYW5nZTtcblxuICAgICAgICB0aGlzLnl5bGxvYyA9IHtcbiAgICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMueXlsaW5lbm8gKyAxLFxuICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4sXG4gICAgICAgICAgICBsYXN0X2NvbHVtbjogbGluZXMgP1xuICAgICAgICAgICAgICAgIChsaW5lcy5sZW5ndGggPT09IG9sZExpbmVzLmxlbmd0aCA/IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbiA6IDApXG4gICAgICAgICAgICAgICAgICsgb2xkTGluZXNbb2xkTGluZXMubGVuZ3RoIC0gbGluZXMubGVuZ3RoXS5sZW5ndGggLSBsaW5lc1swXS5sZW5ndGggOlxuICAgICAgICAgICAgICB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4gLSBsZW5cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2UgPSBbclswXSwgclswXSArIHRoaXMueXlsZW5nIC0gbGVuXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnl5bGVuZyA9IHRoaXMueXl0ZXh0Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuLy8gV2hlbiBjYWxsZWQgZnJvbSBhY3Rpb24sIGNhY2hlcyBtYXRjaGVkIHRleHQgYW5kIGFwcGVuZHMgaXQgb24gbmV4dCBhY3Rpb25cbm1vcmU6ZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9tb3JlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuLy8gV2hlbiBjYWxsZWQgZnJvbSBhY3Rpb24sIHNpZ25hbHMgdGhlIGxleGVyIHRoYXQgdGhpcyBydWxlIGZhaWxzIHRvIG1hdGNoIHRoZSBpbnB1dCwgc28gdGhlIG5leHQgbWF0Y2hpbmcgcnVsZSAocmVnZXgpIHNob3VsZCBiZSB0ZXN0ZWQgaW5zdGVhZC5cbnJlamVjdDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9iYWNrdHJhY2sgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcignTGV4aWNhbCBlcnJvciBvbiBsaW5lICcgKyAodGhpcy55eWxpbmVubyArIDEpICsgJy4gWW91IGNhbiBvbmx5IGludm9rZSByZWplY3QoKSBpbiB0aGUgbGV4ZXIgd2hlbiB0aGUgbGV4ZXIgaXMgb2YgdGhlIGJhY2t0cmFja2luZyBwZXJzdWFzaW9uIChvcHRpb25zLmJhY2t0cmFja19sZXhlciA9IHRydWUpLlxcbicgKyB0aGlzLnNob3dQb3NpdGlvbigpLCB7XG4gICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgICAgICB0b2tlbjogbnVsbCxcbiAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLnl5bGluZW5vXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbi8vIHJldGFpbiBmaXJzdCBuIGNoYXJhY3RlcnMgb2YgdGhlIG1hdGNoXG5sZXNzOmZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHRoaXMudW5wdXQodGhpcy5tYXRjaC5zbGljZShuKSk7XG4gICAgfSxcblxuLy8gZGlzcGxheXMgYWxyZWFkeSBtYXRjaGVkIGlucHV0LCBpLmUuIGZvciBlcnJvciBtZXNzYWdlc1xucGFzdElucHV0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhc3QgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSB0aGlzLm1hdGNoLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiAocGFzdC5sZW5ndGggPiAyMCA/ICcuLi4nOicnKSArIHBhc3Quc3Vic3RyKC0yMCkucmVwbGFjZSgvXFxuL2csIFwiXCIpO1xuICAgIH0sXG5cbi8vIGRpc3BsYXlzIHVwY29taW5nIGlucHV0LCBpLmUuIGZvciBlcnJvciBtZXNzYWdlc1xudXBjb21pbmdJbnB1dDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5tYXRjaDtcbiAgICAgICAgaWYgKG5leHQubGVuZ3RoIDwgMjApIHtcbiAgICAgICAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQuc3Vic3RyKDAsIDIwLW5leHQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG5leHQuc3Vic3RyKDAsMjApICsgKG5leHQubGVuZ3RoID4gMjAgPyAnLi4uJyA6ICcnKSkucmVwbGFjZSgvXFxuL2csIFwiXCIpO1xuICAgIH0sXG5cbi8vIGRpc3BsYXlzIHRoZSBjaGFyYWN0ZXIgcG9zaXRpb24gd2hlcmUgdGhlIGxleGluZyBlcnJvciBvY2N1cnJlZCwgaS5lLiBmb3IgZXJyb3IgbWVzc2FnZXNcbnNob3dQb3NpdGlvbjpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcmUgPSB0aGlzLnBhc3RJbnB1dCgpO1xuICAgICAgICB2YXIgYyA9IG5ldyBBcnJheShwcmUubGVuZ3RoICsgMSkuam9pbihcIi1cIik7XG4gICAgICAgIHJldHVybiBwcmUgKyB0aGlzLnVwY29taW5nSW5wdXQoKSArIFwiXFxuXCIgKyBjICsgXCJeXCI7XG4gICAgfSxcblxuLy8gdGVzdCB0aGUgbGV4ZWQgdG9rZW46IHJldHVybiBGQUxTRSB3aGVuIG5vdCBhIG1hdGNoLCBvdGhlcndpc2UgcmV0dXJuIHRva2VuXG50ZXN0X21hdGNoOmZ1bmN0aW9uIChtYXRjaCwgaW5kZXhlZF9ydWxlKSB7XG4gICAgICAgIHZhciB0b2tlbixcbiAgICAgICAgICAgIGxpbmVzLFxuICAgICAgICAgICAgYmFja3VwO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7XG4gICAgICAgICAgICAvLyBzYXZlIGNvbnRleHRcbiAgICAgICAgICAgIGJhY2t1cCA9IHtcbiAgICAgICAgICAgICAgICB5eWxpbmVubzogdGhpcy55eWxpbmVubyxcbiAgICAgICAgICAgICAgICB5eWxsb2M6IHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxsb2MuZmlyc3RfbGluZSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLmxhc3RfbGluZSxcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGxhc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeXl0ZXh0OiB0aGlzLnl5dGV4dCxcbiAgICAgICAgICAgICAgICBtYXRjaDogdGhpcy5tYXRjaCxcbiAgICAgICAgICAgICAgICBtYXRjaGVzOiB0aGlzLm1hdGNoZXMsXG4gICAgICAgICAgICAgICAgbWF0Y2hlZDogdGhpcy5tYXRjaGVkLFxuICAgICAgICAgICAgICAgIHl5bGVuZzogdGhpcy55eWxlbmcsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICBfbW9yZTogdGhpcy5fbW9yZSxcbiAgICAgICAgICAgICAgICBfaW5wdXQ6IHRoaXMuX2lucHV0LFxuICAgICAgICAgICAgICAgIHl5OiB0aGlzLnl5LFxuICAgICAgICAgICAgICAgIGNvbmRpdGlvblN0YWNrOiB0aGlzLmNvbmRpdGlvblN0YWNrLnNsaWNlKDApLFxuICAgICAgICAgICAgICAgIGRvbmU6IHRoaXMuZG9uZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgYmFja3VwLnl5bGxvYy5yYW5nZSA9IHRoaXMueXlsbG9jLnJhbmdlLnNsaWNlKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGluZXMgPSBtYXRjaFswXS5tYXRjaCgvKD86XFxyXFxuP3xcXG4pLiovZyk7XG4gICAgICAgIGlmIChsaW5lcykge1xuICAgICAgICAgICAgdGhpcy55eWxpbmVubyArPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy55eWxsb2MgPSB7XG4gICAgICAgICAgICBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5sYXN0X2xpbmUsXG4gICAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMueXlsaW5lbm8gKyAxLFxuICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbixcbiAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsaW5lcyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubGVuZ3RoIC0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubWF0Y2goL1xccj9cXG4/LylbMF0ubGVuZ3RoIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbiArIG1hdGNoWzBdLmxlbmd0aFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnl5dGV4dCArPSBtYXRjaFswXTtcbiAgICAgICAgdGhpcy5tYXRjaCArPSBtYXRjaFswXTtcbiAgICAgICAgdGhpcy5tYXRjaGVzID0gbWF0Y2g7XG4gICAgICAgIHRoaXMueXlsZW5nID0gdGhpcy55eXRleHQubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2UgPSBbdGhpcy5vZmZzZXQsIHRoaXMub2Zmc2V0ICs9IHRoaXMueXlsZW5nXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tb3JlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2JhY2t0cmFjayA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgIHRoaXMubWF0Y2hlZCArPSBtYXRjaFswXTtcbiAgICAgICAgdG9rZW4gPSB0aGlzLnBlcmZvcm1BY3Rpb24uY2FsbCh0aGlzLCB0aGlzLnl5LCB0aGlzLCBpbmRleGVkX3J1bGUsIHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXSk7XG4gICAgICAgIGlmICh0aGlzLmRvbmUgJiYgdGhpcy5faW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JhY2t0cmFjaykge1xuICAgICAgICAgICAgLy8gcmVjb3ZlciBjb250ZXh0XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIGJhY2t1cCkge1xuICAgICAgICAgICAgICAgIHRoaXNba10gPSBiYWNrdXBba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHJ1bGUgYWN0aW9uIGNhbGxlZCByZWplY3QoKSBpbXBseWluZyB0aGUgbmV4dCBydWxlIHNob3VsZCBiZSB0ZXN0ZWQgaW5zdGVhZC5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuLy8gcmV0dXJuIG5leHQgbWF0Y2ggaW4gaW5wdXRcbm5leHQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5FT0Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pbnB1dCkge1xuICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b2tlbixcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgdGVtcE1hdGNoLFxuICAgICAgICAgICAgaW5kZXg7XG4gICAgICAgIGlmICghdGhpcy5fbW9yZSkge1xuICAgICAgICAgICAgdGhpcy55eXRleHQgPSAnJztcbiAgICAgICAgICAgIHRoaXMubWF0Y2ggPSAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLl9jdXJyZW50UnVsZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGVtcE1hdGNoID0gdGhpcy5faW5wdXQubWF0Y2godGhpcy5ydWxlc1tydWxlc1tpXV0pO1xuICAgICAgICAgICAgaWYgKHRlbXBNYXRjaCAmJiAoIW1hdGNoIHx8IHRlbXBNYXRjaFswXS5sZW5ndGggPiBtYXRjaFswXS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSB0ZW1wTWF0Y2g7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50ZXN0X21hdGNoKHRlbXBNYXRjaCwgcnVsZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmFja3RyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIHJ1bGUgYWN0aW9uIGNhbGxlZCByZWplY3QoKSBpbXBseWluZyBhIHJ1bGUgTUlTbWF0Y2guXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlOiB0aGlzIGlzIGEgbGV4ZXIgcnVsZSB3aGljaCBjb25zdW1lcyBpbnB1dCB3aXRob3V0IHByb2R1Y2luZyBhIHRva2VuIChlLmcuIHdoaXRlc3BhY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMuZmxleCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMudGVzdF9tYXRjaChtYXRjaCwgcnVsZXNbaW5kZXhdKTtcbiAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbHNlOiB0aGlzIGlzIGEgbGV4ZXIgcnVsZSB3aGljaCBjb25zdW1lcyBpbnB1dCB3aXRob3V0IHByb2R1Y2luZyBhIHRva2VuIChlLmcuIHdoaXRlc3BhY2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lucHV0ID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5FT0Y7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKCdMZXhpY2FsIGVycm9yIG9uIGxpbmUgJyArICh0aGlzLnl5bGluZW5vICsgMSkgKyAnLiBVbnJlY29nbml6ZWQgdGV4dC5cXG4nICsgdGhpcy5zaG93UG9zaXRpb24oKSwge1xuICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgdG9rZW46IG51bGwsXG4gICAgICAgICAgICAgICAgbGluZTogdGhpcy55eWxpbmVub1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyByZXR1cm4gbmV4dCBtYXRjaCB0aGF0IGhhcyBhIHRva2VuXG5sZXg6ZnVuY3Rpb24gbGV4KCkge1xuICAgICAgICB2YXIgciA9IHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZXgoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIGFjdGl2YXRlcyBhIG5ldyBsZXhlciBjb25kaXRpb24gc3RhdGUgKHB1c2hlcyB0aGUgbmV3IGxleGVyIGNvbmRpdGlvbiBzdGF0ZSBvbnRvIHRoZSBjb25kaXRpb24gc3RhY2spXG5iZWdpbjpmdW5jdGlvbiBiZWdpbihjb25kaXRpb24pIHtcbiAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjay5wdXNoKGNvbmRpdGlvbik7XG4gICAgfSxcblxuLy8gcG9wIHRoZSBwcmV2aW91c2x5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGUgb2ZmIHRoZSBjb25kaXRpb24gc3RhY2tcbnBvcFN0YXRlOmZ1bmN0aW9uIHBvcFN0YXRlKCkge1xuICAgICAgICB2YXIgbiA9IHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrWzBdO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gcHJvZHVjZSB0aGUgbGV4ZXIgcnVsZSBzZXQgd2hpY2ggaXMgYWN0aXZlIGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGVcbl9jdXJyZW50UnVsZXM6ZnVuY3Rpb24gX2N1cnJlbnRSdWxlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoICYmIHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uc1t0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV1dLnJ1bGVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uc1tcIklOSVRJQUxcIl0ucnVsZXM7XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyByZXR1cm4gdGhlIGN1cnJlbnRseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlOyB3aGVuIGFuIGluZGV4IGFyZ3VtZW50IGlzIHByb3ZpZGVkIGl0IHByb2R1Y2VzIHRoZSBOLXRoIHByZXZpb3VzIGNvbmRpdGlvbiBzdGF0ZSwgaWYgYXZhaWxhYmxlXG50b3BTdGF0ZTpmdW5jdGlvbiB0b3BTdGF0ZShuKSB7XG4gICAgICAgIG4gPSB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDEgLSBNYXRoLmFicyhuIHx8IDApO1xuICAgICAgICBpZiAobiA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFja1tuXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIklOSVRJQUxcIjtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIGFsaWFzIGZvciBiZWdpbihjb25kaXRpb24pXG5wdXNoU3RhdGU6ZnVuY3Rpb24gcHVzaFN0YXRlKGNvbmRpdGlvbikge1xuICAgICAgICB0aGlzLmJlZ2luKGNvbmRpdGlvbik7XG4gICAgfSxcblxuLy8gcmV0dXJuIHRoZSBudW1iZXIgb2Ygc3RhdGVzIGN1cnJlbnRseSBvbiB0aGUgc3RhY2tcbnN0YXRlU3RhY2tTaXplOmZ1bmN0aW9uIHN0YXRlU3RhY2tTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGg7XG4gICAgfSxcbm9wdGlvbnM6IHt9LFxucGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gYW5vbnltb3VzKHl5LHl5XywkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zLFlZX1NUQVJUKSB7XG52YXIgWVlTVEFURT1ZWV9TVEFSVDtcbnN3aXRjaCgkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zKSB7XG5jYXNlIDA6cmV0dXJuIDlcbmJyZWFrO1xuY2FzZSAxOnJldHVybiA5XG5icmVhaztcbmNhc2UgMjpyZXR1cm4gOVxuYnJlYWs7XG5jYXNlIDM6IHRoaXMuYmVnaW4oJ3RpdGxlJykgXG5icmVhaztcbmNhc2UgNDogeXlfLnl5dGV4dCA9IHl5Xy55eXRleHQuc3Vic3RyKDAsIHl5Xy55eWxlbmcgLSAyKS50cmltKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE0IFxuYnJlYWs7XG5jYXNlIDU6IHRoaXMuYmVnaW4oJ0lOSVRJQUwnKSBcbmJyZWFrO1xuY2FzZSA2OiB0aGlzLmJlZ2luKCdJTklUSUFMJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgeXlfLnl5dGV4dCA9IHl5Xy55eXRleHQudHJpbSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxNSBcbmJyZWFrO1xuY2FzZSA3OiB0aGlzLmJlZ2luKCd0aW1lJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgeXlfLnl5dGV4dCA9IHl5Xy55eXRleHQuc3Vic3RyKDAsIHl5Xy55eWxlbmcgLSAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gNTggXG5icmVhaztcbmNhc2UgODogdGhpcy5iZWdpbignSU5JVElBTCcpOyByZXR1cm4gNTkgXG5icmVhaztcbmNhc2UgOTpyZXR1cm4gNDFcbmJyZWFrO1xuY2FzZSAxMDpyZXR1cm4gMzlcbmJyZWFrO1xuY2FzZSAxMTpyZXR1cm4gNDBcbmJyZWFrO1xuY2FzZSAxMjpyZXR1cm4gNDNcbmJyZWFrO1xuY2FzZSAxMzpyZXR1cm4gNDdcbmJyZWFrO1xuY2FzZSAxNDpyZXR1cm4gNDZcbmJyZWFrO1xuY2FzZSAxNTpyZXR1cm4gMjhcbmJyZWFrO1xuY2FzZSAxNjpyZXR1cm4gNDRcbmJyZWFrO1xuY2FzZSAxNzpyZXR1cm4gNDVcbmJyZWFrO1xuY2FzZSAxODpyZXR1cm4gJy4nXG5icmVhaztcbmNhc2UgMTk6cmV0dXJuIDI5XG5icmVhaztcbmNhc2UgMjA6cmV0dXJuIDQ4XG5icmVhaztcbmNhc2UgMjE6cmV0dXJuIDUwXG5icmVhaztcbmNhc2UgMjI6cmV0dXJuIDM0XG5icmVhaztcbmNhc2UgMjM6cmV0dXJuIDM1XG5icmVhaztcbmNhc2UgMjQ6cmV0dXJuICcvJ1xuYnJlYWs7XG5jYXNlIDI1OnJldHVybiAnXFxcXCdcbmJyZWFrO1xuY2FzZSAyNjpyZXR1cm4gMjNcbmJyZWFrO1xuY2FzZSAyNzpyZXR1cm4gMjJcbmJyZWFrO1xuY2FzZSAyODpyZXR1cm4gJ1t8J1xuYnJlYWs7XG5jYXNlIDI5OnJldHVybiAyNFxuYnJlYWs7XG5jYXNlIDMwOnJldHVybiAyNlxuYnJlYWs7XG5jYXNlIDMxOnJldHVybiAyNVxuYnJlYWs7XG5jYXNlIDMyOnJldHVybiAyMVxuYnJlYWs7XG5jYXNlIDMzOnJldHVybiA1MVxuYnJlYWs7XG5jYXNlIDM0OnJldHVybiA1M1xuYnJlYWs7XG5jYXNlIDM1OnJldHVybiA1NVxuYnJlYWs7XG5jYXNlIDM2OnJldHVybiAxMFxuYnJlYWs7XG5jYXNlIDM3OnJldHVybiA5XG5icmVhaztcbmNhc2UgMzg6cmV0dXJuIDVcbmJyZWFrO1xuY2FzZSAzOTpyZXR1cm4gJ0lOVkFMSUQnXG5icmVhaztcbn1cbn0sXG5ydWxlczogWy9eKD86XFwvXFwvW15cXG5dKikvLC9eKD86XFwvXFwqKFtcXHNcXFNdKj8pXFwqXFwvKS8sL14oPzpcXC9cXCpbXFxzXFxTXSopLywvXig/Ojw8KS8sL14oPzouKj4+KS8sL14oPzooWyBcXHRdKSooW1xcblxccl0pKS8sL14oPzouKikvLC9eKD86KChbMS05XVxcZHswLDJ9KVxcLykpLywvXig/OihbMS05XVxcZHswLDJ9KVteXFxkXSkvLC9eKD86KCN7MSwyfXxufGJ7MSwyfSkpLywvXig/OlsxLTddKS8sL14oPzosK3wnKykvLC9eKD86XFwuKykvLC9eKD86KCAqLSAqKXszfSkvLC9eKD86KCAqLSAqKSkvLC9eKD86ICp+KS8sL14oPzpbX10pLywvXig/Oj0pLywvXig/OlxcLikvLC9eKD86WzBdKS8sL14oPzo8KS8sL14oPzo+KS8sL14oPzpcXCgpLywvXig/OlxcKSkvLC9eKD86XFwvKS8sL14oPzpcXFxcKS8sL14oPzpcXHxcXF0pLywvXig/OlxcfFxcfCkvLC9eKD86XFxbXFx8KS8sL14oPzpcXHw6KS8sL14oPzo6XFx8OikvLC9eKD86OlxcfCkvLC9eKD86XFx8KS8sL14oPzpcXHspLywvXig/OlxcfSkvLC9eKD86OikvLC9eKD86KFtcXG5cXHJdKSkvLC9eKD86KFsgXFx0XSkpLywvXig/OiQpLywvXig/Oi4pL10sXG5jb25kaXRpb25zOiB7XCJ0aW1lXCI6e1wicnVsZXNcIjpbOF0sXCJpbmNsdXNpdmVcIjpmYWxzZX0sXCJ0aXRsZVwiOntcInJ1bGVzXCI6WzQsNSw2XSxcImluY2x1c2l2ZVwiOmZhbHNlfSxcIklOSVRJQUxcIjp7XCJydWxlc1wiOlswLDEsMiwzLDcsOSwxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwyMSwyMiwyMywyNCwyNSwyNiwyNywyOCwyOSwzMCwzMSwzMiwzMywzNCwzNSwzNiwzNywzOCwzOV0sXCJpbmNsdXNpdmVcIjp0cnVlfX1cbn0pO1xucmV0dXJuIGxleGVyO1xufSkoKTtcbnBhcnNlci5sZXhlciA9IGxleGVyO1xuZnVuY3Rpb24gUGFyc2VyICgpIHtcbiAgdGhpcy55eSA9IHt9O1xufVxuUGFyc2VyLnByb3RvdHlwZSA9IHBhcnNlcjtwYXJzZXIuUGFyc2VyID0gUGFyc2VyO1xucmV0dXJuIG5ldyBQYXJzZXI7XG59KSgpO1xubW9kdWxlLmV4cG9ydHMgPSBwYXJzZXJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9wYXJzZXIvcGFyc2VyLmppc29uXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImNvbnN0IElTX09CSkVDVCA9IHsgJ2Z1bnRpb24nOiB0cnVlLCAnb2JqZWN0JzogdHJ1ZSB9XG5jb25zdCBpc09iamVjdCA9IG9iaiA9PiBJU19PQkpFQ1RbdHlwZW9mIG9ial0gJiYgISFvYmpcblxuZXhwb3J0IGNvbnN0IG9iakVhY2ggPSAob2JqLCBjYWxsYmFjaykgPT4ge1xuICBpZiAoaXNPYmplY3Qob2JqKSkge1xuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChrZXkgPT4geyBjYWxsYmFjayhvYmpba2V5XSwga2V5KSB9KVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBleHRlbmQgPSAob2JqLCBleHQpID0+IHtcbiAgb2JqRWFjaChleHQsICh2YWwsIGtleSkgPT4geyBvYmpba2V5XSA9IHZhbCB9KVxuICByZXR1cm4gb2JqXG59XG5cbmV4cG9ydCBjb25zdCBuZWFyID0gKGEsIGIpID0+IE1hdGguYWJzKGEgLSBiKSA8IDAuMDAwMDFcblxuY29uc3QgaXNBY2Nlc3NvclByb3BlcnR5ID0gdmFsdWUgPT4gaXNPYmplY3QodmFsdWUpICYmXG4gICAgICAgICh0eXBlb2YgdmFsdWUuZ2V0ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB2YWx1ZS5zZXQgPT09ICdmdW5jdGlvbicpXG5cbi8qKlxuICogRGVmaW5lIEVTNSBnZXR0ZXIvc2V0dGVyIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBUaGUgb2JqZWN0IHRvIGJlIGRlZmluZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBFUzUgZ2V0dGVyL3NldHRlciBwcm9wZXJ0aWVzLlxuICogRm9yIGV4YW1wbGU6XG4gKiBgYGBcbiAqIHtcbiAqICAgbmFtZToge1xuICogICAgIGdldDogZnVuY3Rpb24gKCkgey4uLn0sXG4gKiAgICAgc2V0OiBmdW5jdGlvbiAoKSB7Li4ufVxuICogICB9LFxuICogICBhZ2U6IHtcbiAqICAgICAgZ2V0Oi4uLlxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmluZVByb3BlcnRpZXMgPSAob2JqLCBwcm9wcykgPT4ge1xuICBvYmpFYWNoKHByb3BzLCAodmFsdWUsIHByb3ApID0+IHtcbiAgICB2YXIgZGVzY3JpcHRvclxuICAgIGlmIChpc0FjY2Vzc29yUHJvcGVydHkodmFsdWUpKSB7XG4gICAgICBkZXNjcmlwdG9yID0gdmFsdWVcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZGVzY3JpcHRvciA9IHsgdmFsdWU6IHZhbHVlIH1cbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZS5jb25zdGFudCkge1xuICAgICAgZGVzY3JpcHRvciA9IHsgdmFsdWU6IHZhbHVlLmNvbnN0YW50IH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCBkZXNjcmlwdG9yKVxuICB9KVxufVxuXG5sZXQgdG9KU09OV2l0aERlZmF1bHQgPSB0cnVlXG5cbmV4cG9ydCBjb25zdCBtYWtlVG9KU09OID0gKHZhbHVlcywgZWxOYW1lKSA9PiBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmlzRW1wdHkpIHJldHVyblxuXG4gIGNvbnN0IHJlc3VsdCA9IHt9XG5cbiAgb2JqRWFjaCh2YWx1ZXMsIChkZWZhdWx0VmFsdWUsIHByb3ApID0+IHtcbiAgICBpZiAodG9KU09OV2l0aERlZmF1bHQgfHwgdGhpc1twcm9wXSAhPT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXN1bHRbcHJvcF0gPSB0aGlzW3Byb3BdXG4gICAgfVxuICB9KVxuICBpZiAoIWVsTmFtZSkgcmV0dXJuIHJlc3VsdFxuXG4gIGNvbnN0IHJlcyA9IHt9XG4gIHJlc1tlbE5hbWVdID0gcmVzdWx0XG4gIHJldHVybiByZXNcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlsLmpzIiwiaW1wb3J0IHsgbWFrZVRvSlNPTiwgZXh0ZW5kIH0gZnJvbSAnLi4vdXRpbCdcbmltcG9ydCBTY29yZUhlYWQgZnJvbSAnLi9TY29yZUhlYWQnXG5pbXBvcnQgUGFydHdpc2VQYXJ0cyBmcm9tICcuL1BhcnR3aXNlUGFydHMnXG5pbXBvcnQgVGltZXdpc2VNZWFzdXJlcyBmcm9tICcuL1RpbWV3aXNlTWVhc3VyZXMnXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IHNjb3JlIC0gcGxhaW4gc2NvcmUgb2JqZWN0LlxuICogQG1peGVzIFBsYXllck1peGluXG4gKi9cbmNsYXNzIFNjb3JlIHtcbiAgY29uc3RydWN0b3Ioc2NvcmUpIHtcbiAgICBleHRlbmQodGhpcywgc2NvcmUpXG4gIH1cblxuICAvKipcbiAgICogSGVhZCBvZiB0aGUgc2NvcmUuXG4gICAqIEB0eXBlIHtTY29yZUhlYWR9XG4gICAqL1xuICBnZXQgaGVhZCgpIHsgcmV0dXJuIHRoaXMuX2hlYWQgfHwgKHRoaXMuX2hlYWQgPSBuZXcgU2NvcmVIZWFkKCkpIH1cbiAgc2V0IGhlYWQoaGVhZCkgeyB0aGlzLl9oZWFkID0gbmV3IFNjb3JlSGVhZChoZWFkKSB9XG5cbiAgLyoqXG4gICAqIFBhcnR3aXNlIHBhcnRzLlxuICAgKiAtIChHZXR0ZXIpXG4gICAqIC0gKFNldHRlcilcbiAgICogQHR5cGUge1BhcnR3aXNlUGFydHN9XG4gICAqL1xuICBnZXQgcGFydHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnRzIHx8ICh0aGlzLl9wYXJ0cyA9IG5ldyBQYXJ0d2lzZVBhcnRzKHRoaXMpKVxuICB9XG4gIHNldCBwYXJ0cyhwYXJ0cykge1xuICAgIHRoaXMucGFydHMucmVtb3ZlQWxsKClcbiAgICB0aGlzLnBhcnRzLmFkZFBhcnRzKHBhcnRzKVxuICAgIHRoaXMubWVhc3VyZXMuZnJvbVBhcnR3aXNlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBUaW1ld2lzZSBtZWFzdXJlcywgZ2VuZXJhdGVkIGJ5IHRoZSBpbml0aWFsaXplIGZ1bmN0aW9uLlxuICAgKiBAdHlwZSB7VGltZXdpc2VNZWFzdXJlc31cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbWVhc3VyZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lYXN1cmVzIHx8ICh0aGlzLl9tZWFzdXJlcyA9IG5ldyBUaW1ld2lzZU1lYXN1cmVzKHRoaXMpKVxuICB9XG5cbiAgLyoqXG4gICAqIEEgY2VsbCBpcyBpZGVudGljYWxseSBhIG1lYXN1cmUgaW4gYSBwYXJ0IG9yIGEgcGFydCBpbiBhIG1lYXN1cmUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259XG4gICAqL1xuICB3YWxrQ2VsbHMoY2FsbGJhY2spIHtcbiAgICB0aGlzLnBhcnRzLmZvckVhY2goKHBhcnQsIHApID0+IHtcbiAgICAgIHBhcnQubWVhc3VyZXMuZm9yRWFjaCgoY2VsbCwgbSkgPT4geyBjYWxsYmFjayhjZWxsLCBtLCBwKSB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogV2FsayBlYWNoIG11c2ljIGRhdGEuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICB3YWxrTXVzaWNEYXRhKGNhbGxiYWNrKSB7XG4gICAgdGhpcy53YWxrQ2VsbHMoKGNlbGwsIG0sIHApID0+IHtcbiAgICAgIGNlbGwuZGF0YS5mb3JFYWNoKChkYXRhLCBkKSA9PiB7IGNhbGxiYWNrKGRhdGEsIGQsIG0sIHApIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHNjb3JlIHRvIHN0cmluZy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBNdXNqZSBzb3VyY2UgY29kZS5cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmhlYWQgKyB0aGlzLnBhcnRzLm1hcCgocGFydCkgPT4gcGFydC50b1N0cmluZygpKS5qb2luKCdcXG5cXG4nKVxuICB9XG5cbiAgLyoqXG4gICAqIEN1c3RvbSB0b0pTT04gbWV0aG9kLlxuICAgKiBAbWV0aG9kXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHRvSlNPTiA9IG1ha2VUb0pTT04oe1xuICAgIGhlYWQ6IHVuZGVmaW5lZCxcbiAgICBwYXJ0czogdW5kZWZpbmVkXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IFNjb3JlXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbW9kZWwvU2NvcmUuanMiLCJpbXBvcnQgeyBtYWtlVG9KU09OLCBleHRlbmQgfSBmcm9tICcuLi91dGlsJ1xuXG4vKipcbiAqIENvbnN0cnVjdCBoZWFkIG9mIHRoZSBzY29yZS5cbiAqIEBjbGFzc1xuICogQHBhcmFtIHtPYmplY3R9IGhlYWRcbiAqL1xuY2xhc3MgU2NvcmVIZWFkIHtcbiAgY29uc3RydWN0b3IoaGVhZCkge1xuICAgIGV4dGVuZCh0aGlzLCBoZWFkKVxuICB9XG5cbiAgLyoqXG4gICAqIFRpdGxlIG9mIHRoZSBzY29yZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJydcbiAgICovXG4gIHRpdGxlID0gJydcblxuICAvKipcbiAgICogU3VidGl0bGUgb2YgdGhlIHNjb3JlLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnJ1xuICAgKi9cbiAgc3VidGl0bGUgPSAnJ1xuXG4gIC8qKlxuICAgKiBTdWJzdWJ0aXRsZSBvZiB0aGUgc2NvcmUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICcnXG4gICAqL1xuICBzdWJzdWJ0aXRsZSA9ICcnXG5cbiAgLyoqXG4gICAqIENvbXBvc2VyIG9mIHRoZSBzY29yZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGNvbXBvc2VyID0gdW5kZWZpbmVkXG5cbiAgLyoqXG4gICAqIEFycmFuZ2VyIG9mIHRoZSBzY29yZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGFycmFuZ2VyID0gdW5kZWZpbmVkXG5cbiAgLyoqXG4gICAqIEx5cmljaXN0IG9mIHRoZSBzY29yZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGx5cmljaXN0ID0gdW5kZWZpbmVkXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBzY29yZSBoZWFkIGlzIGVtcHR5LlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gIXRoaXMudGl0bGUgJiYgIXRoaXMuc3VidGl0bGUgJiYgIXRoaXMuc3Vic3VidGl0bGUgJiZcbiAgICAgICAgICAgIXRoaXMuY29tcG9zZXIgJiYgIXRoaXMuYXJyYW5nZXIgJiYgIXRoaXMubHlyaWNpc3RcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHNjb3JlIGhlYWQgdG8gc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb252ZXJ0ZWQgbXVzamUgaGVhZCBzb3VyY2UgY29kZS5cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IHRpdGxlID0gdGhpcy50aXRsZSA/IGA8PCR7dGhpcy50aXRsZX0+PmAgOiAnJ1xuICAgIHJldHVybiBgJHt0aXRsZX0gJHt0aGlzLmNvbXBvc2VyIHx8ICcnfVxcbmBcbiAgfVxuXG4gIHRvSlNPTiA9IG1ha2VUb0pTT04oe1xuICAgIHRpdGxlOiB1bmRlZmluZWQsXG4gICAgc3VidGl0bGU6IHVuZGVmaW5lZCxcbiAgICBzdWJzdWJ0aXRsZTogdW5kZWZpbmVkLFxuICAgIGNvbXBvc2VyOiB1bmRlZmluZWQsXG4gICAgbHlyaWNpc3Q6IHVuZGVmaW5lZFxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBTY29yZUhlYWRcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2RlbC9TY29yZUhlYWQuanMiLCJpbXBvcnQgUGFydHdpc2VQYXJ0IGZyb20gJy4vUGFydHdpc2VQYXJ0J1xuXG5jbGFzcyBQYXJ0d2lzZVBhcnRzIGV4dGVuZHMgQXJyYXkge1xuICBjb25zdHJ1Y3RvcihzY29yZSkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9zY29yZSA9IHNjb3JlXG4gIH1cblxuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgc2NvcmUuXG4gICAqIEB0eXBlIHtTY29yZX1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgc2NvcmUoKSB7IHJldHVybiB0aGlzLl9zY29yZSB9XG5cbiAgLyoqXG4gICAqIEFkZCBwYXJ0cy5cbiAgICogQHBhcmFtIHtPYmplY3R9XG4gICAqL1xuICBhZGRQYXJ0cyhwYXJ0cykgeyBwYXJ0cy5mb3JFYWNoKHBhcnQgPT4geyB0aGlzLmFwcGVuZChwYXJ0KSB9KSB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBhIHBhcnR3aXNlIHBhcnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJ0IC0gUGxhaW4gcGFydHdpc2UgcGFydCBvYmplY3QuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgYXBwZW5kKHBhcnQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMubGVuZ3RoXG4gICAgY29uc3QgbXVzamVQYXJ0ID0gbmV3IFBhcnR3aXNlUGFydChpbmRleCwgdGhpcylcbiAgICB0aGlzLnB1c2gobXVzamVQYXJ0KVxuICAgIG11c2plUGFydC5tZWFzdXJlcyA9IHBhcnQubWVhc3VyZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIHBhcnRzLlxuICAgKi9cbiAgcmVtb3ZlQWxsKCkgeyB0aGlzLmxlbmd0aCA9IDAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQYXJ0d2lzZVBhcnRzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbW9kZWwvUGFydHdpc2VQYXJ0cy5qcyIsImltcG9ydCB7IG1ha2VUb0pTT04gfSBmcm9tICcuLi91dGlsJ1xuaW1wb3J0IENlbGwgZnJvbSAnLi9DZWxsJ1xuXG4vKipcbiAqIEBjbGFzc1xuICogQHBhcmFtIHBhcnQge09iamVjdH1cbiAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSAtIEluZGV4IG9mIHRoaXMgcGFydCBpbiB0aGUgcGFydHMuXG4gKiBAcGFyYW0gcGFydHMge1BhcnR3aXNlUGFydHN9XG4gKi9cbmNsYXNzIFBhcnR3aXNlUGFydCB7XG4gIGNvbnN0cnVjdG9yKGluZGV4LCBwYXJ0cykge1xuICAgIHRoaXMuX2luZGV4ID0gaW5kZXhcbiAgICB0aGlzLl9wYXJ0cyA9IHBhcnRzXG4gIH1cblxuICAvLyBoZWFkOiB7ICRyZWY6ICcjL29iamVjdHMvUGFydEhlYWQnIH0sXG5cbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byB0aGUgcGFyZW50IHBhcnRzIGluc3RhbmNlLlxuICAgKiBAdHlwZSB7UGFydHdpc2VQYXJ0c31cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcGFydHMoKSB7IHJldHVybiB0aGlzLl9wYXJ0cyB9XG5cbiAgLyoqXG4gICAqIE1lYXN1cmUgaW4gYSBwYXJ0d2lzZSBwYXJ0IGlzIGNlbGxzLlxuICAgKiBAdHlwZSB7QXJyYXkuPENlbGw+fVxuICAgKi9cbiAgZ2V0IG1lYXN1cmVzKCkgeyByZXR1cm4gdGhpcy5fbWVhc3VyZXMgfHwgKHRoaXMuX21lYXN1cmVzID0gW10pIH1cbiAgc2V0IG1lYXN1cmVzKG1lYXN1cmVzKSB7XG4gICAgY29uc3QgcCA9IHRoaXMuX2luZGV4XG4gICAgY29uc3QgeyBzY29yZSB9ID0gdGhpcy5wYXJ0c1xuICAgIGNvbnN0IG1lYSA9IHRoaXMuX21lYXN1cmVzID0gW11cbiAgICBtZWFzdXJlcy5mb3JFYWNoKChjZWxsLCBtKSA9PiB7IG1lYS5wdXNoKG5ldyBDZWxsKGNlbGwsIG0sIHAsIHNjb3JlKSkgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgcGFydHdpc2UgcGFydCB0byBzdGluZy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBNdXNqZSBwYXJ0d2lzZSBwYXJ0IHNvdXJjZSBjb2RlLlxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVhc3VyZXMubWFwKGNlbGwgPT4gY2VsbCkuam9pbignICcpXG4gIH1cblxuICAvKipcbiAgICogQ3VzdG9tIHRvSlNPTiBtZXRob2QuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHRvSlNPTiA9IG1ha2VUb0pTT04oe1xuICAgIG1lYXN1cmVzOiB1bmRlZmluZWRcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFydHdpc2VQYXJ0XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbW9kZWwvUGFydHdpc2VQYXJ0LmpzIiwiaW1wb3J0IHsgbWF0cml4IH0gZnJvbSAnc25hcHN2ZydcblxuaW1wb3J0IHRpbWUgZnJvbSAnLi9UaW1lJ1xuaW1wb3J0IGJhciAgZnJvbSAnLi9CYXInXG5pbXBvcnQgbm90ZSBmcm9tICcuL05vdGUnXG5pbXBvcnQgcmVzdCBmcm9tICcuL1Jlc3QnXG5pbXBvcnQgY2hvcmQgZnJvbSAnLi9DaG9yZCdcbmltcG9ydCB2b2ljZSBmcm9tICcuL1ZvaWNlJ1xuaW1wb3J0IEJlYW0gZnJvbSAnLi9CZWFtJ1xuXG5pbXBvcnQgeyBleHRlbmQsIG5lYXIsIG1ha2VUb0pTT04gfSBmcm9tICcuLi91dGlsJ1xuY29uc3QgQ2xhc3NlcyA9IHsgdGltZSwgYmFyLCBub3RlLCByZXN0LCBjaG9yZCwgdm9pY2UgfVxuY29uc3QgQmFyID0gYmFyXG5cbi8qKlxuICogQ2VsbCBpcyBlaXRoZXIgYSBtZWFzdXJlIGluIGEgcGFydHdpc2UgcGFydCwgb3JcbiAqIGEgcGFydCBpbiBhIHRpbWV3aXNlIG1lYXN1cmUuXG4gKiBAcGFyYW0gY2VsbCB7T2JqZWN0fVxuICogQHBhcmFtIG1JbmRleCB7bnVtYmVyfSAtIE1lYXN1cmUgaW5kZXggb2YgdGhpcyBjZWxsLlxuICogQHBhcmFtIHBJbmRleCB7bnVtYmVyfSAtIFBhcnQgaW5kZXggb2YgdGhpcyBjZWxsLlxuICovXG5jbGFzcyBDZWxsIHtcbiAgY29uc3RydWN0b3IoY2VsbCwgbUluZGV4LCBwSW5kZXgsIHNjb3JlKSB7XG4gICAgdGhpcy5fbUluZGV4ID0gbUluZGV4XG4gICAgdGhpcy5fcEluZGV4ID0gcEluZGV4XG4gICAgdGhpcy5fc2NvcmUgPSBzY29yZVxuICAgIGV4dGVuZCh0aGlzLCBjZWxsKVxuICAgIG1ha2VCZWFtcyh0aGlzLCAxKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byB0aGUgcm9vdCBzY29yZSBpbnN0YW5jZS5cbiAgICogQHR5cGUge1Njb3JlfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBzY29yZSgpIHsgcmV0dXJuIHRoaXMuX3Njb3JlIH1cblxuICAvKipcbiAgICogTXVzaWMgZGF0YVxuICAgKiBAdHlwZSB7QXJyYXkuPE11c2ljRGF0YU1peGluPn1cbiAgICovXG4gIGdldCBkYXRhKCkgeyByZXR1cm4gdGhpcy5fZGF0YSB8fCAodGhpcy5fZGF0YSA9IFtdKSB9XG4gIHNldCBkYXRhKGRhdGEpIHtcbiAgICB0aGlzLmxlbmd0aCA9IDBcbiAgICBkYXRhLmZvckVhY2goKGRhdHVtKSA9PiB7IHRoaXMuYXBwZW5kKGRhdHVtKSB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byB0aGUgcGFyZW50IG1lYXN1cmVzLlxuICAgKiBAdHlwZSB7VGltZXdpc2VNZWFzdXJlc31cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbWVhc3VyZXMoKSB7IHJldHVybiB0aGlzLnNjb3JlLm1lYXN1cmVzIH1cblxuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgbWVhc3VyZS5cbiAgICogQHR5cGUge1RpbWV3aXNlTWVhc3VyZX1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbWVhc3VyZSgpIHsgcmV0dXJuIHRoaXMubWVhc3VyZXNbdGhpcy5fbUluZGV4XSB9XG5cbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byB0aGUgcGFyZW50IHBhcnRzLlxuICAgKiBAdHlwZSB7UGFydHdpc2VQYXJ0c31cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcGFydHMoKSB7IHJldHVybiB0aGlzLnNjb3JlLnBhcnRzIH1cblxuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgcGFydC5cbiAgICogQHR5cGUge1BhcnR3aXNlUGFydH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcGFydCgpIHsgcmV0dXJuIHRoaXMucGFydHNbdGhpcy5fcEluZGV4XSB9XG5cbiAgLyoqXG4gICAqIFByZXZpb3VzIGNlbGwgaW4gdGhlIHBhcnQuXG4gICAqIEB0eXBlIHtDZWxsfHVuZGVmaW5lZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcHJldigpIHsgcmV0dXJuIHRoaXMucGFydC5tZWFzdXJlc1t0aGlzLl9tSW5kZXggLSAxXSB9XG5cbiAgLyoqXG4gICAqIE5leHQgY2VsbCBpbiB0aGUgcGFydC5cbiAgICogQHR5cGUge0NlbGx8dW5kZWZpbmVkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBuZXh0KCkgeyByZXR1cm4gdGhpcy5wYXJ0Lm1lYXN1cmVzW3RoaXMuX21JbmRleCArIDFdIH1cblxuICAvKipcbiAgICogVGhlIGZpcnN0IG11c2ljIGRhdGEgaW4gdGhlIGNlbGwuXG4gICAqIEB0eXBlIHtNdXNpY0RhdGFNaXhpbnx1bmRlZmluZWR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGZpcnN0RGF0YSgpIHsgcmV0dXJuIHRoaXMuZGF0YVswXSB9XG5cbiAgLyoqXG4gICAqIFRoZSBsYXN0IG11c2ljIGRhdGEgaW4gdGhlIGNlbGwuXG4gICAqIEB0eXBlIHtNdXNpY0RhdGFNaXhpbnx1bmRlZmluZWR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGxhc3REYXRhKCkgeyByZXR1cm4gdGhpcy5kYXRhW3RoaXMuZGF0YS5sZW5ndGggLSAxXSB9XG5cbiAgLyoqXG4gICAqIFRoZSBsZWZ0IGJhciBvZiB0aGlzIGNlbGwuXG4gICAqIEB0eXBlIHtCYXJ8dW5kZWZpbmVkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBiYXJMZWZ0KCkge1xuICAgIGNvbnN0IHsgZmlyc3REYXRhIH0gPSB0aGlzXG4gICAgaWYgKGZpcnN0RGF0YSAmJiBmaXJzdERhdGEuJHR5cGUgPT09ICdiYXInKSByZXR1cm4gZmlyc3REYXRhXG5cbiAgICAvLyBUYWtlIGZyb20gdGhlIHByZXZpb3VzIG1lYXN1cmUuXG4gICAgY29uc3QgcHJldkNlbGwgPSB0aGlzLnByZXZcbiAgICBpZiAocHJldkNlbGwpIHJldHVybiBwcmV2Q2VsbC5iYXJSaWdodFxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSByaWdodCBiYXIgb2YgdGhpcyBjZWxsLlxuICAgKiBAdHlwZSB7QmFyfHVuZGVmaW5lZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgYmFyUmlnaHQoKSB7XG4gICAgY29uc3QgeyBsYXN0RGF0YSB9ID0gdGhpc1xuICAgIGlmIChsYXN0RGF0YSAmJiBsYXN0RGF0YS4kdHlwZSA9PT0gJ2JhcicpIHJldHVybiBsYXN0RGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBhIG11c2ljIGRhdGEgdG8gdGhlIGNlbGwuXG4gICAqIEBwYXJhbSAge09iamVjdH0gbXVzaWNEYXRhIC0gTXVzaWMgZGF0YVxuICAgKi9cbiAgYXBwZW5kKG11c2ljRGF0YSkge1xuICAgIGNvbnN0IHR5cGUgPSBPYmplY3Qua2V5cyhtdXNpY0RhdGEpWzBdIC8vIG11c2ljRGF0YSBoYXMgb25seSBvbmUga2V5XG4gICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgQ2xhc3Nlc1t0eXBlXShtdXNpY0RhdGFbdHlwZV0pXG4gICAgaW5zdGFuY2UuX2NlbGwgPSB0aGlzXG4gICAgaW5zdGFuY2UuX2luZGV4ID0gdGhpcy5kYXRhLmxlbmd0aFxuICAgIHRoaXMuZGF0YS5wdXNoKGluc3RhbmNlKVxuICB9XG5cblxuICAvKipcbiAgICogV2lkdGhcbiAgICogLSAoR2V0dGVyKSBHZXQgdGhlIGNlbGwgd2lkdGguXG4gICAqIC0gKFNldHRlcikgU2V0IHRoZSBjZWxsIHdpZHRoLCBhbmQgdGhpcyB3aWxsIGNhdXNlIHRoZSBjZWxsIHRvIHJlZmxvdy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3aWR0aCgpIHsgcmV0dXJuIHRoaXMuX3cgfVxuICBzZXQgd2lkdGgodykge1xuICAgIHRoaXMuX3cgPSB3XG4gICAgcmVmbG93KHRoaXMpXG4gIH1cblxuICBnZXQgaGVpZ2h0KCkgeyByZXR1cm4gdGhpcy5sYXlvdXQub3B0aW9ucy5wYXJ0SGVpZ2h0IH1cblxuICAvKipcbiAgICogVGhlIHggcG9zaXRpb24gb2YgdGhlIGNlbGwgaW4gcGFyZW50IHRpbWV3aXNlIG1lYXN1cmUuXG4gICAqIC0gU2V0IHRoZSB4IHZhbHVlIHdpbGwgY2F1c2UgdGhlIGNlbGwgZWxlbWVudCB0cmFuc2xhdGUuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgeCgpIHsgcmV0dXJuIHRoaXMuX3ggfVxuICBzZXQgeCh4KSB7XG4gICAgdGhpcy5feCA9IHhcbiAgICB0aGlzLmVsLnRyYW5zZm9ybShtYXRyaXgoKS50cmFuc2xhdGUoeCwgdGhpcy55MikpXG4gIH1cblxuICAvKipcbiAgICogVGhlIHkyIHBvc2l0aW9uIG9mIHRoZSBjZWxsIGluIHBhcmVudCB0aW1ld2lzZSBtZWFzdXJlLlxuICAgKiAtIFNldCB0aGUgeTIgdmFsdWUgd2lsbCBjYXVzZSB0aGUgY2VsbCBlbGVtZW50IHRyYW5zbGF0ZS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB5MigpIHtcbiAgICBjb25zdCB7IHBhcnRIZWlnaHQsIHBhcnRTZXAgfSA9IHRoaXMubGF5b3V0Lm9wdGlvbnNcbiAgICBjb25zdCBwID0gdGhpcy5fcEluZGV4XG5cbiAgICByZXR1cm4gcCA/IChwICsgMSkgKiBwYXJ0SGVpZ2h0ICsgcCAqIHBhcnRTZXAgOiBwYXJ0SGVpZ2h0XG4gIH1cblxuICAvKipcbiAgICogVGhlIGxlZnQgYmFyIG9mIHRoaXMgY2VsbC5cbiAgICogLSBiYXJMZWZ0IGF0IGZpcnN0IG1lYXN1cmUgb2YgYSBzeXN0ZW06XG4gICAqIGBgYFxuICAgKiB8XSAgLT4gfFxuICAgKiA6fCAgLT4gfFxuICAgKiA6fDogLT4gfDpcbiAgICogYGBgXG4gICAqIEB0eXBlIHtCYXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGJhckxlZnRJblN5c3RlbSgpIHtcbiAgICBsZXQgYmFyID0gdGhpcy5iYXJMZWZ0XG4gICAgaWYgKCFiYXIpIHJldHVybiB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfVxuXG4gICAgLy8gRmlyc3QgbWVhc3VyZSBpbiB0aGUgc3lzdGVtLlxuICAgIGlmICh0aGlzLm1lYXN1cmUuaW5TeXN0ZW1CZWdpbikge1xuICAgICAgaWYgKGJhci52YWx1ZSA9PT0gJ2VuZCcgfHwgYmFyLnZhbHVlID09PSAncmVwZWF0LWVuZCcpIHtcbiAgICAgICAgYmFyID0gbmV3IEJhcignc2luZ2xlJylcbiAgICAgIH0gZWxzZSBpZiAoYmFyLnZhbHVlID09PSAncmVwZWF0LWJvdGgnKSB7XG4gICAgICAgIGJhciA9IG5ldyBCYXIoJ3JlcGVhdC1iZWdpbicpXG4gICAgICB9XG4gICAgfVxuICAgIGJhci5kZWYgPSB0aGlzLmxheW91dC5kZWZzLmdldChiYXIpXG4gICAgcmV0dXJuIGJhclxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSByaWdodCBiYXIgb2YgdGhpcyBjZWxsLlxuICAgKiAtIGJhclJpZ2h0IGF0IGxhc3QgbWVhc3VyZSBvZiBhIHN5c3RlbTpcbiAgICogYGBgXG4gICAqICB8OiAtPiAgfFxuICAgKiA6fDogLT4gOnxcbiAgICogYGBgXG4gICAqIEB0eXBlIHttdXNqZS5CYXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGJhclJpZ2h0SW5TeXN0ZW0oKSB7XG4gICAgY29uc3QgeyBzeXN0ZW0gfSA9IHRoaXMubWVhc3VyZVxuICAgIGxldCBiYXIgPSB0aGlzLmJhclJpZ2h0XG5cbiAgICBpZiAoIWJhcikgcmV0dXJuIHsgd2lkdGg6IDAsIGhlaWdodDogMCB9XG5cbiAgICAvLyBMYXN0IG1lYXN1cmUgaW4gdGhlIHN5c3RlbS5cbiAgICBpZiAoc3lzdGVtICYmIHRoaXMubWVhc3VyZS5pblN5c3RlbUVuZCkge1xuICAgICAgaWYgKGJhci52YWx1ZSA9PT0gJ3JlcGVhdC1iZWdpbicpIHtcbiAgICAgICAgYmFyID0gbmV3IEJhcignc2luZ2xlJylcbiAgICAgIH0gZWxzZSBpZiAoYmFyLnZhbHVlID09PSAncmVwZWF0LWJvdGgnKSB7XG4gICAgICAgIGJhciA9IG5ldyBCYXIoJ3JlcGVhdC1lbmQnKVxuICAgICAgfVxuICAgIH1cbiAgICBiYXIuZGVmID0gdGhpcy5sYXlvdXQuZGVmcy5nZXQoYmFyKVxuICAgIHJldHVybiBiYXJcbiAgfVxuXG4gIC8qKlxuICAgKiBGbG93IHRoZSBjZWxsLlxuICAgKi9cbiAgZmxvdygpIHtcbiAgICBjb25zdCB7IGRlZnMsIG9wdGlvbnMgfSA9IHRoaXMubGF5b3V0XG4gICAgY29uc3QgeyBtdXNpY0RhdGFTZXAgfSA9IG9wdGlvbnNcbiAgICBsZXQgeCA9IDBcbiAgICBsZXQgbWluSGVpZ2h0XG5cbiAgICB0aGlzLmRhdGEuZm9yRWFjaChkYXRhID0+IHtcbiAgICAgIGNvbnN0IGRlZiA9IGRhdGEuZGVmID0gZGVmcy5nZXQoZGF0YSlcbiAgICAgIGRhdGEueCA9IHhcbiAgICAgIGRhdGEueSA9IDBcbiAgICAgIHggKz0gZGVmLndpZHRoICsgbXVzaWNEYXRhU2VwXG4gICAgICBtaW5IZWlnaHQgPSBNYXRoLm1pbihtaW5IZWlnaHQsIGRlZi5oZWlnaHQpXG4gICAgfSlcblxuICAgIHRoaXMubWluV2lkdGggPSB4XG4gICAgdGhpcy5taW5IZWlnaHQgPSBtaW5IZWlnaHRcbiAgfVxuXG4gIC8qKlxuICAgKiBEcmF3IGJveCBvZiB0aGUgY2VsbC5cbiAgICogQHJldHVybiB7RWxlbWVudH0gVGhlIGJveCBTVkcgcmVjdCBlbGVtZW50LlxuICAgKi9cbiAgZHJhd0JveCgpIHtcbiAgICB0aGlzLl9ib3hFbCA9IHRoaXMuZWwucmVjdCgwLCAtdGhpcy5oZWlnaHQsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnYmJveCcpXG4gICAgcmV0dXJuIHRoaXMuX2JveEVsXG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgdGhlIGJveCBTVkcgZWxlbWVudC5cbiAgICovXG4gIGNsZWFyQm94KCkge1xuICAgIHRoaXMuX2JveEVsLnJlbW92ZSgpXG4gICAgdGhpcy5fYm94RWwgPSB1bmRlZmluZWRcbiAgfVxuXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgY2VsbCB0byBzdHJpbmcuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29udmVydGVkIGNlbGwgaW4gbXVzamUgc291cmNlIGNvZGUuXG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLm1hcChtdXNpY0RhdGEgPT4gbXVzaWNEYXRhLnRvU3RyaW5nKCkpLmpvaW4oJyAnKVxuICB9XG5cbiAgdG9KU09OID0gbWFrZVRvSlNPTih7XG4gICAgZGF0YTogdW5kZWZpbmVkXG4gIH0pXG59XG5cbi8vIFJlZmxvdyB0aGUgY2VsbC5cbmZ1bmN0aW9uIHJlZmxvdyh0aGF0KSB7XG4gIHRoYXQuZGF0YS5mb3JFYWNoKGRhdGEgPT4geyBkYXRhLnggKj0gdGhhdC53aWR0aCAvIHRoYXQubWluV2lkdGggfSlcbn1cblxuXG4vKipcbiAqIE1ha2UgYmVhbXMgYXV0b21hdGljYWxseSBpbiBncm91cCBieSB0aGUgZ3JvdXBEdXIuXG4gKiBAcGFyYW0ge251bWJlcn0gZ3JvdXBEdXIgLSBEdXJhdGlvbiBvZiBhIGJlYW0gZ3JvdXAgaW4gcXVhcnRlci5cbiAqL1xuZnVuY3Rpb24gbWFrZUJlYW1zKHRoYXQsIGdyb3VwRHVyKSB7XG5cbiAgZ2V0QmVhbUdyb3Vwcyh0aGF0LCBncm91cER1cikuZm9yRWFjaChncm91cCA9PiB7XG4gICAgY29uc3QgYmVhbUxldmVsID0ge30gICAvLyBpdCBzdGFydHMgZnJvbSAwLCB3aGlsZSB1bmRlcmJhciBzdGFydHMgZnJvbSAxXG5cbiAgICBjb25zdCBuZXh0SGFzU2FtZUJlYW1sZXZlbCA9IChpbmRleCwgbGV2ZWwpID0+IHtcbiAgICAgIGNvbnN0IG5leHQgPSBncm91cFtpbmRleCArIDFdXG4gICAgICByZXR1cm4gbmV4dCAmJiBuZXh0LmR1cmF0aW9uLnVuZGVyYmFyID4gbGV2ZWxcbiAgICB9XG5cbiAgICBncm91cC5mb3JFYWNoKChkYXRhLCBpKSA9PiB7XG4gICAgICBjb25zdCB7IHVuZGVyYmFyIH0gPSBkYXRhLmR1cmF0aW9uXG5cbiAgICAgIGZvciAobGV0IGxldmVsID0gMDsgbGV2ZWwgPCB1bmRlcmJhcjsgbGV2ZWwrKykge1xuICAgICAgICBpZiAobmV4dEhhc1NhbWVCZWFtbGV2ZWwoaSwgbGV2ZWwpKSB7XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBCZWFtcyBvZiB0aGUgbm90ZS5cbiAgICAgICAgICAgKiAtIFByb2R1Y2VkIGJ5IHRoZSB7QGxpbmsgQ2VsbCNtYWtlQmVhbXN9IG1ldGhvZC5cbiAgICAgICAgICAgKiAtIFRoZSBhYm92ZSBtZXRob2QgaXMgY2FsbCBpbiB7QGxpbmsgU2NvcmUjcHJlcGFyZUNlbGxzfS5cbiAgICAgICAgICAgKiBAbWVtYmVyb2YgTm90ZSNcbiAgICAgICAgICAgKiBAYWxpYXMgYmVhbXNcbiAgICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPEJlYW0+fVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGRhdGEuYmVhbXMgPSBkYXRhLmJlYW1zIHx8IFtdXG5cbiAgICAgICAgICBpZiAoYmVhbUxldmVsW2xldmVsXSkge1xuICAgICAgICAgICAgZGF0YS5iZWFtc1tsZXZlbF0gPSBuZXcgQmVhbSgnY29udGludWUnLCBsZXZlbCwgZGF0YSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmVhbUxldmVsW2xldmVsXSA9IHRydWU7XG4gICAgICAgICAgICBkYXRhLmJlYW1zW2xldmVsXSA9IG5ldyBCZWFtKCdiZWdpbicsIGxldmVsLCBkYXRhKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoYmVhbUxldmVsW2xldmVsXSkge1xuICAgICAgICAgICAgZGF0YS5iZWFtcyA9IGRhdGEuYmVhbXMgfHwgW107XG4gICAgICAgICAgICBkYXRhLmJlYW1zW2xldmVsXSA9IG5ldyBCZWFtKCdlbmQnLCBsZXZlbCwgZGF0YSlcbiAgICAgICAgICAgIGRlbGV0ZSBiZWFtTGV2ZWxbbGV2ZWxdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGdldEJlYW1Hcm91cHModGhhdCwgZ3JvdXBEdXIpIHtcbiAgY29uc3QgZ3JvdXBzID0gW11cbiAgbGV0IGdyb3VwID0gW11cbiAgbGV0IGNvdW50ZXIgPSAwXG5cbiAgY29uc3QgaW5Hcm91cCA9ICgpID0+IGNvdW50ZXIgPCBncm91cER1ciAmJiAhbmVhcihjb3VudGVyLCBncm91cER1cilcbiAgY29uc3QgcHV0R3JvdXAgPSAoKSA9PiB7XG4gICAgaWYgKGdyb3VwLmxlbmd0aCA+IDEpIGdyb3Vwcy5wdXNoKGdyb3VwKVxuICAgIGdyb3VwID0gW11cbiAgfVxuXG4gIHRoYXQuZGF0YS5mb3JFYWNoKG11c2ljRGF0YSA9PiB7XG4gICAgaWYgKG11c2ljRGF0YS4kdHlwZSAhPT0gJ25vdGUnICYmIG11c2ljRGF0YS4kdHlwZSAhPT0gJ3Jlc3QnKSByZXR1cm5cblxuICAgIGNvbnN0IHsgZHVyYXRpb24gfSA9IG11c2ljRGF0YVxuICAgIGNvbnN0IGR1ciA9IGR1cmF0aW9uLnF1YXJ0ZXJcblxuICAgIGNvdW50ZXIgKz0gZHVyXG5cbiAgICBpZiAoaW5Hcm91cCgpKSB7XG4gICAgICBpZiAoZHVyYXRpb24udW5kZXJiYXIpIGdyb3VwLnB1c2gobXVzaWNEYXRhKVxuICAgIH0gZWxzZSBpZiAobmVhcihjb3VudGVyLCBncm91cER1cikpIHtcbiAgICAgIGdyb3VwLnB1c2gobXVzaWNEYXRhKVxuICAgICAgcHV0R3JvdXAoKVxuICAgICAgY291bnRlciA9IDBcbiAgICB9IGVsc2Uge1xuICAgICAgcHV0R3JvdXAoKVxuICAgICAgY291bnRlciAlPSBncm91cER1clxuICAgIH1cbiAgfSlcblxuICBwdXRHcm91cCgpXG5cbiAgcmV0dXJuIGdyb3Vwc1xufVxuXG5leHBvcnQgZGVmYXVsdCBDZWxsXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbW9kZWwvQ2VsbC5qcyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV84X187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwge1wicm9vdFwiOlwiU25hcFwiLFwiY29tbW9uanMyXCI6XCJzbmFwc3ZnXCIsXCJjb21tb25qc1wiOlwic25hcHN2Z1wiLFwiYW1kXCI6XCJzbmFwc3ZnXCJ9XG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IGV4dGVuZCwgbWFrZVRvSlNPTiB9IGZyb20gJy4uL3V0aWwnXG5pbXBvcnQgTXVzaWNEYXRhIGZyb20gJy4vTXVzaWNEYXRhJ1xuXG4vKipcbiAqIFRpbWUgc2lnbmF0dXJlLlxuICogQGNsYXNzXG4gKiBAcGFyYW0gdGltZSB7T2JqZWN0fVxuICogQG1peGVzIE11c2ljRGF0YU1peGluXG4gKiBAbWl4ZXMgTXVzaWNEYXRhTGF5b3V0TWl4aW5cbiAqL1xuY2xhc3MgVGltZSBleHRlbmRzIE11c2ljRGF0YSB7XG4gIGNvbnN0cnVjdG9yKHRpbWUpIHtcbiAgICBzdXBlcigpXG4gICAgZXh0ZW5kKHRoaXMsIHRpbWUpXG4gIH1cblxuICAvKipcbiAgICogVHlwZSBvZiB0aW1lLlxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHQgdGltZVxuICAgKi9cbiAgJHR5cGUgPSAndGltZSdcblxuICAvKipcbiAgICogSG93IG1hbnkgYmVhdHMgcGVyIG1lYXN1cmUuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBiZWF0cyA9IDRcblxuICAvKipcbiAgICogQmVhdCB0eXBlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBiZWF0VHlwZSA9IDRcblxuICAvKipcbiAgICogRGVmIGlkIHVzZWQgaW4gdGhlIFNWRyA8ZGVmcz4gZWxlbWVudC5cbiAgICogYGBgXG4gICAqIGlkIDo9ICd0JyBiZWF0cyAnLScgYmVhdFR5cGVcbiAgICogYGBgXG4gICAqIEUuZy4gYHQzLTRgXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGRlZklkKCkgeyByZXR1cm4gYHQke3RoaXMuYmVhdHN9LSR7dGhpcy5iZWF0VHlwZX1gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0byBtdXNqZSBzb3VyY2UgY29kZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBNdXNqZSBzb3VyY2UgY29kZS5cbiAgICovXG4gIHRvU3RyaW5nKCkgeyByZXR1cm4gYCR7dGhpcy5iZWF0c30vJHt0aGlzLmJlYXRUeXBlfWAgfVxuXG4gIHRvSlNPTiA9IG1ha2VUb0pTT04oe1xuICAgIGJlYXRzOiA0LFxuICAgIGJlYXRUeXBlOiA0XG4gIH0sICd0aW1lJylcbn1cblxuZXhwb3J0IGRlZmF1bHQgVGltZVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21vZGVsL1RpbWUuanMiLCJjbGFzcyBNdXNpY0RhdGEge1xuXG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBjZWxsLlxuICAgKiBAdHlwZSB7Q2VsbH1cbiAgICovXG4gIGdldCBjZWxsKCkgeyByZXR1cm4gdGhpcy5fY2VsbCB9XG5cbiAgLyoqXG4gICAqIFRoZSBhc2NlbmRhbnQgc3lzdGVtIG9mIHRoZSBtdXNpYyBkYXRhLlxuICAgKiBAdHlwZSB7U3lzdGVtTGF5b3V0fVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBzeXN0ZW0oKSB7IHJldHVybiB0aGlzLmNlbGwubWVhc3VyZS5zeXN0ZW0gfVxuXG4gIC8qKlxuICAgKiBQcmV2aW91cyBtdXNpYyBkYXRhLlxuICAgKiBAdHlwZSB7TXVzaWNEYXRhTWl4aW58dW5kZWZpbmVkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBwcmV2KCkgeyByZXR1cm4gdGhpcy5jZWxsLmRhdGFbdGhpcy5faW5kZXggLSAxXSB9XG5cbiAgLyoqXG4gICAqIE5leHQgbXVzaWMgZGF0YS5cbiAgICogQHR5cGUge011c2ljRGF0YU1peGlufHVuZGVmaW5lZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbmV4dCgpIHsgcmV0dXJuIHRoaXMuY2VsbC5kYXRhW3RoaXMuX2luZGV4ICsgMV0gfVxuXG4gIC8qKlxuICAgKiBQcmV2aW91cyBtdXNpYyBkYXRhIGluIHBhcnQsIGFjcm9zcyBtZWFzdXJlLlxuICAgKiBAdHlwZSB7TXVzaWNEYXRhTWl4aW58dW5kZWZpbmVkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBwcmV2SW5QYXJ0KCkge1xuICAgIGxldCB7IHByZXYsIGNlbGwgfSA9IHRoaXNcbiAgICB3aGlsZSAoIXByZXYgJiYgY2VsbC5wcmV2KSB7XG4gICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgY2VsbCA9IGNlbGwucHJldlxuICAgICAgICBwcmV2ID0gY2VsbC5sYXN0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJldlxuICB9XG5cbiAgLyoqXG4gICAqIE5leHQgbXVzaWMgZGF0YSBpbiBwYXJ0LCBhY3Jvc3MgbWVhc3VyZS5cbiAgICogQHR5cGUge011c2ljRGF0YU1peGlufHVuZGVmaW5lZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbmV4dEluUGFydCgpIHtcbiAgICBsZXQgeyBuZXh0LCBjZWxsIH0gPSB0aGlzXG4gICAgd2hpbGUgKCFuZXh0ICYmIGNlbGwubmV4dCkge1xuICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgIGNlbGwgPSBjZWxsLm5leHRcbiAgICAgICAgbmV4dCA9IGNlbGwuZmlyc3REYXRhXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXh0XG4gIH1cblxuICAvKipcbiAgICogUHJldmlvdXMgbXVzaWMgZGF0YSB3aGljaCBoYXMgYSBkdXJhdGlvbi5cbiAgICogQHR5cGUge011c2ljRGF0YU1peGlufHVuZGVmaW5lZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcHJldkR1cmFibGUoKSB7XG4gICAgbGV0IHsgcHJldiB9ID0gdGhpc1xuICAgIHdoaWxlIChwcmV2ICYmICFwcmV2LmR1cmF0aW9uKSBwcmV2ID0gcHJldi5wcmV2XG4gICAgcmV0dXJuIHByZXZcbiAgfVxuXG4gIC8qKlxuICAgKiBOZXh0IG11c2ljIGRhdGEgd2hpY2ggaGFzIGEgZHVyYXRpb24uXG4gICAqIEB0eXBlIHtNdXNpY0RhdGFNaXhpbnx1bmRlZmluZWR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG5leHREdXJhYmxlKCkge1xuICAgIGxldCB7IG5leHQgfSA9IHRoaXNcbiAgICB3aGlsZSAobmV4dCAmJiAhbmV4dC5kdXJhdGlvbikgbmV4dCA9IG5leHQubmV4dFxuICAgIHJldHVybiBuZXh0XG4gIH1cblxuICAvKipcbiAgICogUHJldmlvdXMgbXVzaWMgZGF0YSB3aGljaCBoYXMgYSBkdXJhdGlvbiBpbiBwYXJ0LCBhY3Jvc3MgbWVhc3VyZS5cbiAgICogQHR5cGUge011c2ljRGF0YU1peGlufHVuZGVmaW5lZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcHJldkR1cmFibGVJblBhcnQoKSB7XG4gICAgbGV0IHByZXYgPSB0aGlzLnByZXZJblBhcnRcbiAgICB3aGlsZSAocHJldiAmJiAhcHJldi5kdXJhdGlvbikgcHJldiA9IHByZXYucHJldkluUGFydFxuICAgIHJldHVybiBwcmV2XG4gIH1cblxuICAvKipcbiAgICogTmV4dCBtdXNpYyBkYXRhIHdoaWNoIGhhcyBhIGR1cmF0aW9uIGluIHBhcnQsIGFjcm9zcyBtZWFzdXJlLlxuICAgKiBAdHlwZSB7TXVzaWNEYXRhTWl4aW58dW5kZWZpbmVkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBuZXh0RHVyYWJsZUluUGFydCgpIHtcbiAgICBsZXQgbmV4dCA9IHRoaXMubmV4dEluUGFydFxuICAgIHdoaWxlIChuZXh0ICYmICFuZXh0LmR1cmF0aW9uKSBuZXh0ID0gbmV4dC5uZXh0SW5QYXJ0XG4gICAgcmV0dXJuIG5leHRcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBtdXNpYyBkYXRhIGluIHRoZSBjZWxsLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHgoKSB7IHJldHVybiB0aGlzLl94IH1cbiAgc2V0IHgoeCkge1xuICAgIHRoaXMuX3ggPSB4XG4gICAgaWYgKHRoaXMuZWwpIHRoaXMuZWwuYXR0cigneCcsIHgpXG4gIH1cblxuICAvKipcbiAgICogVGhlIHkgcG9zaXRpb24gb2YgdGhlIG11c2ljIGRhdGEgaW4gdGhlIGNlbGwuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgeSgpIHsgcmV0dXJuIHRoaXMuX3kgfVxuICBzZXQgeSh5KSB7XG4gICAgdGhpcy5feSA9IHlcbiAgICBpZiAodGhpcy5lbCkgdGhpcy5lbC5hdHRyKCd5JywgeSlcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgbXVzaWMgZGF0YSBpbiB0aGUgc3lzdGVtLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHN5c3RlbVgoKSB7IHJldHVybiB0aGlzLnggKyB0aGlzLmNlbGwueCArIHRoaXMuY2VsbC5tZWFzdXJlLnggfVxuXG4gIC8qKlxuICAgKiBUaGUgd2lkdGggb2YgdGhlIG11c2ljIGRhdGEuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHdpZHRoKCkgeyByZXR1cm4gdGhpcy5kZWYud2lkdGggfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNdXNpY0RhdGFcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2RlbC9NdXNpY0RhdGEuanMiLCJpbXBvcnQgTXVzaWNEYXRhIGZyb20gJy4vTXVzaWNEYXRhJ1xuXG5jb25zdCBCQVJfVE9fU1RSSU5HID0ge1xuICBzaW5nbGU6ICd8JywgZG91YmxlOiAnfHwnLCBlbmQ6ICd8XScsXG4gICdyZXBlYXQtYmVnaW4nOiAnfDonLCAncmVwZWF0LWVuZCc6ICc6fCcsICdyZXBlYXQtYm90aCc6ICc6fDonXG59XG5jb25zdCBCQVJfVE9fSUQgPSB7XG4gIHNpbmdsZTogJ2JzJywgZG91YmxlOiAnYmQnLCBlbmQ6ICdiZScsXG4gICdyZXBlYXQtYmVnaW4nOiAnYnJiJywgJ3JlcGVhdC1lbmQnOiAnYnJlJywgJ3JlcGVhdC1ib3RoJzogJ2JyYmUnXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhciAtIFRoZSBiYXIgdmFsdWUsIHdoaWNoIGNhbiBiZSBlaXRoZXIgb2ZcbiAqIC0gJ3NpbmdsZScgLSBgfGBcbiAqIC0gJ2RvdWJsZScgLSBgfHxgXG4gKiAtICdlbmQnIC0gYHxdYFxuICogLSAncmVwZWF0LWJlZ2luJyAtIGB8OmBcbiAqIC0gJ3JlcGVhdC1lbmQnIC0gYDp8YFxuICogLSAncmVwZWF0LWJvdGgnIC0gYDp8OmBcbiAqL1xuY2xhc3MgQmFyIGV4dGVuZHMgTXVzaWNEYXRhIHtcbiAgY29uc3RydWN0b3IoYmFyKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX3ZhbHVlID0gYmFyXG4gIH1cblxuICAvKipcbiAgICogVHlwZSBvZiBiYXIuXG4gICAqIEBjb25zdGFudFxuICAgKiBAcmVhZG9ubHlcbiAgICogQGRlZmF1bHQgYmFyXG4gICAqL1xuICAkdHlwZSA9ICdiYXInXG5cbiAgLyoqXG4gICAqIFZhbHVlIG9mIHRoZSBiYXIsIHdoaWNoIGlzIHRoZSBzYW1lIGFzIHRoZSBiYXIgcGFyYW1ldGVyIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgc2luZ2xlXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHZhbHVlKCkgeyByZXR1cm4gdGhpcy5fdmFsdWUgfHwgKHRoaXMuX3ZhbHVlID0gJ3NpbmdsZScpIH1cblxuICAvKipcbiAgICogRGVmIGlkIHVzZWQgaW4gdGhlIFNWRyA8ZGVmcz4gZWxlbWVudC5cbiAgICogYGBgXG4gICAqIGRlZklkICAgIEJhciB2YWx1ZVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqICdicycgICAtIHNpbmdsZVxuICAgKiAnYmQnICAgLSBkb3VibGVcbiAgICogJ2JlJyAgIC0gcmVwZWF0LWVuZFxuICAgKiAnYnJiJyAgLSByZXBlYXQtYmVnaW5cbiAgICogJ2JyZScgIC0gcmVwZWF0LWVuZFxuICAgKiAnYnJiZScgLSByZXBlYXQtYm90aFxuICAgKiBgYGBcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZGVmSWQoKSB7IHJldHVybiBCQVJfVE9fSURbdGhpcy52YWx1ZV0gfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGJhciB0byBzdHJpbmcuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29udmVydGVkIHN0cmluZyBvZiB0aGUgYmFybGluZSBpbiBtdXNqZSBzb3VyY2UgY29kZS5cbiAgICovXG4gIHRvU3RyaW5nKCkgeyByZXR1cm4gQkFSX1RPX1NUUklOR1t0aGlzLnZhbHVlXSB9XG5cbiAgLyoqXG4gICAqIFt0b0pTT04gZGVzY3JpcHRpb25dXG4gICAqIEByZXR1cm4ge09iamVjdH0geyBiYXI6IHZhbHVlIH1cbiAgICovXG4gIHRvSlNPTigpIHsgcmV0dXJuIHsgYmFyOiB0aGlzLnZhbHVlIH0gfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2RlbC9CYXIuanMiLCJpbXBvcnQgeyBleHRlbmQsIG1ha2VUb0pTT04gfSBmcm9tICcuLi91dGlsJ1xuaW1wb3J0IE11c2ljRGF0YSBmcm9tICcuL011c2ljRGF0YSdcbmltcG9ydCBQaXRjaCBmcm9tJy4vUGl0Y2gnXG5pbXBvcnQgRHVyYXRpb24gZnJvbSAnLi9EdXJhdGlvbidcbmltcG9ydCBUaWUgZnJvbSAnLi9UaWUnXG5pbXBvcnQgU2x1ciBmcm9tICcuL1NsdXInXG5cbi8qKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge09iamVjdH0gbm90ZVxuICogQG1peGVzIE11c2ljRGF0YU1peGluXG4gKiBAbWl4ZXMgTXVzaWNEYXRhTGF5b3V0TWl4aW5cbiAqL1xuY2xhc3MgTm90ZSBleHRlbmRzIE11c2ljRGF0YSB7XG4gIGNvbnN0cnVjdG9yKG5vdGUpIHtcbiAgICBzdXBlcigpXG4gICAgZXh0ZW5kKHRoaXMsIG5vdGUpXG4gIH1cblxuICAvKipcbiAgICogVHlwZSBvZiBub3RlLlxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHQgbm90ZVxuICAgKi9cbiAgJHR5cGUgPSAnbm90ZSdcblxuICAvKipcbiAgICogVW5pcXVlIGRlZiBpZCBvZiB0aGUgbm90ZSB1c2VkIGluIHRoZSBTVkcgPGRlZnM+IGVsZW1lbnQuXG4gICAqIGBgYFxuICAgKiBkZWZJZCA6PSAnbicgYWNjaWRlbnRhbCBzdGVwIG9jdGF2ZSB0eXBlIGRvdFxuICAgKiBgYGBcbiAgICogRS5nLlxuICAgKiBgYGBcbiAgICogTm90ZSAgICAgZGVmSWRcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIDEgICAgICAgIG4xMDQwXG4gICAqIGIzLSAgICAgIG5iMzAyMFxuICAgKiAjNSdfLiAgICBuczUxODFcbiAgICogNiwsICAgICAgbjYtMlxuICAgKiBgYGBcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZGVmSWQoKSB7XG4gICAgY29uc3QgeyBhY2NpZGVudGFsLCBzdGVwLCBvY3RhdmUgfSA9IHRoaXMucGl0Y2hcbiAgICBjb25zdCB7IHR5cGUsIGRvdCB9ID0gdGhpcy5kdXJhdGlvblxuICAgIHJldHVybiBgbiR7YWNjaWRlbnRhbC5yZXBsYWNlKC8jL2csICdzJyl9JHtzdGVwfSR7b2N0YXZlfSR7dHlwZX0ke2RvdH1gXG4gIH1cblxuICAvKipcbiAgICogUGl0Y2ggb2YgdGhlIG5vdGUuXG4gICAqIEB0eXBlIHttdXNqZS5QaXRjaH1cbiAgICovXG4gIGdldCBwaXRjaCgpIHsgcmV0dXJuIHRoaXMuX3BpdGNoIHx8ICh0aGlzLl9waXRjaCA9IG5ldyBQaXRjaCh0aGlzKSkgfVxuICBzZXQgcGl0Y2gocGl0Y2gpIHsgdGhpcy5fcGl0Y2ggPSBuZXcgUGl0Y2godGhpcywgcGl0Y2gpIH1cblxuICAvKipcbiAgICogRHVyYXRpb24gb2YgdGhlIG5vdGUuXG4gICAqIEB0eXBlIHttdXNqZS5EdXJhdGlvbn1cbiAgICovXG4gIGdldCBkdXJhdGlvbigpIHsgcmV0dXJuIHRoaXMuX2R1cmF0aW9uIHx8ICh0aGlzLl9kdXJhdGlvbiA9IG5ldyBEdXJhdGlvbigpKSB9XG4gIHNldCBkdXJhdGlvbiAoZHVyYXRpb24pIHsgdGhpcy5fZHVyYXRpb24gPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pIH1cblxuICBnZXQgYmVhbXMoKSB7IHJldHVybiB0aGlzLl9iZWFtcyB8fCAodGhpcy5fYmVhbXMgPSBbXSkgfVxuICBzZXQgYmVhbXMoYmVhbXMpIHsgdGhpcy5fYmVhbXMgPSBiZWFtcyB9XG5cbiAgLyoqXG4gICAqIFRpZVxuICAgKiBAdHlwZSB7bXVzamUuVGllfVxuICAgKi9cbiAgZ2V0IHRpZSgpIHsgcmV0dXJuIHRoaXMuX3RpZSB8fCAodGhpcy5fdGllID0gbmV3IFRpZSh0aGlzKSkgfVxuICBzZXQgdGllKHRpZSkge1xuICAgIC8qKlxuICAgICAqIFZhbHVlIG9mIHRoZSB0aWUuXG4gICAgICogQG1lbWJlcm9mIFRpZSNcbiAgICAgKiBAYWxpYXMgdmFsdWVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnRpZS52YWx1ZSA9IHRpZVxuICB9XG5cbiAgLyoqXG4gICAqIFNsdXJcbiAgICogQHR5cGUge1NsdXJ9XG4gICAqL1xuICBnZXQgc2x1cigpIHsgcmV0dXJuIHRoaXMuX3NsdXIgfHwgKHRoaXMuX3NsdXIgPSBuZXcgU2x1cih0aGlzKSkgfVxuICBzZXQgc2x1cihzbHVyKSB7IGV4dGVuZCh0aGlzLnNsdXIsIHNsdXIpIH1cblxuICAvKiogQG1ldGhvZCAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5zbHVyLmJlZ2luICsgdGhpcy5waXRjaCArIHRoaXMuZHVyYXRpb24gK1xuICAgICAgICAgICB0aGlzLnNsdXIuZW5kICsgdGhpcy50aWUudmFsdWVcbiAgfVxuXG4gIHRvSlNPTiA9IG1ha2VUb0pTT04oe1xuICAgIHBpdGNoOiB1bmRlZmluZWQsXG4gICAgZHVyYXRpb246IHVuZGVmaW5lZCxcbiAgICB0aWU6IHVuZGVmaW5lZCxcbiAgICBzbHVyOiB1bmRlZmluZWRcbiAgfSwgJ25vdGUnKVxufVxuXG5leHBvcnQgZGVmYXVsdCBOb3RlXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbW9kZWwvTm90ZS5qcyIsImltcG9ydCB7IG1ha2VUb0pTT04sIGV4dGVuZCB9IGZyb20gJy4uL3V0aWwnXG5cbmNvbnN0IEE0X0ZSRVFVRU5DWSA9IDQ0MFxuY29uc3QgQTRfTUlESV9OVU1CRVIgPSA2OVxuY29uc3QgU1RFUF9UT19NSURJX05VTUJFUiA9IFt1bmRlZmluZWQsIDAsIDIsIDQsIDUsIDcsIDksIDExXVxuY29uc3QgQUNDSURFTlRBTF9UT19BTFRFUiA9IHsgJyMnIDogMSwgJyMjJzogMiwgbjogMCwgYiA6IC0xLCBiYjogLTIgfVxuXG5jb25zdCBjaGFycyA9IChjaCwgbnVtKSA9PiBuZXcgQXJyYXkobnVtICsgMSkuam9pbihjaClcbmNvbnN0IG9jdGF2ZVN0cmluZyA9IChvY3RhdmUpID0+XG4gIG9jdGF2ZSA+IDAgPyBjaGFycygnXFwnJywgb2N0YXZlKSA6XG4gIG9jdGF2ZSA8IDAgPyBjaGFycygnLCcsIC1vY3RhdmUpIDogJydcblxuLy8gLyoqXG4vLyAgKiBTdGVwIGlzIGEgdmFsdWUgb2YgYDFgLCBgMmAsIGAzYCwgYDRgLCBgNWAsIGA2YCwgb3IgYDdgLlxuLy8gICogQHR5cGUge251bWJlcn1cbi8vICAqIEBkZWZhdWx0XG4vLyAgKi9cbi8vIHN0ZXAgPSAxXG5cbi8vIC8qKlxuLy8gICogT2N0YXZlIGlzIGFuIGludGVnZXIgdmFsdWUgZnJvbSBgLTVgIHRvIGA1YCBpbmNsdXNpdmUuXG4vLyAgKiBAdHlwZSB7bnVtYmVyfVxuLy8gICogQGRlZmF1bHRcbi8vICAqL1xuLy8gb2N0YXZlID0gMFxuXG4vLyAvKipcbi8vICAqIEFjY2lkZW50YWwgaXMgZWl0aGVyIG9mXG4vLyAgKiAtIGAnIydgIC0gc2hhcnBcbi8vICAqIC0gYCcjIydgIC0gZG91YmxlIHNoYXJwXG4vLyAgKiAtIGAnYidgIC0gZmxhdFxuLy8gICogLSBgJ2JiJ2AgLSBkb3VibGUgZmxhdFxuLy8gICogLSBgJ24nYCAtIG5hdHVyYWxcbi8vICAqIC0gYCcnYCAtIChub25lKVxuLy8gICogQHR5cGUge3N0cmluZ31cbi8vICAqL1xuLy8gYWNjaWRlbnRhbCA9ICcnXG5cbi8qKlxuICogQGNsYXNzXG4gKiBAcGFyYW0gcGFyZW50IHtOb3RlfENob3JkfVxuICogQHBhcmFtIHBpdGNoIHtPYmplY3R9XG4gKi9cbmNsYXNzIFBpdGNoIHtcbiAgY29uc3RydWN0b3IocGFyZW50LCB7XG4gICAgc3RlcCA9IDEsXG4gICAgb2N0YXZlID0gMCxcbiAgICBhY2NpZGVudGFsID0gJydcbiAgfSkge1xuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudFxuICAgIGV4dGVuZCh0aGlzLCB7IHN0ZXAsIG9jdGF2ZSwgYWNjaWRlbnRhbCB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byB0aGUgcGFyZW50IHBhcmVudC5cbiAgICogQHR5cGUge05vdGV8Q2hvcmR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHBhcmVudCgpIHsgcmV0dXJuIHRoaXMuX3BhcmVudCB9XG5cbiAgLyoqXG4gICAqIERlZiBpZCB1c2VkIGluIHRoZSBTVkcgPGRlZnM+IGVsZW1lbnQuXG4gICAqIGBgYFxuICAgKiBkZWZJZCA6PSAncCcgYWNjaWRlbnRhbCBzdGVwIG9jdGF2ZVxuICAgKiBgYGBcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZGVmSWQoKSB7XG4gICAgcmV0dXJuIGBwJHt0aGlzLmFjY2lkZW50YWwucmVwbGFjZSgvIy9nLCAncycpfSR7dGhpcy5zdGVwfSR7dGhpcy5vY3RhdmV9YFxuICB9XG5cbiAgLyoqXG4gICAqIEFsdGVyIChmcm9tIC0yIHRvIDIgaW5jbHVzaXZlKS5cbiAgICpcbiAgICogSWYgbm8gYWNjaWRlbnRhbCBpbiB0aGlzIHBpdGNoLCBpdCBtaWdodCBiZSBhZmZlY3RlZCBieSBhIHByZXZpb3VzIG5vdGUgaW4gdGhlIHNhbWUgY2VsbCAodGhlIHNhbWUgcGFydCBhbmQgdGhlIHNhbWUgbWVhc3VyZSkuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGFsdGVyKCkge1xuICAgIGlmICh0aGlzLmFjY2lkZW50YWwpIHJldHVybiBBQ0NJREVOVEFMX1RPX0FMVEVSW3RoaXMuYWNjaWRlbnRhbF1cbiAgICBjb25zdCB7IGFsdGVyTGluayB9ID0gdGhpc1xuICAgIHJldHVybiBhbHRlckxpbmsgPyBhbHRlckxpbmsuYWx0ZXIgOiAwXG4gIH1cblxuICAvKipcbiAgICogUGl0Y2ggbGlua2VkIHRoYXQgd2lsbCBhZmZlY3QgdGhlIGFsdGVyIGluIHRoaXMgcGl0Y2guXG4gICAqIEB0eXBlIHtQaXRjaHx1bmRlZmluZWR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGFsdGVyTGluaygpIHtcbiAgICBsZXQgcHJldkRhdGEgPSB0aGlzLnBhcmVudC5wcmV2XG5cbiAgICB3aGlsZShwcmV2RGF0YSkge1xuICAgICAgaWYgKHByZXZEYXRhLiR0eXBlID09PSAnbm90ZScgJiZcbiAgICAgICAgICBwcmV2RGF0YS5waXRjaC5zdGVwID09PSB0aGlzLnN0ZXAgJiYgcHJldkRhdGEucGl0Y2guYWNjaWRlbnRhbCkge1xuICAgICAgICByZXR1cm4gcHJldkRhdGEucGl0Y2hcbiAgICAgIH1cbiAgICAgIHByZXZEYXRhID0gcHJldkRhdGEucHJldlxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgTUlESSBub3RlIG51bWJlciBvZiB0aGUgcGl0Y2hcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtaWRpTnVtYmVyKCkge1xuICAgIHJldHVybiAodGhpcy5vY3RhdmUgKyA1KSAqIDEyICsgU1RFUF9UT19NSURJX05VTUJFUlt0aGlzLnN0ZXBdICsgdGhpcy5hbHRlclxuICB9XG5cbiAgLyoqXG4gICAqIEZyZXF1ZW5jeSBvZiB0aGUgcGl0Y2hcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZnJlcXVlbmN5KCkge1xuICAgIHJldHVybiBBNF9GUkVRVUVOQ1kgKiBNYXRoLnBvdygyLCAodGhpcy5taWRpTnVtYmVyIC0gQTRfTUlESV9OVU1CRVIpIC8gMTIpXG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0byBtdXNqZSBzb3VyY2UgY29kZSBzdHJpbmcuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29udmVydGVkIG11c2plIHNvdXJjZSBjb2RlIHN0cmluZy5cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmFjY2lkZW50YWwgKyB0aGlzLnN0ZXAgKyBvY3RhdmVTdHJpbmcodGhpcy5vY3RhdmUpXG4gIH1cblxuICB0b0pTT04gPSBtYWtlVG9KU09OKHtcbiAgICBzdGVwOiAxLFxuICAgIG9jdGF2ZTogMCxcbiAgICBhY2NpZGVudGFsOiAnJ1xuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBQaXRjaFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21vZGVsL1BpdGNoLmpzIiwiaW1wb3J0IHsgbWFrZVRvSlNPTiwgZXh0ZW5kIH0gZnJvbSAnLi4vdXRpbCdcblxuY29uc3QgVFlQRV9UT19TVFJJTkcgPSB7XG4gIDE6ICcgLSAtIC0gJywgMjogJyAtICcsIDQ6ICcnLCA4OiAnXycsIDE2OiAnPScsIDMyOiAnPV8nLFxuICA2NDogJz09JywgMTI4OiAnPT1fJywgMjU2OiAnPT09JywgNTEyOiAnPT09XycsIDEwMjQ6ICc9PT09J1xufVxuY29uc3QgVFlQRV9UT19VTkRFUkJBUiA9IHtcbiAgIDE6IDAsICAgMjogMCwgICA0OiAwLCAgIDg6IDEsICAgMTY6IDIsIDMyOiAzLFxuICA2NDogNCwgMTI4OiA1LCAyNTY6IDYsIDUxMjogNywgMTAyNDogOFxufVxuY29uc3QgRE9UX1RPX1NUUklORyA9IFsnJywgJy4nLCAnLi4nXVxuXG5cbiAgLy8gLyoqXG4gIC8vICAqIEJlYXQgdHlwZVxuICAvLyAgKiBAdHlwZSB7bnVtYmVyfVxuICAvLyAgKiBAZGVmYXVsdFxuICAvLyAgKi9cbiAgLy8gdHlwZSA9IDRcblxuICAvLyAqXG4gIC8vICAqIERvdCB3aXRoIHZhbHVlIG9mIDAsIDEsIG9yIDIuXG4gIC8vICAqIEB0eXBlIHtudW1iZXJ9XG4gIC8vICAqIEBkZWZhdWx0XG5cbiAgLy8gZG90ID0gMFxuXG5jbGFzcyBEdXJhdGlvbntcbiAgY29uc3RydWN0b3IoeyB0eXBlID0gNCwgZG90ID0gMCB9ID0ge30pIHtcbiAgICBleHRlbmQodGhpcywgeyB0eXBlLCBkb3QgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBUeXBlIG9mIGR1cmF0aW9uLlxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHQgZHVyYXRpb25cbiAgICovXG4gICR0eXBlID0gJ2R1cmF0aW9uJ1xuXG4gIC8qKlxuICAgKiBEZWYgaWQgdXNlZCBpbiB0aGUgU1ZHIDxkZWZzPiBlbGVtZW50LlxuICAgKiBgYGBcbiAgICogZGVmSWQgOj0gJ2QnIHR5cGUgZG90XG4gICAqIGBgYFxuICAgKiAqRS5nLipcbiAgICogYGBgXG4gICAqIE5vdGUgICAgIGRlZklkXG4gICAqIC0tLS0tLS0tLS0tLS0tLS1cbiAgICogMS4gICAgICAgZDQxXG4gICAqIDFfICAgICAgIGQ4MFxuICAgKiAxPSAgICAgICBkMTYwXG4gICAqIDEtLi4gICAgIGQyMlxuICAgKiBgYGBcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZGVmSWQoKSB7IHJldHVybiBgZCR7dGhpcy50eXBlfSR7dGhpcy5kb3R9YCB9XG5cbiAgLyoqXG4gICAqIGAoR2V0dGVyKWAgRHVyYXRpb24gbWVhc3VyZWQgaW4gcXVhcnRlciBub3RlLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHF1YXJ0ZXIoKSB7XG4gICAgY29uc3QgZCA9IDQgLyB0aGlzLnR5cGVcbiAgICByZXR1cm4gdGhpcy5kb3QgPT09IDAgPyBkIDpcbiAgICAgICAgICAgdGhpcy5kb3QgPT09IDEgPyBkICogMS41IDogZCAqIDEuNzVcbiAgfVxuXG4gIC8qKlxuICAgKiBgKEdldHRlcilgIER1cmF0aW9uIGluIHNlY29uZFxuICAgKiBBZmZlY3RlZCBieSB0aGUgdGVtcG8uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHNlY29uZCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWFydGVyICogNjAgLyA4MCAgLy8gLyBURU1QTztcbiAgfVxuXG4gIC8qKlxuICAgKiBgKEdldHRlcilgIE51bWJlciBvZiB1bmRlcmJhcnMgaW4gdGhlIGJlYW0uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHVuZGVyYmFyKCkgeyByZXR1cm4gVFlQRV9UT19VTkRFUkJBUlt0aGlzLnR5cGVdIHx8IDAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHsgcmV0dXJuIFRZUEVfVE9fU1RSSU5HW3RoaXMudHlwZV0gKyBET1RfVE9fU1RSSU5HW3RoaXMuZG90XSB9XG5cbiAgLyoqXG4gICAqIFt0b0pTT04gZGVzY3JpcHRpb25dXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHRvSlNPTiA9IG1ha2VUb0pTT04oe1xuICAgIHR5cGU6IDQsXG4gICAgZG90OiAwXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IER1cmF0aW9uXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbW9kZWwvRHVyYXRpb24uanMiLCIvKipcbiAqIFRpZSBvZiB0aGUgbm90ZS5cbiAqIEBwYXJhbSBwYXJlbnQge05vdGV8Q2hvcmR9XG4gKi9cbmNsYXNzIFRpZSB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudFxuICB9XG5cbiAgdmFsdWUgPSAnJ1xuXG4gIGdldCBwYXJlbnQoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQgfVxuXG4gIGdldCBiZWdpbigpIHsgcmV0dXJuIHRoaXMudmFsdWUgfVxuXG4gIGdldCBlbmQoKSB7IHJldHVybiB0aGlzLnByZXZQYXJlbnQgfVxuXG4gIC8qKlxuICAgKiBUaGUgcHJldmlvdXMgZHVyYWJsZSBtdXNpYyBkYXRhIGluIHBhcnQsIGlmIGl0IGlzIGEgdGllIGJlZ2luLlxuICAgKiBAdHlwZSB7RHVyYWJsZXx1bmRlZmluZWR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHByZXZQYXJlbnQoKSB7XG4gICAgdmFyIHByZXYgPSB0aGlzLnBhcmVudC5wcmV2RHVyYWJsZUluUGFydFxuICAgIHJldHVybiBwcmV2ICYmIHByZXYudGllICYmIHByZXYudGllLnZhbHVlICYmIHByZXZcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbmV4dCBkdXJhYmxlIG11c2ljIGRhdGEgaW4gcGFydC5cbiAgICogQHR5cGUge0R1cmFibGV8dW5kZWZpbmVkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBuZXh0UGFyZW50KCkgeyByZXR1cm4gdGhpcy52YWx1ZSAmJiB0aGlzLnBhcmVudC5uZXh0RHVyYWJsZUluUGFydCB9XG5cbiAgLyoqXG4gICAqIElmIHByZXZpb3VzIGR1cmFibGUgbXVzaWMgZGF0YSBpbiBwYXJ0IGhhcyBlcnJvci5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHByZXZIYXNFcnJvcigpIHtcbiAgICBjb25zdCBwcmV2ID0gdGhpcy5wcmV2UGFyZW50XG4gICAgaWYgKCFwcmV2IHx8ICFwcmV2LnBpdGNoKSByZXR1cm4gdHJ1ZVxuICAgIHJldHVybiBwcmV2LnBpdGNoICYmIHByZXYucGl0Y2gubWlkaU51bWJlciAhPT0gdGhpcy5wYXJlbnQucGl0Y2gubWlkaU51bWJlclxuICB9XG5cbiAgLyoqXG4gICAqIElmIG5leHQgZHVyYWJsZSBtdXNpYyBkYXRhIGluIHBhcnQgaGFzIGVycm9yLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbmV4dEhhc0Vycm9yKCkge1xuICAgIHZhciBuZXh0ID0gdGhpcy5uZXh0UGFyZW50XG4gICAgaWYgKCFuZXh0IHx8ICFuZXh0LnBpdGNoKSByZXR1cm4gdHJ1ZVxuICAgIHJldHVybiBuZXh0LnBpdGNoLm1pZGlOdW1iZXIgIT09IHRoaXMucGFyZW50LnBpdGNoLm1pZGlOdW1iZXJcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpZVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21vZGVsL1RpZS5qcyIsImltcG9ydCB7IG1ha2VUb0pTT04gfSBmcm9tICcuLi91dGlsJ1xuXG4vKipcbiAqIFNsdXJcbiAqIEBjbGFzc1xuICogQHBhcmFtIHBhcmVudCB7Tm90ZXxDaG9yZH1cbiAqL1xuY2xhc3MgU2x1ciB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudFxuICB9XG5cbiAgYmVnaW4gPSAnJ1xuXG4gIGVuZCA9ICcnXG5cbiAgLyoqXG4gICAqIFBhcmVudCBtdXNpYyBkYXRhLlxuICAgKiBAdHlwZSB7Tm90ZXxDaG9yZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcGFyZW50KCkgeyByZXR1cm4gdGhpcy5fcGFyZW50IH1cblxuICAvKipcbiAgICogUHJldmlvdXMgc2x1cnJlZCBwYXJlbnQuXG4gICAqIEB0eXBlIHtOb3RlfENob3JkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBwcmV2UGFyZW50KCkge1xuICAgIGlmICghdGhpcy5lbmQpIHJldHVyblxuXG4gICAgbGV0IHByZXYgPSB0aGlzLnBhcmVudC5wcmV2SW5QYXJ0XG4gICAgd2hpbGUgKHByZXYpIHtcbiAgICAgIGlmIChwcmV2LnNsdXIgJiYgIXByZXYuc2x1ci5pc0VtcHR5KSByZXR1cm4gcHJldlxuICAgICAgcHJldiA9IHByZXYucHJldkluUGFydFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBOZXh0IFNsdXJyZWQgcGFyZW50LlxuICAgKiBAdHlwZSB7Tm90ZXxDaG9yZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbmV4dFBhcmVudCgpIHtcbiAgICBpZiAoIXRoaXMuYmVnaW4pIHJldHVyblxuXG4gICAgbGV0IG5leHQgPSB0aGlzLnBhcmVudC5uZXh0SW5QYXJ0XG4gICAgd2hpbGUgKG5leHQpIHtcbiAgICAgIGlmIChuZXh0LnNsdXIgJiYgIW5leHQuc2x1ci5pc0VtcHR5KSByZXR1cm4gbmV4dFxuICAgICAgbmV4dCA9IG5leHQubmV4dEluUGFydFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdG9kbyBOZXN0ZWQgdGllIGluIHNsdXIuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBwcmV2Q3Jvc3NUaWUoKSB7fVxuXG4gIC8qKlxuICAgKiBAdG9kbyBOZXN0ZWQgdGllIGluIHNsdXIuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBuZXh0Q3Jvc3NUaWUoKSB7fVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgcHJldmlvdXMgc2x1ciBoYXMgZXJyb3IuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBwcmV2SGFzRXJyb3IoKSB7XG4gICAgY29uc3QgeyBwcmV2UGFyZW50IH0gPSB0aGlzXG4gICAgcmV0dXJuICFwcmV2UGFyZW50IHx8ICFwcmV2UGFyZW50LnNsdXIuYmVnaW5cbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgbmV4dCBzbHVyIGhhcyBlcnJvci5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG5leHRIYXNFcnJvcigpIHtcbiAgICBjb25zdCB7IG5leHRQYXJlbnQgfSA9IHRoaXNcbiAgICByZXR1cm4gIW5leHRQYXJlbnQgfHwgIW5leHRQYXJlbnQuc2x1ci5lbmRcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgc2x1ciBpcyBlbXB0eS5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGlzRW1wdHkoKSB7IHJldHVybiAhKHRoaXMuYmVnaW4gfHwgdGhpcy5lbmQpIH1cblxuICAvKipcbiAgICogQ29udmVydCB0aGUgc2x1ciB0byBKU09OIG9iamVjdC5cbiAgICogQG1ldGhvZFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEpTT04gb2JqZWN0LlxuICAgKi9cbiAgdG9KU09OID0gbWFrZVRvSlNPTih7XG4gICAgYmVnaW46IHVuZGVmaW5lZCxcbiAgICBlbmQ6IHVuZGVmaW5lZFxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBTbHVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbW9kZWwvU2x1ci5qcyIsImltcG9ydCB7IGV4dGVuZCwgbWFrZVRvSlNPTiB9IGZyb20gJy4uL3V0aWwnXG5pbXBvcnQgTXVzaWNEYXRhIGZyb20gJy4vTXVzaWNEYXRhJ1xuaW1wb3J0IER1cmF0aW9uIGZyb20gJy4vRHVyYXRpb24nXG5cbi8qKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3Jlc3R9IHJlc3RcbiAqIEBtaXhlcyBNdXNpY0RhdGFNaXhpblxuICogQG1peGVzIE11c2ljRGF0YUxheW91dE1peGluXG4gKi9cbmNsYXNzIFJlc3QgZXh0ZW5kcyBNdXNpY0RhdGEge1xuICBjb25zdHJ1Y3RvcihyZXN0KSB7XG4gICAgc3VwZXIoKVxuICAgIGV4dGVuZCh0aGlzLCByZXN0KVxuICB9XG5cbiAgLyoqXG4gICAqIFR5cGUgb2YgcmVzdC5cbiAgICogQGNvbnN0YW50XG4gICAqIEBkZWZhdWx0IHJlc3RcbiAgICovXG4gICR0eXBlID0gJ3Jlc3QnXG5cbiAgLyoqXG4gICAqIFVuaXF1ZSBkZWYgaWQgb2YgdGhlIHJlc3QgdXNlZCBpbiB0aGUgU1ZHIDxkZWZzPiBlbGVtZW50LlxuICAgKiBgYGBcbiAgICogZGVmSWQgOj0gJ3InIHR5cGUgZG90XG4gICAqIGBgYFxuICAgKiBFLmcuXG4gICAqIGBgYFxuICAgKiBSZXN0ICAgICBkZWZJZFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tXG4gICAqIDAgICAgICAgIHI0MFxuICAgKiAwIC0gICAgICByMjBcbiAgICogMD0uICAgICAgcjE2MVxuICAgKiBgYGBcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZGVmSWQoKSB7XG4gICAgY29uc3QgeyB0eXBlLCBkb3QgfSA9IHRoaXMuZHVyYXRpb25cbiAgICByZXR1cm4gYHIke3R5cGV9JHtkb3R9YFxuICB9XG5cbiAgLyoqXG4gICAqIER1cmF0aW9uIG9mIHRoZSByZXN0LlxuICAgKiBAdHlwZSB7RHVyYXRpb259XG4gICAqL1xuICBnZXQgZHVyYXRpb24oKSB7IHJldHVybiB0aGlzLl9kdXJhdGlvbiB8fCAodGhpcy5fZHVyYXRpb24gPSBuZXcgRHVyYXRpb24oKSkgfVxuICBzZXQgZHVyYXRpb24oZHVyYXRpb24pIHsgdGhpcy5fZHVyYXRpb24gPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pIH1cblxuICBnZXQgYmVhbXMoKSB7IHJldHVybiB0aGlzLl9iZWFtcyB8fCAodGhpcy5fYmVhbXMgPSBbXSkgfVxuICBzZXQgYmVhbXMoYmVhbXMpIHsgdGhpcy5fYmVhbXMgPSBiZWFtcyB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhlIHJlc3QgdG8gbXVzamUgc291cmNlIGNvZGUgc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbnZlcnRlZCBtdXNqZSBzb3VyY2UgY29kZS5cbiAgICovXG4gIHRvU3RyaW5nKCkgeyByZXR1cm4gYDAke3RoaXMuZHVyYXRpb259YCB9XG5cbiAgdG9KU09OID0gbWFrZVRvSlNPTih7XG4gICAgZHVyYXRpb246IHVuZGVmaW5lZCxcbiAgfSwgJ3Jlc3QnKVxufVxuXG5leHBvcnQgZGVmYXVsdCBSZXN0XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbW9kZWwvUmVzdC5qcyIsImltcG9ydCB7IGV4dGVuZCwgbWFrZVRvSlNPTiB9IGZyb20gJy4uL3V0aWwnXG5pbXBvcnQgTXVzaWNEYXRhIGZyb20gJy4vTXVzaWNEYXRhJ1xuaW1wb3J0IFBpdGNoIGZyb20gJy4vUGl0Y2gnXG5pbXBvcnQgRHVyYXRpb24gZnJvbSAnLi9EdXJhdGlvbidcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBjaG9yZFxuICogQG1peGVzIE11c2ljRGF0YU1peGluXG4gKiBAbWl4ZXMgTXVzaWNEYXRhTGF5b3V0TWl4aW5cbiAqL1xuY2xhc3MgQ2hvcmQgZXh0ZW5kcyBNdXNpY0RhdGEge1xuICBjb25zdHJ1Y3RvcihjaG9yZCkge1xuICAgIHN1cGVyKClcbiAgICBleHRlbmQodGhpcywgY2hvcmQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFR5cGUgb2YgY2hvcmQuXG4gICAqIEBjb25zdGFudFxuICAgKiBAZGVmYXVsdCBjaG9yZFxuICAgKi9cbiAgJHR5cGUgPSAnY2hvcmQnXG5cbiAgLyoqXG4gICAqIFBpdGNoZXMgaW4gdGhlIGNob3JkLlxuICAgKiBAdHlwZSB7QXJyYXkuPFBpdGNoPn1cbiAgICovXG4gIGdldCBwaXRjaGVzKCkgeyByZXR1cm4gdGhpcy5fcGl0Y2hlcyB8fCAodGhpcy5fcGl0Y2hlcyA9IFtdKSB9XG4gIHNldCBwaXRjaGVzKHBpdGNoZXMpIHsgdGhpcy5fcGl0Y2hlcyA9IHBpdGNoZXMubWFwKHBpdGNoID0+IG5ldyBQaXRjaChwaXRjaCkpIH1cblxuICAvKipcbiAgICogRHVyYXRpb24gb2YgdGhlIGNob3JkLlxuICAgKiBAdHlwZSB7RHVyYXRpb259XG4gICAqL1xuICBnZXQgZHVyYXRpb24oKSB7IHJldHVybiB0aGlzLl9kdXJhdGlvbiB8fCAodGhpcy5fZHVyYXRpb24gPSBuZXcgRHVyYXRpb24oKSkgfVxuICBzZXQgZHVyYXRpb24oZHVyYXRpb24pIHsgdGhpcy5fZHVyYXRpb24gPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pIH1cblxuICAvKipcbiAgICogQ29udmVydCBjaG9yZCB0byB0aGUgbXVzamUgc291cmNlIGNvZGUgc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbnZlcnRlZCBtdXNqZSBzb3VyY2UgY29kZSBvZiB0aGUgY2hvcmQuXG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJzwnICsgdGhpcy5waXRjaGVzLm1hcChwaXRjaCA9PiBwaXRjaC50b1N0cmluZygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJycpICsgJz4nICsgdGhpcy5kdXJhdGlvblxuICB9XG5cbiAgdG9KU09OID0gbWFrZVRvSlNPTih7XG4gICAgcGl0Y2hlczogdW5kZWZpbmVkLFxuICAgIGR1cmF0aW9uOiB1bmRlZmluZWQsXG4gIH0sICdjaG9yZCcpXG59XG5cbmV4cG9ydCBkZWZhdWx0IENob3JkXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbW9kZWwvQ2hvcmQuanMiLCJpbXBvcnQgeyBleHRlbmQgfSBmcm9tICcuLi91dGlsJ1xuaW1wb3J0IE11c2ljRGF0YSBmcm9tICcuL011c2ljRGF0YSdcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7T2JqZWN0fSB2b2ljZVxuICovXG5jbGFzcyBWb2ljZSBleHRlbmRzIE11c2ljRGF0YSB7XG4gIGNvbnN0cnVjdG9yKHZvaWNlKSB7XG4gICAgc3VwZXIoKVxuICAgIGV4dGVuZCh0aGlzLCB2b2ljZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBUeXBlIG9mIHZvaWNlLlxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHQgdm9pY2VcbiAgICovXG4gICR0eXBlID0gJ3ZvaWNlJ1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoZSB2b2ljZSB0byBtdXNqZSBzb3VyY2UgY29kZSBzdHJpbmcuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29udmVydGVkIG11c2plIHNvdXJjZSBjb2RlIHN0cmluZy5cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVm9pY2VcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2RlbC9Wb2ljZS5qcyIsIi8qKlxuICogQSBbYmVhbV1bd2lraV0gaXMgYSBob3Jpem9udGFsIG9yIGRpYWdvbmFsIGxpbmUgdXNlZCB0byBjb25uZWN0IG11bHRpcGxlIGNvbnNlY3V0aXZlIG5vdGVzIChhbmQgb2NjYXNpb25hbGx5IHJlc3RzKSBpbiBvcmRlciB0byBpbmRpY2F0ZSByaHl0aG1pYyBncm91cGluZy4gT25seSBlaWdodGggbm90ZXMgKHF1YXZlcnMpIG9yIHNob3J0ZXIgY2FuIGJlIGJlYW1lZC5cbiAqXG4gKiBbd2lraV06IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JlYW1fKG11c2ljKVxuICpcbiAqIEJlYW0gaXMgY3JlYXRlZCBieSB7QGxpbmsgQ2VsbCNtYWtlQmVhbXN9IGFuZFxuICogYXR0YWNoZWQgdG8ge0BsaW5rIER1cmFibGV9IGluIHtAbGluayBEdXJhYmxlI2JlYW1zfVtsZXZlbF1cbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gQmVhbSB2YWx1ZTogYCdiZWdpbidgLCBgJ2NvbnRpbnVlJ2Agb3IgYCdlbmQnYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbCAtIEJlYW0gbGV2ZWwgc3RhcnRpbmcgZnJvbSAwIHRvIHVwLlxuICogQHBhcmFtIHtEdXJhYmxlfSBwYXJlbnQgLSBUaGUgcGFyZW50IGR1cmFibGUgbXVzaWMgZGF0YS5cbiAqL1xuY2xhc3MgQmVhbSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBsZXZlbCwgcGFyZW50KSB7XG4gICAgdGhpcy5fdmFsdWUgPSB2YWx1ZVxuICAgIHRoaXMuX2xldmVsID0gbGV2ZWxcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnRcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJlbnRcbiAgICogQHR5cGUge05vdGV8UmVzdHxDaG9yZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcGFyZW50KCkgeyByZXR1cm4gdGhpcy5fcGFyZW50IH1cblxuICAvKipcbiAgICogQmVhbSB2YWx1ZTogYCdiZWdpbidgLCBgJ2NvbnRpbnVlJ2Agb3IgYCdlbmQnYC5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgdmFsdWUoKSB7IHJldHVybiB0aGlzLl92YWx1ZSB9XG5cbiAgLyoqXG4gICAqIEJlYW0gbGV2ZWwgc3RhcnRpbmcgZnJvbSAwIHRvIHVwLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBsZXZlbCgpIHsgcmV0dXJuIHRoaXMuX2xldmVsIH1cblxuICAvKipcbiAgICogVGhlIGVuZCBwYXJlbnQgbXVzaWMgZGF0YSBvZiB0aGUgYmVhbSBncm91cC5cbiAgICogQHR5cGUge011c2ljRGF0YU1peGlufVxuICAgKi9cbiAgZ2V0IGVuZER1cmFibGUoKSB7XG4gICAgbGV0IG5leHREYXRhID0gdGhpcy5wYXJlbnQubmV4dFxuICAgIHdoaWxlIChuZXh0RGF0YSAmJiBuZXh0RGF0YS5iZWFtc1t0aGlzLmxldmVsXS52YWx1ZSAhPT0gJ2VuZCcpIHtcbiAgICAgIG5leHREYXRhID0gbmV4dERhdGEubmV4dFxuICAgIH1cbiAgICByZXR1cm4gbmV4dERhdGFcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCZWFtXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbW9kZWwvQmVhbS5qcyIsImltcG9ydCBUaW1ld2lzZU1lYXN1cmUgZnJvbSAnLi9UaW1ld2lzZU1lYXN1cmUnXG5cbi8qKlxuICogQ29uc3RydWN0IHRpbWV3aXNlIHNjb3JlIG1lYXN1cmVzLlxuICogQGNsYXNzXG4gKiBAY2xhc3NkZXNjIFRpbWV3aXNlIHNjb3JlIG1lYXN1cmVzLlxuICogQHBhcmFtIHNjb3JlIHtTY29yZX1cbiAqIEBhdWdtZW50cyB7QXJyYXl9XG4gKi9cbmNsYXNzIFRpbWV3aXNlTWVhc3VyZXMgZXh0ZW5kcyBBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHNjb3JlKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX3Njb3JlID0gc2NvcmVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBzY29yZS5cbiAgICogQHR5cGUge1Njb3JlfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBzY29yZSgpIHsgcmV0dXJuIHRoaXMuX3Njb3JlIH1cblxuICAvKipcbiAgICogTWFrZSB0aW1ld2lzZSBzY29yZSBtZWFzdXJlcyBmcm9tIHRoZSBwYXJ0d2lzZSBwYXJ0cy5cbiAgICovXG4gIGZyb21QYXJ0d2lzZSgpIHtcbiAgICB0aGlzLnJlbW92ZUFsbCgpXG4gICAgdGhpcy5zY29yZS53YWxrQ2VsbHMoKGNlbGwsIG0pID0+IHtcbiAgICAgIGlmIChtID09PSB0aGlzLmxlbmd0aCAmJiAhdGhpc1ttXSkgdGhpcy5wdXNoKG5ldyBUaW1ld2lzZU1lYXN1cmUobSwgdGhpcykpXG4gICAgICB0aGlzW21dLnBhcnRzLnB1c2goY2VsbClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgbWVhc3VyZXMuXG4gICAqL1xuICByZW1vdmVBbGwoKSB7IHRoaXMubGVuZ3RoID0gMCB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbWV3aXNlTWVhc3VyZXNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2RlbC9UaW1ld2lzZU1lYXN1cmVzLmpzIiwiaW1wb3J0IHsgbWF0cml4IH0gZnJvbSAnc25hcHN2ZydcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSBtZWFzdXJlIHtPYmplY3R9XG4gKiBAbWl4ZXMgVGltZXdpc2VNZWFzdXJlTGF5b3V0TWl4aW5cbiAqL1xuY2xhc3MgVGltZXdpc2VNZWFzdXJlIHtcbiAgY29uc3RydWN0b3IoaW5kZXgsIG1lYXN1cmVzKSB7XG4gICAgLy8gdGhpcy5faW5kZXggPSBpbmRleFxuICAgIHRoaXMuX21lYXN1cmVzID0gbWVhc3VyZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBtZWFzdXJlcyBpbnN0YW5jZS5cbiAgICogQG1lbWJlciB7VGltZXdpc2VNZWFzdXJlc31cbiAgICovXG4gIGdldCBtZWFzdXJlcygpIHsgcmV0dXJuIHRoaXMuX21lYXN1cmVzIH1cblxuICAvKipcbiAgICogUGFydHMgaW4gdGltZXdpc2UgbWVhc3VyZS5cbiAgICogQHR5cGUge0FycmF5LjxDZWxsPn1cbiAgICovXG4gIGdldCBwYXJ0cygpIHsgcmV0dXJuIHRoaXMuX3BhcnRzIHx8ICh0aGlzLl9wYXJ0cyA9IFtdKSB9XG4gIHNldCBwYXJ0cyhwYXJ0cykgeyB0aGlzLl9wYXJ0cyA9IHBhcnRzIH1cblxuICAvKipcbiAgICogTGVmdCBiYXIgb2YgdGhlIG1lYXN1cmUuXG4gICAqIEB0eXBlIHtCYXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGJhckxlZnQoKSB7IHJldHVybiB0aGlzLnBhcnRzWzBdLmJhckxlZnQgfVxuXG4gIC8qKlxuICAgKiBSaWdodCBiYXIgb2YgdGhlIG1lYXN1cmUuXG4gICAqIEB0eXBlIHtCYXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGJhclJpZ2h0KCkgeyByZXR1cm4gdGhpcy5wYXJ0c1swXS5iYXJSaWdodCB9XG5cblxuICAvKipcbiAgICogTWVhc3VyZSBTVkcgZ3JvdXAgZWxlbWVudC5cbiAgICogQHR5cGUge1NuYXAuRWxlbWVudH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgZWwoKSB7IHJldHVybiB0aGlzLl9lbCB9XG5cbiAgLyoqXG4gICAqIE1pbmltdW4gd2lkdGggb2YgdGhlIG1lYXN1cmUuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWluV2lkdGgoKSB7XG4gICAgdmFyIG1pbldpZHRoID0gMFxuICAgIHRoaXMucGFydHMuZm9yRWFjaChmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgbWluV2lkdGggPSBNYXRoLm1heChtaW5XaWR0aCwgY2VsbC5taW5XaWR0aClcbiAgICB9KVxuICAgIHJldHVybiBtaW5XaWR0aCArIHRoaXMucGFkZGluZ1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byB0aGUgcGFyZW50IHN5c3RlbSBvZiB0aGlzIG1lYXN1cmUuXG4gICAqIC0gKEdldHRlcilcbiAgICogLSAoU2V0dGVyKSBUaGUgbWVhc3VyZSBlbCB3aWxsIGJlIGNyZWF0ZWQsIGFuZCB0aGUgaGVpZ2h0IG9mIHRoZSBtZWFzdXJlIHdpbGwgYmUgc2V0LlxuICAgKiBAdHlwZSB7U3lzdGVtTGF5b3V0fVxuICAgKi9cbiAgZ2V0IHN5c3RlbSgpIHsgcmV0dXJuIHRoaXMuX3MgfVxuICBzZXQgc3lzdGVtKHN5c3RlbSkge1xuICAgIHRoaXMuX3MgPSBzeXN0ZW1cbiAgICB0aGlzLl9lbCA9IHN5c3RlbS5lbC5nKCkuYWRkQ2xhc3MoJ211cy1tZWFzdXJlJylcbiAgfVxuXG4gIGdldCBwYWRkaW5nKCkge1xuICAgIGNvbnN0IGxvID0gdGhpcy5sYXlvdXQub3B0aW9uc1xuICAgIHJldHVybiBsby5tZWFzdXJlUGFkZGluZ1JpZ2h0ICsgbG8ubWVhc3VyZVBhZGRpbmdMZWZ0XG4gIH1cblxuICBnZXQgb3V0ZXJXaWR0aCgpIHsgcmV0dXJuIHRoaXMub3V0ZXJXaWR0aExlZnQgKyB0aGlzLm91dGVyV2lkdGhSaWdodCB9XG5cbiAgZ2V0IG91dGVyV2lkdGhMZWZ0KCkge1xuICAgIHJldHVybiB0aGlzLmxheW91dC5vcHRpb25zLm1lYXN1cmVQYWRkaW5nTGVmdCArXG4gICAgICAgICAgICB0aGlzLmJhckxlZnRJblN5c3RlbS53aWR0aCAvIDJcbiAgfVxuXG4gIGdldCBvdXRlcldpZHRoUmlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5b3V0Lm9wdGlvbnMubWVhc3VyZVBhZGRpbmdSaWdodCArXG4gICAgICAgICAgICB0aGlzLmJhclJpZ2h0SW5TeXN0ZW0ud2lkdGggLyAyXG4gIH1cblxuICAvKipcbiAgICogV2lkdGggb2YgdGhlIG1lYXN1cmUuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2lkdGgoKSB7IHJldHVybiB0aGlzLl93IHx8ICh0aGlzLl93ID0gdGhpcy5taW5XaWR0aCkgfVxuICBzZXQgd2lkdGgodykge1xuICAgIHRoaXMuX3cgPSB3XG4gICAgdGhpcy5wYXJ0cy5mb3JFYWNoKGNlbGwgPT4geyBjZWxsLndpZHRoID0gdyAtIHRoaXMub3V0ZXJXaWR0aCB9KVxuICB9XG5cbiAgZ2V0IGhlaWdodCgpIHsgcmV0dXJuIHRoaXMuc3lzdGVtLmhlaWdodCB9XG5cbiAgZ2V0IG1pbkhlaWdodCgpIHtcbiAgICBjb25zdCB7IHBhcnRTZXAgfSA9IHRoaXMubGF5b3V0Lm9wdGlvbnNcbiAgICBsZXQgbWluSGVpZ2h0ID0gMFxuXG4gICAgdGhpcy5wYXJ0cy5mb3JFYWNoKGNlbGwgPT4geyBtaW5IZWlnaHQgKz0gY2VsbC5oZWlnaHQgKyBwYXJ0U2VwIH0pXG4gICAgcmV0dXJuIG1pbkhlaWdodCA/IG1pbkhlaWdodCAtIHBhcnRTZXAgOiAwXG4gIH1cblxuICAvKipcbiAgICogVGhlIHggcG9zaXRpb24gb2YgdGhlIG1lYXN1cmUgaW4gdGhlIHN5c3RlbS5cbiAgICogLSAoR2V0dGVyKVxuICAgKiAtIChTZXR0ZXIpIFNldCB4IGNhdXNlIHRoZSBtZWFzdXJlIGVsZW1lbnQgdG8gdHJhbnNsYXRlLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHgoKSB7IHJldHVybiB0aGlzLl94IH1cbiAgc2V0IHgoeCkge1xuICAgIHRoaXMuX3ggPSB4XG4gICAgdGhpcy5lbC50cmFuc2Zvcm0oU25hcC5tYXRyaXgoKS50cmFuc2xhdGUoeCwgMCkpXG4gIH1cblxuICAvKipcbiAgICogSWYgdGhlIG1lYXN1cmUgaW4gdGhlIGJlZ2lubmluZyBvZiB0aGUgc3lzdGVtLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgaW5TeXN0ZW1CZWdpbigpIHsgcmV0dXJuIHRoaXMuX3NJbmRleCA9PT0gMCB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSBtZWFzdXJlIGluIHRoZSBlbmQgb2YgdGhlIHN5c3RlbS5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGluU3lzdGVtRW5kKCkgeyByZXR1cm4gdGhpcy5fc0luZGV4ID09PSB0aGlzLnN5c3RlbS5tZWFzdXJlcy5sZW5ndGggLSAxIH1cblxuICAvKipcbiAgICogTGVmdCBiYXIgb2YgdGhlIG1lYXN1cmUgaW4gc3lzdGVtLlxuICAgKiBAdHlwZSB7bXVzamUuQmFyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBiYXJMZWZ0SW5TeXN0ZW0oKSB7IHJldHVybiB0aGlzLnBhcnRzWzBdLmJhckxlZnRJblN5c3RlbSB9XG5cbiAgLyoqXG4gICAqIFJpZ2h0IGJhciBvZiB0aGUgbWVhc3VyZSBpbiBzeXN0ZW0uXG4gICAqIEB0eXBlIHtCYXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGJhclJpZ2h0SW5TeXN0ZW0oKSB7IHJldHVybiB0aGlzLnBhcnRzWzBdLmJhclJpZ2h0SW5TeXN0ZW0gfVxuXG4gIC8qKlxuICAgKiBGbG93IHRoZSBtZWFzdXJlLlxuICAgKi9cbiAgZmxvdygpIHtcbiAgICB0aGlzLnBhcnRzLmZvckVhY2goY2VsbCA9PiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2VsbCBTVkcgZ3JvdXAgZWxlbWVudC5cbiAgICAgICAqIEBtZW1iZXJvZiBDZWxsTGF5b3V0I1xuICAgICAgICogQGFsaWFzIGVsXG4gICAgICAgKiBAdHlwZSB7U25hcC5FbGVtZW50fVxuICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgKi9cbiAgICAgIGNlbGwuZWwgPSB0aGlzLmVsLmcoKS5hZGRDbGFzcygnbXVzLWNlbGwnKVxuXG4gICAgICBjZWxsLnggPSB0aGlzLm91dGVyV2lkdGhMZWZ0XG5cbiAgICAgIC8vIGNlbGwuZHJhd0JveCgpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBEcmF3IGJveCBvZiB0aGUgY2VsbC5cbiAgICogQHJldHVybiB7U25hcC5FbGVtZW50fSBUaGUgYm94IFNWRyByZWN0IGVsZW1lbnQuXG4gICAqL1xuICBkcmF3Qm94KCkge1xuICAgIHRoaXMuX2JveEVsID0gdGhpcy5lbC5yZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKHsgc3Ryb2tlOiAnZ3JlZW4nLCBmaWxsOiAnbm9uZScgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciB0aGUgYm94IFNWRyBlbGVtZW50LlxuICAgKi9cbiAgY2xlYXJCb3goKSB7XG4gICAgdGhpcy5fYm94RWwucmVtb3ZlKClcbiAgICB0aGlzLl9ib3hFbCA9IHVuZGVmaW5lZFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbWV3aXNlTWVhc3VyZVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21vZGVsL1RpbWV3aXNlTWVhc3VyZS5qcyIsImltcG9ydCB7IG1hdHJpeCB9IGZyb20gJ3NuYXBzdmcnXG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICcuLi8uLi91dGlsJ1xuaW1wb3J0IExheW91dCBmcm9tICcuLi9MYXlvdXQvTGF5b3V0J1xuaW1wb3J0IHJlbmRlckJhciBmcm9tICcuL3JlbmRlckJhcidcbmltcG9ydCByZW5kZXJEdXJhdGlvbiBmcm9tICcuL3JlbmRlckR1cmF0aW9uJ1xuaW1wb3J0IHJlbmRlckN1cnZlIGZyb20gJy4vcmVuZGVyQ3VydmUnXG5cbmNsYXNzIFJlbmRlcmVyIHtcbiAgY29uc3RydWN0b3Ioc3ZnLCBsbykge1xuICAgIHRoaXMuX2xvID0gZXh0ZW5kKExheW91dC5vcHRpb25zLCBsbylcbiAgICB0aGlzLmxheW91dCA9IG5ldyBMYXlvdXQoc3ZnLCB0aGlzLl9sbylcbiAgfVxuXG4gIHJlbmRlcihzY29yZSkge1xuICAgIHRoaXMuX3Njb3JlID0gc2NvcmVcbiAgICB0aGlzLmxheW91dC5mbG93KHNjb3JlKVxuICAgIHRoaXMucmVuZGVySGVhZGVyKClcbiAgICB0aGlzLnJlbmRlckNvbnRlbnQoKVxuICB9XG5cbiAgcmVuZGVySGVhZGVyKCkge1xuICAgIGNvbnN0IGxvID0gdGhpcy5fbG9cbiAgICBjb25zdCB7IGhlYWRlciB9ID0gdGhpcy5sYXlvdXRcbiAgICBjb25zdCB7IGVsLCB3aWR0aCB9ID0gaGVhZGVyXG5cbiAgICBlbC50ZXh0KHdpZHRoLzIsIGxvLnRpdGxlRm9udFNpemUsIHRoaXMuX3Njb3JlLmhlYWQudGl0bGUpLmF0dHIoe1xuICAgICAgZm9udFNpemU6IGxvLnRpdGxlRm9udFNpemUgKiAyLFxuICAgICAgZm9udFdlaWdodDogbG8udGl0bGVGb250V2VpZ2h0LFxuICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZSdcbiAgICB9KVxuXG4gICAgZWwudGV4dCh3aWR0aCwgbG8udGl0bGVGb250U2l6ZSAqIDEuNSwgdGhpcy5fc2NvcmUuaGVhZC5jb21wb3NlcikuYXR0cih7XG4gICAgICBmb250U2l6ZTogbG8uY29tcG9zZXJGb250U2l6ZSxcbiAgICAgIGZvbnRXZWlnaHQ6IGxvLmNvbXBvc2VyRm9udFdlaWdodCxcbiAgICAgIHRleHRBbmNob3I6ICdlbmQnXG4gICAgfSlcblxuICAgIGhlYWRlci5oZWlnaHQgPSBlbC5nZXRCQm94KCkuaGVpZ2h0XG4gIH1cblxuICByZW5kZXJDb250ZW50KCkge1xuICAgIGNvbnN0IGxvID0gdGhpcy5fbG9cblxuICAgIHRoaXMubGF5b3V0LmNvbnRlbnQuc3lzdGVtcy5mb3JFYWNoKHN5c3RlbSA9PiB7XG4gICAgICBjb25zdCB7IG1lYXN1cmVzIH0gPSBzeXN0ZW1cbiAgICAgIG1lYXN1cmVzLmZvckVhY2gobWVhc3VyZSA9PiB7XG4gICAgICAgIHJlbmRlckJhcihtZWFzdXJlLCBsbylcbiAgICAgICAgbWVhc3VyZS5wYXJ0cy5mb3JFYWNoKGNlbGwgPT4geyByZW5kZXJDZWxsKGNlbGwsIGxvKSB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlck5vdGUobm90ZSwgY2VsbCwgbG8pIHtcbiAgbm90ZS5lbCA9IGNlbGwuZWwuZygpLnRyYW5zZm9ybShtYXRyaXgoKS50cmFuc2xhdGUobm90ZS54LCBub3RlLnkpKVxuICBub3RlLmVsLnVzZShub3RlLmRlZi5waXRjaERlZi5lbClcbiAgcmVuZGVyRHVyYXRpb24obm90ZSwgbG8pXG59XG5cbmZ1bmN0aW9uIHJlbmRlckNlbGwoY2VsbCwgbG8pIHtcbiAgY2VsbC5kYXRhLmZvckVhY2goZGF0YSA9PiB7XG4gICAgc3dpdGNoIChkYXRhLiR0eXBlKSB7XG4gICAgICBjYXNlICdyZXN0JzpcbiAgICAgICAgcmVuZGVyTm90ZShkYXRhLCBjZWxsLCBsbylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ25vdGUnOlxuICAgICAgICByZW5kZXJOb3RlKGRhdGEsIGNlbGwsIGxvKVxuICAgICAgICByZW5kZXJDdXJ2ZSgndGllJywgZGF0YSlcbiAgICAgICAgcmVuZGVyQ3VydmUoJ3NsdXInLCBkYXRhKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndGltZSc6XG4gICAgICAgIGRhdGEuZWwgPSBjZWxsLmVsLnVzZShkYXRhLmRlZi5lbCkuYXR0cih7IHg6IGRhdGEueCwgeTogZGF0YS55IH0pXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVuZGVyZXJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZW5kZXJlci9SZW5kZXJlci9SZW5kZXJlci5qcyIsImltcG9ydCBsYXlvdXRPcHRpb25zIGZyb20gJy4vbGF5b3V0T3B0aW9ucydcbmltcG9ydCBEZWZzIGZyb20gJy4uL2RlZnMvRGVmcydcbmltcG9ydCBTdmdMYXlvdXQgZnJvbSAnLi9TdmdMYXlvdXQnXG5pbXBvcnQgQm9keUxheW91dCBmcm9tICcuL0JvZHlMYXlvdXQnXG5pbXBvcnQgSGVhZGVyTGF5b3V0IGZyb20gJy4vSGVhZGVyTGF5b3V0J1xuaW1wb3J0IENvbnRlbnRMYXlvdXQgZnJvbSAnLi9Db250ZW50TGF5b3V0J1xuXG4vKipcbiAqIEBjbGFzc1xuICogQHBhcmFtIHN2ZyB7c3RyaW5nfVxuICogQHBhcmFtIG9wdGlvbnMge09iamVjdH0gTGF5b3V0IG9wdGlvbnNcbiAqL1xuY2xhc3MgTGF5b3V0IHtcbiAgY29uc3RydWN0b3Ioc3ZnLCBvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMuc3ZnID0gc3ZnXG5cbiAgICB0aGlzLnN2ZyA9IG5ldyBTdmdMYXlvdXQodGhpcylcbiAgICB0aGlzLmJvZHkgPSBuZXcgQm9keUxheW91dCh0aGlzKVxuICAgIHRoaXMuaGVhZGVyID0gbmV3IEhlYWRlckxheW91dCh0aGlzKVxuICAgIHRoaXMuY29udGVudCA9IG5ldyBDb250ZW50TGF5b3V0KHRoaXMpXG5cbiAgICB0aGlzLmRlZnMgPSBuZXcgRGVmcyh0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge1Njb3JlfSBzY29yZVxuICAgKi9cbiAgZmxvdyhzY29yZSkge1xuICAgIGluaXQodGhpcywgc2NvcmUpXG4gICAgdGhpcy5jb250ZW50LmZsb3coc2NvcmUubWVhc3VyZXMpXG4gIH1cbn1cblxuTGF5b3V0Lm9wdGlvbnMgPSBsYXlvdXRPcHRpb25zXG5cbmZ1bmN0aW9uIGluaXQodGhhdCwgc2NvcmUpIHtcbiAgY29uc3QgeyBtZWFzdXJlcyB9ID0gc2NvcmVcbiAgbWVhc3VyZXMuZm9yRWFjaCgobWVhc3VyZSwgbSkgPT4ge1xuICAgIG1lYXN1cmUgPSBtZWFzdXJlc1ttXVxuICAgIG1lYXN1cmUubGF5b3V0ID0gdGhhdFxuICAgIG1lYXN1cmUucGFydHMuZm9yRWFjaChjZWxsID0+IHtcbiAgICAgIGNlbGwubGF5b3V0ID0gdGhhdFxuICAgICAgY2VsbC5mbG93KClcbiAgICB9KVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBMYXlvdXRcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZW5kZXJlci9MYXlvdXQvTGF5b3V0LmpzIiwiaW1wb3J0IHsgb2JqRWFjaCB9IGZyb20gJy4uLy4uL3V0aWwnXG5cbmNvbnN0IGxheW91dE9wdGlvbnMgPSB7XG4gIG1vZGU6ICdibG9jaycsIC8vIGlubGluZSB8IGJsb2NrIHwgcGFwZXJcbiAgLy8gd2lkdGg6IDY1MCxcbiAgLy8gaGVpZ2h0OiA2MDAsXG4gIG1hcmdpblRvcDogMjUsXG4gIG1hcmdpblJpZ2h0OiAzMCxcbiAgbWFyZ2luQm90dG9tOiAyNSxcbiAgbWFyZ2luTGVmdDogMzAsXG5cbiAgZm9udFNpemU6IDIwLFxuICBmb250RmFtaWx5OiAnSGVsdmV0aWNhLCBBcmlhbCwgU2FucyBTZXJpZicsXG5cbiAgdGl0bGVGb250U2l6ZTogJzExMCUnLFxuICAvLyB0aXRsZUZvbnRGYW1pbHlcbiAgdGl0bGVGb250V2VpZ2h0OiAnYm9sZCcsXG4gIGNvbXBvc2VyRm9udFNpemU6ICc5MCUnLFxuICAvLyBjb21wb3NlckZvbnRGYW1pbHk6XG4gIGNvbXBvc2VyRm9udFdlaWdodDogJ2JvbGQnLFxuICAvLyBjb21wb3NlckZvbnRTdHlsZSxcbiAgdGltZUZvbnRTaXplOiAnOTUlJyxcbiAgdGltZUZvbnRXZWlnaHQ6ICdib2xkJyxcblxuICBoZWFkZXJTZXA6ICcxMDAlJyxcbiAgc3lzdGVtU2VwOiAnMTgwJScsXG4gIG11c2ljRGF0YVNlcDogJzIwJScsXG5cbiAgcGFydEhlaWdodDogJzEyMCUnLFxuICBwYXJ0U2VwOiAnODAlJyxcblxuICBtZWFzdXJlUGFkZGluZ0xlZnQ6ICc1MCUnLFxuICBtZWFzdXJlUGFkZGluZ1JpZ2h0OiAnNTAlJyxcblxuICBiYXJsaW5lSGVpZ2h0OiAnMTIwJScsXG4gIHRoaW5CYXJsaW5lV2lkdGg6ICc0JScsXG4gIHRoaWNrQmFybGluZVdpZHRoOiAnMTYlJyxcbiAgYmFybGluZVNlcDogJzE4JScsXG4gIGJhcmxpbmVEb3RSYWRpdXM6ICc3LjUlJyxcbiAgYmFybGluZURvdFNlcDogJzIyJScsXG5cbiAgYWNjaWRlbnRhbEZvbnRTaXplOiAnOTUlJyxcbiAgYWNjaWRlbnRhbFNoaWZ0OiAnMTAlJyxcblxuICBvY3RhdmVSYWRpdXM6ICc2LjYlJyxcbiAgb2N0YXZlT2Zmc2V0OiAnMCUnLFxuICBvY3RhdmVTZXA6ICcyMyUnLFxuXG4gIHN0ZXBCYXNlbGluZVNoaWZ0OiAnMTIlJywgIC8vIGZvciBzdGVwIHdpdGhvdXQgbG93ZXIgb2N0YXZlIGFuZCB1bmRlcmxpbmVcblxuICB0eXBlU3Ryb2tlV2lkdGg6ICc1JScsXG4gIHR5cGViYXJPZmZzZXQ6ICczMCUnLCAgIC8vIDEgLSAtIC1cbiAgdHlwZWJhckxlbmd0aDogJzU1JScsICAgLy8gb2ZmIGxlbiBzZXAgbGVuIHNlcCBsZW4gKGRvdCkgZXh0XG4gIHR5cGViYXJTZXA6ICc0NSUnLCAgICAgIC8vIDEgLVxuICB0eXBlYmFyRXh0OiAnMjAlJywgICAgICAvLyBvZmYgbGVuIChkb3QpIGV4dFxuICB1bmRlcmJhclNlcDogJzE3JScsXG5cbiAgZG90T2Zmc2V0OiAnNjAlJywgICAgICAgLy8gZm9yIHR5cGUgPSAyXG4gIGRvdFJhZGl1czogJzYuNiUnLCAgICAgIC8vIDEgLSAuIC5cbiAgZG90U2VwOiAnNjAlJywgICAgICAgICAgLy8gb2ZmIGxlbiBkb3RPZmYgLiBkb3RTZXAgLiBleHRcbiAgdDREb3RPZmZzZXQ6ICczMCUnLFxuICB0NERvdFNlcDogJzUwJScsXG4gIHQ0RG90RXh0OiAnMjUlJyxcbiAgdDREb3RCYXNlbGluZVNoaWZ0OiAnMjAlJ1xufVxuXG5jb25zdCB7IGZvbnRTaXplIH0gPSBsYXlvdXRPcHRpb25zXG5cbm9iakVhY2gobGF5b3V0T3B0aW9ucywgKHZhbHVlLCBrZXkpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHJldHVyblxuXG4gIGNvbnN0IHVuaXQgPSB2YWx1ZS5yZXBsYWNlKC9bXFxkXFwuXSsvLCAnJylcbiAgdmFsdWUgPSArdmFsdWUucmVwbGFjZSgvW15cXGRcXC5dKy8sICcnKVxuXG4gIHN3aXRjaCAodW5pdCkge1xuICAgIGNhc2UgJyUnOlxuICAgICAgbGF5b3V0T3B0aW9uc1trZXldID0gZm9udFNpemUgKiB2YWx1ZSAvIDEwMFxuICAgICAgYnJlYWtcbiAgICBjYXNlICcnOlxuICAgICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgY2FzZSAncHgnOlxuICAgICAgbGF5b3V0T3B0aW9uc1trZXldID0gdmFsdWVcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnb3RoZXJzIHRvIGJlIGltcGxlbWVudGVkJzpcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgfVxufSlcblxuZXhwb3J0IGRlZmF1bHQgbGF5b3V0T3B0aW9uc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlbmRlcmVyL0xheW91dC9sYXlvdXRPcHRpb25zLmpzIiwiaW1wb3J0IEFjY2lkZW50YWxEZWYgZnJvbSAnLi9BY2NpZGVudGFsRGVmJ1xuaW1wb3J0IEJhckRlZiBmcm9tICcuL0JhckRlZidcbmltcG9ydCBEdXJhdGlvbkRlZiBmcm9tICcuL0R1cmF0aW9uRGVmJ1xuaW1wb3J0IFBpdGNoRGVmIGZyb20gJy4vUGl0Y2hEZWYnXG5pbXBvcnQgVGltZURlZiBmcm9tICcuL1RpbWVEZWYnXG5pbXBvcnQgTm90ZSBmcm9tICcuLi8uLi9tb2RlbC9Ob3RlJ1xuXG4vKipcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtMYXlvdXR9IGxheW91dFxuICovXG5jbGFzcyBEZWZzIHtcbiAgY29uc3RydWN0b3IobGF5b3V0KSB7XG4gICAgdGhpcy5fbGF5b3V0ID0gbGF5b3V0XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdmcgZGVmIG9mIHRoZSBtdXNpYyBkYXRhLlxuICAgKiBAcGFyYW0gIG11c2ljRGF0YSB7TXVzaWNEYXRhTWl4aW59IG11c2ljIGRhdGFcbiAgICogQHJldHVybiB7RGVmfVxuICAgKi9cbiAgZ2V0KG11c2ljRGF0YSkge1xuICAgIHZhciBpZCA9IG11c2ljRGF0YS5kZWZJZFxuICAgIHJldHVybiB0aGlzW2lkXSB8fCAodGhpc1tpZF0gPSBtYWtlRGVmKGlkLCBtdXNpY0RhdGEsIHRoaXMpKVxuICB9XG5cbiAgZ2V0QWNjaWRlbnRhbChhY2NpZGVudGFsKSB7XG4gICAgdmFyIGlkID0gJ2EnICsgYWNjaWRlbnRhbC5yZXBsYWNlKC8jL2csICdzJylcbiAgICByZXR1cm4gdGhpc1tpZF0gfHxcbiAgICAgICAgICAodGhpc1tpZF0gPSBuZXcgQWNjaWRlbnRhbERlZihpZCwgYWNjaWRlbnRhbCwgdGhpcy5fbGF5b3V0KSlcbiAgfVxuXG4gIF9nZXRQaXRjaChpZCwgbm90ZSkge1xuICAgIHJldHVybiB0aGlzW2lkXSB8fFxuICAgICAgICAgICh0aGlzW2lkXSA9IG5ldyBQaXRjaERlZihpZCwgbm90ZSwgdGhpcykpXG4gIH1cbn1cblxuXG5mdW5jdGlvbiBtYWtlRGVmKGlkLCBtdXNpY0RhdGEsIGRlZnMpIHtcbiAgc3dpdGNoIChtdXNpY0RhdGEuJHR5cGUpIHtcbiAgICBjYXNlICdiYXInOlxuICAgICAgcmV0dXJuIG5ldyBCYXJEZWYoaWQsIG11c2ljRGF0YSwgZGVmcy5fbGF5b3V0KVxuICAgIGNhc2UgJ3RpbWUnOlxuICAgICAgcmV0dXJuIG5ldyBUaW1lRGVmKGlkLCBtdXNpY0RhdGEsIGRlZnMuX2xheW91dClcbiAgICBjYXNlICdub3RlJzpcbiAgICAgIHJldHVybiBtYWtlTm90ZURlZihtdXNpY0RhdGEsIGRlZnMpXG4gICAgY2FzZSAncmVzdCc6XG4gICAgICByZXR1cm4gbWFrZVJlc3REZWYobXVzaWNEYXRhLCBkZWZzKVxuICAgIGNhc2UgJ2R1cmF0aW9uJzpcbiAgICAgIHJldHVybiBuZXcgRHVyYXRpb25EZWYoaWQsIG11c2ljRGF0YSwgZGVmcy5fbGF5b3V0KVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlTm90ZURlZihub3RlLCBkZWZzKSB7XG4gIGNvbnN0IHVuZGVyYmFyID0gbm90ZS5kdXJhdGlvbi51bmRlcmJhclxuICBjb25zdCBwaXRjaElkID0gbm90ZS5waXRjaC5kZWZJZCArIHVuZGVyYmFyXG4gIGNvbnN0IHBpdGNoRGVmID0gZGVmcy5fZ2V0UGl0Y2gocGl0Y2hJZCwgbm90ZSlcbiAgY29uc3QgZHVyYXRpb25EZWYgPSBkZWZzLmdldChub3RlLmR1cmF0aW9uKVxuICByZXR1cm4ge1xuICAgIHBpdGNoRGVmOiBwaXRjaERlZixcbiAgICBkdXJhdGlvbkRlZjogZHVyYXRpb25EZWYsXG4gICAgaGVpZ2h0OiBwaXRjaERlZi5oZWlnaHQsXG4gICAgd2lkdGg6IHBpdGNoRGVmLndpZHRoICsgZHVyYXRpb25EZWYud2lkdGggKiAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKHVuZGVyYmFyID8gcGl0Y2hEZWYuc2NhbGUueCA6IDEpXG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZVJlc3REZWYocmVzdCwgZGVmcykge1xuICBjb25zdCByZXN0Tm90ZSA9IG5ldyBOb3RlKHsgcGl0Y2g6IHsgc3RlcDogMCB9LCBkdXJhdGlvbjogcmVzdC5kdXJhdGlvbiB9KVxuICByZXR1cm4gbWFrZU5vdGVEZWYocmVzdE5vdGUsIGRlZnMpXG59XG5cbmV4cG9ydCBkZWZhdWx0IERlZnNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZW5kZXJlci9kZWZzL0RlZnMuanMiLCJpbXBvcnQgU25hcCBmcm9tICdzbmFwc3ZnJ1xuaW1wb3J0IHN2Z1BhdGhzIGZyb20gJy4uL3N2Z1BhdGhzJ1xuXG4vKipcbiAqIFNWRyBkZWZpbml0aW9uIGZvciBhY2NpZGVudGFsLlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0ge3N0cmluZ30gYWNjaWRlbnRhbCBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0ICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIEFjY2lkZW50YWxEZWYoaWQsIGFjY2lkZW50YWwsIGxheW91dCkge1xuICBjb25zdCB7IGFjY2lkZW50YWxTaGlmdCwgYWNjaWRlbnRhbEZvbnRTaXplIH0gPSBsYXlvdXQub3B0aW9uc1xuICBjb25zdCBlbCA9IHRoaXMuZWwgPSBsYXlvdXQuc3ZnLmVsLmcoKS5hdHRyKCdpZCcsIGlkKVxuICBjb25zdCBhY2NLZXkgPSBhY2NpZGVudGFsLnJlcGxhY2UoL2JiLywgJ2InKSAvLyBkb3VibGUgZmxhdCB0byBiZSBzeW50aGVzaXplZFxuICBjb25zdCBwYXRoRGF0YSA9IHN2Z1BhdGhzW2FjY0tleV1cbiAgY29uc3QgcmF0aW8gPSBzdmdQYXRocy5BQ0NJREVOVEFMX1JBVElPU1thY2NLZXldXG4gIGNvbnN0IHNoaWZ0ID0gc3ZnUGF0aHMuQUNDSURFTlRBTF9TSElGVFNbYWNjS2V5XVxuICBjb25zdCBwYXRoID0gZWwucGF0aChwYXRoRGF0YSlcbiAgbGV0IGJiID0gZWwuZ2V0QkJveCgpXG5cbiAgcGF0aC50cmFuc2Zvcm0oU25hcC5tYXRyaXgoKVxuICAgIC50cmFuc2xhdGUoMC4xICogYWNjaWRlbnRhbFNoaWZ0LCAtYWNjaWRlbnRhbFNoaWZ0KVxuICAgIC5zY2FsZShyYXRpbyAqIGFjY2lkZW50YWxGb250U2l6ZSlcbiAgICAudHJhbnNsYXRlKC1iYi54LCBzaGlmdCAtIGJiLnkyKVxuICApXG5cbiAgLy8gQ29tYmluZSB0d28gZmxhdCB0byBiZSBkb3VibGUgZmxhdC5cbiAgaWYgKGFjY2lkZW50YWwgPT09ICdiYicpIHtcbiAgICBlbC51c2UocGF0aCkuYXR0cigneCcsIGFjY2lkZW50YWxGb250U2l6ZSAqIDAuMjQpXG4gICAgZWwudHJhbnNmb3JtKCdzY2FsZSgwLjksMSknKVxuICB9XG5cbiAgYmIgPSBlbC5nZXRCQm94KClcbiAgdGhpcy53aWR0aCA9IGJiLndpZHRoICogMS4yXG5cbiAgZWwudG9EZWZzKClcbn1cblxuZXhwb3J0IGRlZmF1bHQgQWNjaWRlbnRhbERlZlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlbmRlcmVyL2RlZnMvQWNjaWRlbnRhbERlZi5qcyIsImNvbnN0IHN2Z1BhdGhzID0ge1xuICAvLyBodHRwczovL3VwbG9hZC53aWtpbWVkaWEub3JnL3dpa2lwZWRpYS9jb21tb25zL2EvYTYvU2hhcnAuc3ZnXG4gICcjJzogJ002LjEwMiw3LjQ1N1YyLjc1M0w4LjEwMiwyLjIwMVY2Ljg4MUw2LjEwMiw3LjQ1N3pNMTAuMDQsNi4zMTlMOC42NjUsNi43MTNWMi4wMzNMMTAuMDQsMS42NDlWLTAuMjk1TDguNjY1LDAuMDg5Vi00LjY5Mjc3SDguMTAyVjAuMjM0TDYuMTAyLDAuODA5Vi0zLjg0MDc3SDUuNTcxVjAuOTg2TDQuMTk2LDEuMzcxVjMuMzE5TDUuNTcxLDIuOTM1VjcuNjA2TDQuMTk2LDcuOTg5VjkuOTI5TDUuNTcxLDkuNTQ1VjE0LjI5OUw2LjEwMiwxNC4yOTk3N1Y5LjM3NUw4LjEwMiw4LjgyNVYxMy40NTA3N0g4LjY2NVY4LjY1MUwxMC4wNCw4LjI2NlY2LjMxOXonLFxuXG4gIC8vIGh0dHBzOi8vdXBsb2FkLndpa2ltZWRpYS5vcmcvd2lraXBlZGlhL2NvbW1vbnMvMy8zYS9Eb3VibGVTaGFycC5zdmdcbiAgJyMjJzogJ001LjAwOSw4LjMwNzIxQzQuMjc0NDMsOC4xOTE5MiAzLjUyNzY5LDguMTkyMDkgMi43ODU4LDguMTkyOTRDMi43NzAwNyw3LjY1MDExIDIuODU2NzQsNy4wNzI5IDIuNjQxNSw2LjU2MzQzQzIuNDk4MjEsNi4yMjQyNiAyLjIyNTMyLDUuOTU2NjUgMS45ODI2OSw1LjY4MTU1QzEuNTk1NTIsNi4wMjc4IDEuMjc3NTEsNi40ODQ3NSAxLjI0NzA0LDcuMDE2MzhDMS4yMTcwNiw3LjQwNzY3IDEuMjM5MDIsNy44MDA4NSAxLjIzMjIsOC4xOTI5NEMwLjQ5MDQsOC4yMDQxNi0wLjI1OTE4LDguMTY4MjgtMC45OTEsOC4zMTRDLTAuODQ5ODgsNy41ODYzLTAuODgxOTUsNi44NDE3MS0wLjg2OTE3LDYuMTA0OEMtMC4zMDQzLDYuMDg5NTMgMC4zMDAyMyw2LjE3MTAxIDAuODI0ODQsNS45MjUyNkMxLjEzNDQxLDUuNzgwMjMgMS4zOTY1Myw1LjU1Mjk1IDEuNjU5MSw1LjMzNjc2QzEuMzE3Myw0Ljk0OTY1IDAuODczNDYsNC42MDg2MSAwLjMzNjY1LDQuNTc2NTFDLTAuMDY0MjcsNC41NDQ4NS0wLjQ2NzM0LDQuNTY3OTMtMC44NjkxNyw0LjU2MDk3Qy0wLjg5NDM0LDMuODI5NDktMC44MDg5NSwzLjA4ODU1LTAuOTYwNzksMi4zNjYzQy0wLjIzNzMzLDIuNDk2OTcgMC41MDA2NSwyLjQ2MzQzIDEuMjMyMiwyLjQ3Mjg0QzEuMjQzMDYsMi45OTM4MyAxLjE4NDgzLDMuNTMzODEgMS4zMzE5MSw0LjAzNTVDMS40NDQxNCw0LjQxODM4IDEuNzQ5NzgsNC43MTI5MyAyLjAwNTEsNS4wMTUyMUMyLjM2NTUzLDQuNzAxMTEgMi42OTA1Nyw0LjMwNzA2IDIuNzUwMTEsMy44MTQxMkMyLjgwNCwzLjM2NzkzIDIuNzYxMjMsMi45MTk3NyAyLjc4NTgsMi40NzI4NEMzLjUyMjYzLDIuNDUzNDggNC4yODIxNSwyLjU0NzEzIDQuOTk1MzUsMi4zMTRDNC44ODg5MSwzLjA1NzExIDQuODc4ODksMy44MTE1MiA0Ljg4NzE3LDQuNTYwOTdDNC4zNjEyNyw0LjU3NTgyIDMuODA5NTQsNC41MTc0NyAzLjMwOTU1LDQuNjk0NTdDMi45Mjk3NSw0LjgyOTEgMi42MzExNCw1LjEyMzQxIDIuMzI4NjksNS4zODMyNUMyLjY1NjYxLDUuNzE4NjcgMy4wNTE2LDYuMDI4MDIgMy41NDAzLDYuMDczNjhDMy45ODgzNCw2LjExNTU0IDQuNDM4MjksNi4wOTY1OCA0Ljg4NzE3LDYuMTA0OEM0Ljg5ODI4LDYuODM5NTggNC44NjE5Myw3LjU4MjUgNS4wMDksOC4zMDcyMXonLFxuXG4gIC8vIGh0dHBzOi8vdXBsb2FkLndpa2ltZWRpYS5vcmcvd2lraXBlZGlhL2NvbW1vbnMvYi9iYS9GbGF0LnN2Z1xuICBiOiAnTTguMTY2LDMuNjU3QzguMTY2LDQuMjMyIDcuOTUwNDI1LDQuNzgyNzMgNy4zNTksNS41MjE4OEM2LjczMjQzNSw2LjMwNDk0IDYuMjA1LDYuNzUzMTMgNS41MSw3LjI4MDEzVjMuODQ4QzUuNjY4LDMuNDQ5IDUuOTAxLDMuMTI2IDYuMjEsMi44NzhDNi41MTgsMi42MzEgNi44MywyLjUwNyA3LjE0NiwyLjUwN0M3LjY2OCwyLjUwNyA3Ljk5OSwyLjgwMyA4LjE0MiwzLjM5M0M4LjE1OCwzLjQ0MSA4LjE2NiwzLjUyOSA4LjE2NiwzLjY1N3pNOC4wOTEsMS4yNTdDNy42NiwxLjI1NyA3LjIyMiwxLjM3NiA2Ljc3NiwxLjYxNUM2LjMzLDEuODUzIDUuOTA4LDIuMTcyIDUuNTEsMi41NjlWLTQuNzAyNjdINC45NDcgVjcuNzUyMTNDNC45NDcsOC4xMDQxMyA1LjA0Myw4LjI4MDEzIDUuMjM1LDguMjgwMTNDNS4zNDYsOC4yODAxMyA1LjQ4MzkxMyw4LjE4NzEzIDUuNjksOC4wNjQxM0M2LjI3MzM0LDcuNzE1OTggNi42MzY5MzUsNy40ODMzMiA3LjAzMiw3LjIzNzg4QzcuNDgyNjE3LDYuOTU3OTIgNy45OSw2LjYzMSA4LjY2MSw1Ljk5MUM5LjEyNCw1LjUyNiA5LjQ1OSw1LjA1NyA5LjY2Nyw0LjU4NUM5Ljg3NCw0LjExMiA5Ljk3OCwzLjY0NCA5Ljk3OCwzLjE3OUM5Ljk3OCwyLjQ5MSA5Ljc5NSwyLjAwMiA5LjQyOSwxLjcxM0M5LjAxNSwxLjQwOSA4LjU2OCwxLjI1NyA4LjA5MSwxLjI1N3onLFxuXG4gIC8vIGh0dHBzOi8vdXBsb2FkLndpa2ltZWRpYS5vcmcvd2lraXBlZGlhL2NvbW1vbnMvZi9mNC9NdXNpYy1uYXR1cmFsLnN2Z1xuICBuOiAnTSAwLDE0LjExMlY0MS41MmgtMS4yNDhWMzEuMjQ4bC02LjY3MiwxLjcyOFY1LjIzMmgxLjJ2MTAuNzA0bDYuNzIsLTEuODI0em0tNi43Miw2LjQzMnY3LjUzNmw1LjQ3MiwtMS40NHYtNy41MzZsLTUuNDcyLDEuNDR6JyxcblxuICBBQ0NJREVOVEFMX1JBVElPUzogeyAnIyc6IDAuMDQzLCAnbic6IDAuMDIzLCAnIyMnOiAwLjA2MiwgYjogMC4wNTcgfSxcbiAgQUNDSURFTlRBTF9TSElGVFM6IHsgJyMnOiAxLCAnbic6IDIsICcjIyc6IC00LCBiOiAwIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgc3ZnUGF0aHNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZW5kZXJlci9zdmdQYXRocy5qcyIsIi8qKlxuICogU1ZHIGRlZmluaXRpb24gZm9yIGJhcmxpbmUuXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCAgICAgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtIHtCYXJ9IGJhciAgICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0IFtkZXNjcmlwdGlvbl1cbiAqL1xuZnVuY3Rpb24gQmFyRGVmKGlkLCBiYXIsIGxheW91dCkge1xuICBjb25zdCB7XG4gICAgdGhpbkJhcmxpbmVXaWR0aCwgdGhpY2tCYXJsaW5lV2lkdGgsXG4gICAgYmFybGluZVNlcCwgYmFybGluZURvdFNlcCwgYmFybGluZURvdFJhZGl1c1xuICB9ID0gbGF5b3V0Lm9wdGlvbnNcbiAgbGV0IHggPSAwXG4gIGxldCBsaW5lV2lkdGhcbiAgdGhpcy5lbCA9IGxheW91dC5zdmcuZWwuZygpLmF0dHIoJ2lkJywgaWQpLnRvRGVmcygpXG5cbiAgc3dpdGNoIChiYXIudmFsdWUpIHtcbiAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgbGluZVdpZHRoID0gdGhpbkJhcmxpbmVXaWR0aFxuICAgICAgYWRkQmFybGluZSh0aGlzLCB4LCBsaW5lV2lkdGgpXG4gICAgICB4ICs9IGxpbmVXaWR0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdkb3VibGUnOlxuICAgICAgbGluZVdpZHRoID0gdGhpbkJhcmxpbmVXaWR0aFxuICAgICAgYWRkQmFybGluZSh0aGlzLCB4LCBsaW5lV2lkdGgpXG4gICAgICB4ICs9IGxpbmVXaWR0aCArIGJhcmxpbmVTZXBcbiAgICAgIGFkZEJhcmxpbmUodGhpcywgeCwgbGluZVdpZHRoKVxuICAgICAgeCArPSBsaW5lV2lkdGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnZW5kJzpcbiAgICAgIGxpbmVXaWR0aCA9IHRoaW5CYXJsaW5lV2lkdGhcbiAgICAgIGFkZEJhcmxpbmUodGhpcywgeCwgbGluZVdpZHRoKVxuICAgICAgeCArPSBsaW5lV2lkdGggKyBiYXJsaW5lU2VwXG4gICAgICBsaW5lV2lkdGggPSB0aGlja0JhcmxpbmVXaWR0aFxuICAgICAgYWRkQmFybGluZSh0aGlzLCB4LCBsaW5lV2lkdGgpXG4gICAgICB4ICs9IGxpbmVXaWR0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdyZXBlYXQtYmVnaW4nOlxuICAgICAgbGluZVdpZHRoID0gdGhpY2tCYXJsaW5lV2lkdGhcbiAgICAgIGFkZEJhcmxpbmUodGhpcywgeCwgbGluZVdpZHRoKVxuICAgICAgeCArPSBsaW5lV2lkdGggKyBiYXJsaW5lU2VwXG4gICAgICBsaW5lV2lkdGggPSB0aGluQmFybGluZVdpZHRoXG4gICAgICBhZGRCYXJsaW5lKHRoaXMsIHgsIGxpbmVXaWR0aClcbiAgICAgIHggKz0gbGluZVdpZHRoICsgYmFybGluZURvdFNlcCArIGJhcmxpbmVEb3RSYWRpdXNcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAncmVwZWF0LWVuZCc6XG4gICAgICB4ID0gYmFybGluZURvdFNlcCArIGJhcmxpbmVEb3RSYWRpdXNcbiAgICAgIGxpbmVXaWR0aCA9IHRoaW5CYXJsaW5lV2lkdGhcbiAgICAgIGFkZEJhcmxpbmUodGhpcywgeCwgbGluZVdpZHRoKVxuICAgICAgeCArPSBsaW5lV2lkdGggKyBiYXJsaW5lU2VwXG4gICAgICBsaW5lV2lkdGggPSB0aGlja0JhcmxpbmVXaWR0aFxuICAgICAgYWRkQmFybGluZSh0aGlzLCB4LCBsaW5lV2lkdGgpXG4gICAgICB4ICs9IGxpbmVXaWR0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdyZXBlYXQtYm90aCc6XG4gICAgICB4ID0gYmFybGluZURvdFNlcCArIGJhcmxpbmVEb3RSYWRpdXNcbiAgICAgIGxpbmVXaWR0aCA9IHRoaW5CYXJsaW5lV2lkdGhcbiAgICAgIGFkZEJhcmxpbmUodGhpcywgeCwgbGluZVdpZHRoKVxuICAgICAgeCArPSBsaW5lV2lkdGggKyBiYXJsaW5lU2VwXG4gICAgICBsaW5lV2lkdGggPSB0aGlja0JhcmxpbmVXaWR0aFxuICAgICAgYWRkQmFybGluZSh0aGlzLCB4LCBsaW5lV2lkdGgpXG4gICAgICB4ICs9IGxpbmVXaWR0aCArIGJhcmxpbmVTZXBcbiAgICAgIGxpbmVXaWR0aCA9IHRoaW5CYXJsaW5lV2lkdGhcbiAgICAgIGFkZEJhcmxpbmUodGhpcywgeCwgbGluZVdpZHRoKVxuICAgICAgeCArPSBsaW5lV2lkdGggKyBiYXJsaW5lRG90U2VwICsgYmFybGluZURvdFJhZGl1c1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICB9XG4gIHRoaXMud2lkdGggPSB4XG59XG5cbmZ1bmN0aW9uIGFkZEJhcmxpbmUodGhhdCwgeCwgd2lkdGgpIHsgdGhhdC5lbC5yZWN0KHgsIDAsIHdpZHRoLCAxKSB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhckRlZlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlbmRlcmVyL2RlZnMvQmFyRGVmLmpzIiwiLyoqXG4gKiBTVkcgZGVmaW5pdGlvbiBmb3IgZHVyYXRpb24uXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCAgICAgICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0ge0R1cmF0aW9ufSBkdXJhdGlvbiBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0ICAgW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBEdXJhdGlvbkRlZihpZCwgZHVyYXRpb24sIGxheW91dCkge1xuICB0aGlzLl9pZCA9IGlkXG4gIHRoaXMuX2xheW91dCA9IGxheW91dFxuXG4gIC8vIG9ubHkgbWFrZSBkZWYgZWwgZm9yOlxuICAvLyBpZCA9IGQxMCwgZDExLCBkMTIsIGQyMCwgZDIxLCBkMjAsIGQ0MSwgZDQwXG4gIHN3aXRjaCAoZHVyYXRpb24udHlwZSkge1xuICAgIGNhc2UgMTogICAvLyB3aG9sZSBub3RlXG4gICAgICBtYWtlRWwodGhpcylcbiAgICAgIG1ha2VUeXBlMSh0aGlzLCBpZCwgZHVyYXRpb24uZG90KVxuICAgICAgYnJlYWtcbiAgICBjYXNlIDI6ICAgLy8gaGFsZiBub3RlXG4gICAgICBtYWtlRWwodGhpcylcbiAgICAgIG1ha2VUeXBlMih0aGlzLCBpZCwgZHVyYXRpb24uZG90KVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OiAgLy8gb3RoZXIgbm90ZSB0eXBlcyB0eXBlIHF1YXJ0ZXIgbm90ZSBkZWZcbiAgICAgIGlmIChkdXJhdGlvbi5kb3QgPT09IDApIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IDBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1ha2VFbCh0aGlzKVxuICAgICAgICBtYWtlVHlwZTQodGhpcywgaWQsIGR1cmF0aW9uLmRvdClcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlVHlwZTEodGhhdCwgaWQsIGRvdCkge1xuICBjb25zdCB7IHR5cGViYXJMZW5ndGgsIHR5cGViYXJTZXAsIHR5cGViYXJPZmZzZXQgfSA9IHRoYXQuX2xheW91dC5vcHRpb25zXG4gIGxldCB4ID0gdHlwZWJhck9mZnNldFxuXG4gIGFkZExpbmUodGhhdCwgeClcbiAgeCArPSB0eXBlYmFyTGVuZ3RoICsgdHlwZWJhclNlcFxuICBhZGRMaW5lKHRoYXQsIHgpXG4gIHggKz0gdHlwZWJhckxlbmd0aCArIHR5cGViYXJTZXBcbiAgYWRkTGluZSh0aGF0LCB4KVxuICB4ICs9IHR5cGViYXJMZW5ndGhcblxuICB0aGF0LndpZHRoID0gYWRkRG90KHRoYXQsIHgsIGRvdCwgMSlcbn1cblxuZnVuY3Rpb24gbWFrZVR5cGUyKHRoYXQsIGlkLCBkb3QpIHtcbiAgY29uc3QgeyB0eXBlYmFyT2Zmc2V0LCB0eXBlYmFyTGVuZ3RoIH0gPSB0aGF0Ll9sYXlvdXQub3B0aW9uc1xuICBsZXQgeCA9IHR5cGViYXJPZmZzZXRcblxuICBhZGRMaW5lKHRoYXQsIHR5cGViYXJPZmZzZXQpXG4gIHggKz0gdHlwZWJhckxlbmd0aFxuICB0aGF0LndpZHRoID0gYWRkRG90KHRoYXQsIHgsIGRvdCwgMilcbn1cblxuZnVuY3Rpb24gbWFrZVR5cGU0KHRoYXQsIGlkLCBkb3QpIHtcbiAgY29uc3Qge1xuICAgIHQ0RG90T2Zmc2V0LCB0NERvdEJhc2VsaW5lU2hpZnQsIHQ0RG90U2VwLCB0NERvdEV4dCwgZG90UmFkaXVzXG4gIH0gPSB0aGF0Ll9sYXlvdXQub3B0aW9uc1xuICBsZXQgeCA9IHQ0RG90T2Zmc2V0XG5cbiAgdGhhdC5lbC5jaXJjbGUoeCwgLXQ0RG90QmFzZWxpbmVTaGlmdCwgZG90UmFkaXVzKVxuXG4gIGlmIChkb3QgPiAxKSB7XG4gICAgeCArPSB0NERvdFNlcFxuICAgIHRoYXQuZWwuY2lyY2xlKHgsIC10NERvdEJhc2VsaW5lU2hpZnQsIGRvdFJhZGl1cylcbiAgfVxuICB0aGF0LndpZHRoID0geCArIHQ0RG90RXh0XG59XG5cbmZ1bmN0aW9uIG1ha2VFbCh0aGF0KSB7XG4gIHRoYXQuZWwgPSB0aGF0Ll9sYXlvdXQuc3ZnLmVsLmcoKVxuICAgICAgICAgICAgICAuYXR0cignaWQnLCB0aGF0Ll9pZClcbiAgICAgICAgICAgICAgLnRvRGVmcygpXG59XG5cbmZ1bmN0aW9uIGFkZExpbmUodGhhdCwgeCkge1xuICBjb25zdCB7IHR5cGVTdHJva2VXaWR0aCwgdHlwZWJhckxlbmd0aCB9ID0gdGhhdC5fbGF5b3V0Lm9wdGlvbnNcbiAgdGhhdC5lbC5yZWN0KHgsIC10eXBlU3Ryb2tlV2lkdGgsIHR5cGViYXJMZW5ndGgsIHR5cGVTdHJva2VXaWR0aClcbn1cblxuLy8gQWRkIGRvdCBmb3IgdHlwZSAxICh3aG9sZSkgb3IgdHlwZSAyIChoYWxmKSBub3RlLlxuZnVuY3Rpb24gYWRkRG90KHRoYXQsIHgsIGRvdCwgdHlwZSkge1xuICBjb25zdCB7IGRvdE9mZnNldCwgZG90U2VwLCBkb3RSYWRpdXMsIHR5cGViYXJFeHQgfSA9IHRoYXQuX2xheW91dC5vcHRpb25zXG5cbiAgaWYgKGRvdCA+IDApIHtcbiAgICB4ICs9IGRvdE9mZnNldCAqICh0eXBlID09PSAxID8gMS4yIDogMSlcbiAgICB0aGF0LmVsLmNpcmNsZSh4LCAwLCBkb3RSYWRpdXMpXG4gIH1cbiAgaWYgKGRvdCA+IDEpIHtcbiAgICB4ICs9IGRvdFNlcCAqICh0eXBlID09PSAxID8gMS4yIDogMSlcbiAgICB0aGF0LmVsLmNpcmNsZSh4LCAwLCBkb3RSYWRpdXMpXG4gIH1cbiAgcmV0dXJuIHggKyB0eXBlYmFyRXh0XG59XG5cbmV4cG9ydCBkZWZhdWx0IER1cmF0aW9uRGVmXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVuZGVyZXIvZGVmcy9EdXJhdGlvbkRlZi5qcyIsImltcG9ydCBTbmFwIGZyb20gJ3NuYXBzdmcnXG5pbXBvcnQgeyBleHRlbmQsIG5lYXIgfSBmcm9tICcuLi8uLi91dGlsJ1xuXG4vKipcbiAqIFNWRyBkZWZpbml0aW9uIGZvciBwaXRjaC5cbiAqIFRoZSBgUGl0Y2hEZWZgIGlzIGRlZmluZWQgYnkgcHJvcGVydGllczogYSBzIG8gdVxuICogYWNjaWRlbnRhbCBzdGVwIG9jdGF2ZSB1bmRlcmJhclxuICogQGNsYXNzXG4gKiBAcGFyYW0gaWQge3N0cmluZ30gICAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSBwaXRjaCB7UGl0Y2h9ICAgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtIGxheW91dCB7TGF5b3V0fSBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIFBpdGNoRGVmKGlkLCBub3RlLCBkZWZzKSB7XG4gIGNvbnN0IGxheW91dCA9IHRoaXMuX2xheW91dCA9IGRlZnMuX2xheW91dFxuICBjb25zdCB7IGFjY2lkZW50YWwsIG9jdGF2ZSB9ID0gbm90ZS5waXRjaFxuICAvLyBjb25zdCBzY2FsZSA9IGdldFNjYWxlKGFjY2lkZW50YWwsIG9jdGF2ZSwgdW5kZXJiYXIpXG4gIGNvbnN0IGVsID0gdGhpcy5lbCA9IGxheW91dC5zdmcuZWwuZygpLmF0dHIoe1xuICAgIGlkLFxuICAgIHN0cm9rZTogJ2JsYWNrJyxcbiAgICBzdHJva2VXaWR0aDogMC4xXG4gIH0pXG4gIGxldCBtYXRyaXgsIHNiYm94LCBwYmJveFxuXG4gIHRoaXMuX2RlZnMgPSBkZWZzXG4gIGFkZEFjY2lkZW50YWwodGhpcywgYWNjaWRlbnRhbClcbiAgYWRkU3RlcCh0aGlzLCBub3RlLnBpdGNoLnN0ZXApXG4gIGFkZE9jdGF2ZSh0aGlzLCBvY3RhdmUsIG5vdGUuZHVyYXRpb24udW5kZXJiYXIpXG5cbiAgbWF0cml4ID0gZ2V0TWF0cml4KHRoaXMsIG9jdGF2ZSlcbiAgZWwudHJhbnNmb3JtKG1hdHJpeClcblxuICAvLyDmraTlpITnmoRfc2Jib3jlsLHmmK/liqDkuoZzdGVw55qEYm91bmRpbmcgYm9477yM5pivYWRkU3RlcOWSjGFkZE9jdGF2ZeWIm+W7uuWSjOS/ruaUueeahFxuICBzYmJveCA9IHRoaXMuX3NiYm94XG4gIHNiYm94ID0gZ2V0QkJveEFmdGVyVHJhbnNmb3JtKHRoaXMuZWwsIHNiYm94LCBtYXRyaXgpXG5cbiAgcGJib3ggPSBlbC5nZXRCQm94KClcbiAgZWwudG9EZWZzKClcblxuICBleHRlbmQodGhpcywge1xuICAgIG1hdHJpeCxcbiAgICB3aWR0aDogcGJib3gud2lkdGgsXG4gICAgaGVpZ2h0OiAtcGJib3gueSxcbiAgICBzdGVwQ3g6IHNiYm94LmN4LFxuICAgIHN0ZXBZOiBzYmJveC55LFxuICAgIHN0ZXBDeTogc2Jib3guY3ksXG4gICAgc3RlcFkyOiBzYmJveC55MixcbiAgICBzdGVwVG9wOiBvY3RhdmUgPiAwID8gcGJib3gueSA6IHNiYm94LnkgKyBsYXlvdXQub3B0aW9ucy5mb250U2l6ZSAqIDAuMlxuICB9KVxufVxuXG5mdW5jdGlvbiBhZGRBY2NpZGVudGFsKHRoYXQsIGFjY2lkZW50YWwpIHtcbiAgaWYgKCFhY2NpZGVudGFsKSB7XG4gICAgdGhhdC5fYWNjaWRlbnRhbFgyID0gMFxuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IGFjY0RlZiA9IHRoYXQuX2RlZnMuZ2V0QWNjaWRlbnRhbChhY2NpZGVudGFsKVxuICB0aGF0LmVsLnVzZShhY2NEZWYuZWwpLmF0dHIoJ3knLCAtdGhhdC5fbGF5b3V0Lm9wdGlvbnMuYWNjaWRlbnRhbFNoaWZ0KVxuICB0aGF0Ll9hY2NpZGVudGFsWDIgPSBhY2NEZWYud2lkdGhcbn1cblxuLy8gc3RlcOWcqOi/memHjOWwseaYr+mfs+mYtueahOaVsOWtl1xuZnVuY3Rpb24gYWRkU3RlcCh0aGF0LCBzdGVwKSB7XG4gIHRoYXQuX3NiYm94ID0gdGhhdC5lbFxuICAgIC50ZXh0KHRoYXQuX2FjY2lkZW50YWxYMiwgMCwgJycgKyBzdGVwKVxuICAgIC5hdHRyKCdmb250LXNpemUnLCB0aGF0Ll9sYXlvdXQub3B0aW9ucy5mb250U2l6ZSlcbiAgICAuZ2V0QkJveCgpXG59XG5cbmZ1bmN0aW9uIGFkZE9jdGF2ZSh0aGF0LCBvY3RhdmUsIHVuZGVyYmFyKSB7XG4gIGlmICghb2N0YXZlKSByZXR1cm5cblxuICBjb25zdCB7IG9jdGF2ZVJhZGl1cywgb2N0YXZlT2Zmc2V0LCBvY3RhdmVTZXAgfSA9IHRoYXQuX2xheW91dC5vcHRpb25zXG4gIGNvbnN0IG9jdGF2ZUVsID0gdGhhdC5lbC5nKClcblxuICAvLyDliqDkuIrlhavluqblkozpn7PnmoTngrlcbiAgaWYgKG9jdGF2ZSA+IDApIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9jdGF2ZTsgaSsrKSB7XG4gICAgICBvY3RhdmVFbC5jaXJjbGUoXG4gICAgICAgIHRoYXQuX3NiYm94LmN4LFxuICAgICAgICB0aGF0Ll9zYmJveC55ICsgb2N0YXZlT2Zmc2V0IC0gb2N0YXZlU2VwICogaSxcbiAgICAgICAgb2N0YXZlUmFkaXVzXG4gICAgICApXG4gICAgfVxuICB9IGVsc2Uge1xuXG5cblxuICAgIGZvciAobGV0IGkgPSAwOyBpID4gb2N0YXZlOyBpLS0pIHtcbiAgICAgIG9jdGF2ZUVsLmNpcmNsZShcbiAgICAgICAgdGhhdC5fc2Jib3guY3gsXG4gICAgICAgIHRoYXQuX3NiYm94LnkyIC0gb2N0YXZlT2Zmc2V0IC0gb2N0YXZlU2VwICogaSAtIHVuZGVyYmFyID8gdW5kZXJiYXIgKiB0aGF0Ll9sYXlvdXQub3B0aW9ucy51bmRlcmJhclNlcCA6IDAsXG4gICAgICAgIG9jdGF2ZVJhZGl1c1xuICAgICAgKVxuICAgIH1cbiAgfVxuICB0aGF0LmVsLmFkZChvY3RhdmVFbClcbn1cblxuLy8gVHJhbnNmb3JtIHRoZSBwaXRjaCB0byBiZSBpbiBhIGdvb2QgYmFzZWxpbmUgcG9zaXRpb24gYW5kXG4vLyBzY2FsZSBpdCB0byBiZSBtb3JlIHNxdWFyZS5cbmZ1bmN0aW9uIGdldE1hdHJpeCh0aGF0LCBvY3RhdmUpIHtcbiAgY29uc3QgeyBzdGVwQmFzZWxpbmVTaGlmdCwgdW5kZXJiYXJTZXAgfSA9IHRoYXQuX2xheW91dC5vcHRpb25zXG4gIGNvbnN0IHBiYm94ID0gdGhhdC5lbC5nZXRCQm94KClcblxuICAvLyDlhbPplK7vvJrlpoLmnpxvY3RhdmXlpKfkuo7nrYnkuo4w77yM5ZCM5pe25LiL6Z2i5Lmf5rKh5pyJ57q/77yMZHnlsLHmmK8tc3RlcEJhc2VsaW5lU2hpZnQsIOWQpuWImVxuICAvLyDlsLHmmK8w77yM6L+Y6KaB5Yqg5LiKdW5kZXJCYXIgKiB1bmRlckJhclNlcFxuICAvLyBjb25zdCBkeSA9IChvY3RhdmUgPj0gMCAmJiB1bmRlcmJhciA9PT0gMCA/IC1zdGVwQmFzZWxpbmVTaGlmdCA6IDApIC1cbiAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgdW5kZXJiYXIgKiB1bmRlcmJhclNlcFxuICByZXR1cm4gU25hcC5tYXRyaXgoKVxuICAgIC8vIC50cmFuc2xhdGUoLXBiYm94LngsIDApXG4gICAgLy8gLnRyYW5zbGF0ZSgwLCBuZWFyKHBiYm94LnkyLCB0aGF0Ll9zYmJveC55MikgPyAwIDogLXBiYm94LnkyKVxufVxuXG4vLyDlsIZib3VuZGluZyBib3jlubPnp7vliLDlkIjpgILkvY3nva5cbmZ1bmN0aW9uIGdldEJCb3hBZnRlclRyYW5zZm9ybShjb250YWluZXIsIGJib3gsIG1hdHJpeCkge1xuICBjb25zdCByZWN0ID0gY29udGFpbmVyLnJlY3QoYmJveC54LCBiYm94LnksIGJib3gud2lkdGgsIGJib3guaGVpZ2h0KVxuICBjb25zdCBnID0gY29udGFpbmVyLmcocmVjdClcbiAgcmVjdC50cmFuc2Zvcm0obWF0cml4KVxuICBiYm94ID0gZy5nZXRCQm94KClcbiAgZy5yZW1vdmUoKVxuICByZXR1cm4gYmJveFxufVxuXG5mdW5jdGlvbiBnZXRTY2FsZShoYXNBY2NpZGVudGFsLCBvY3RhdmUsIHVuZGVyYmFyKSB7XG4gIGNvbnN0IGFic09jdGF2ZSA9IE1hdGguYWJzKG9jdGF2ZSlcbiAgcmV0dXJuIHtcbiAgICB4OiBNYXRoLnBvdygwLjk3LCBhYnNPY3RhdmUgKyB1bmRlcmJhciArIChoYXNBY2NpZGVudGFsID8gMiA6IDApKSxcbiAgICB5OiBNYXRoLnBvdygwLjk1LCBhYnNPY3RhdmUgKyB1bmRlcmJhciArIChoYXNBY2NpZGVudGFsID8gMSA6IDApKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBpdGNoRGVmXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVuZGVyZXIvZGVmcy9QaXRjaERlZi5qcyIsImltcG9ydCBTbmFwIGZyb20gJ3NuYXBzdmcnXG5cbi8qKlxuICogU1ZHIGRlZmluaXRpb24gZm9yIHRpbWUgc2lnbmF0dXJlLlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgICAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSB7VGltZX0gdGltZSAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSB7TGF5b3V0fSBsYXlvdXQgW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBUaW1lRGVmKGlkLCB0aW1lLCBsYXlvdXQpIHtcbiAgY29uc3QgeyB0aW1lRm9udFNpemU6IGZvbnRTaXplLCB0aW1lRm9udFdlaWdodDogZm9udFdlaWdodCB9ID0gbGF5b3V0Lm9wdGlvbnNcbiAgY29uc3QgbGluZUV4dGVuZCA9IGZvbnRTaXplICogMC4xXG4gIGNvbnN0IGVsID0gdGhpcy5lbCA9IGxheW91dC5zdmcuZWwuZygpLmF0dHIoe1xuICAgIGlkLFxuICAgIGZvbnRTaXplLFxuICAgIGZvbnRXZWlnaHQsXG4gICAgdGV4dEFuY2hvcjogJ21pZGRsZSdcbiAgfSlcbiAgY29uc3QgbGluZVkgPSAtMC44NSAqIGZvbnRTaXplXG4gIGxldCBiYlxuXG4gIGVsLnRleHQoMCwgLTEgKiBmb250U2l6ZSwgdGltZS5iZWF0cylcbiAgZWwudGV4dCgwLCAwLCB0aW1lLmJlYXRUeXBlKSAgIC8vIGJhc2VsaW5lIHkgPSAwXG4gIGJiID0gZWwuZ2V0QkJveCgpXG4gIGVsLmxpbmUoYmIueCAtIGxpbmVFeHRlbmQsIGxpbmVZLCBiYi54MiArIGxpbmVFeHRlbmQsIGxpbmVZKVxuICBlbC50cmFuc2Zvcm0oU25hcC5tYXRyaXgoKS5zY2FsZSgxLCAwLjgpLnRyYW5zbGF0ZShsaW5lRXh0ZW5kIC0gYmIueCwgMCkpXG5cbiAgYmIgPSBlbC5nZXRCQm94KClcbiAgZWwudG9EZWZzKClcblxuICB0aGlzLndpZHRoID0gYmIud2lkdGhcbiAgdGhpcy5oZWlnaHQgPSAtYmIueVxufVxuXG5leHBvcnQgZGVmYXVsdCBUaW1lRGVmXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVuZGVyZXIvZGVmcy9UaW1lRGVmLmpzIiwiaW1wb3J0IFNuYXAgZnJvbSAnc25hcHN2ZydcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSBsYXlvdXQge0xheW91dH1cbiAqL1xuY2xhc3MgU3ZnTGF5b3V0IHtcbiAgY29uc3RydWN0b3IobGF5b3V0KSB7XG4gICAgdGhpcy5fbGF5b3V0ID0gbGF5b3V0XG4gICAgY29uc3QgeyBmb250RmFtaWx5LCB3aWR0aCB9ID0gbGF5b3V0Lm9wdGlvbnNcbiAgICB0aGlzLl9lbCA9IFNuYXAobGF5b3V0LnN2ZylcbiAgICAgIC5hdHRyKHsgZm9udEZhbWlseSB9KVxuICAgICAgLmFkZENsYXNzKCdtdXNqZScpXG4gICAgdGhpcy5lbC5jbGVhcigpXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoXG4gIH1cblxuICBnZXQgZWwoKSB7IHJldHVybiB0aGlzLl9lbCB9XG5cbiAgLyoqXG4gICAqIFdpZHRoIG9mIHRoZSBzdmcuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2lkdGgoKSB7IHJldHVybiB0aGlzLl93IH1cbiAgc2V0IHdpZHRoKHcpIHtcbiAgICB0aGlzLl93ID0gd1xuICAgIHRoaXMuZWwuYXR0cignd2lkdGgnLCB3KVxuICAgIGNvbnN0IHsgYm9keSB9ID0gdGhpcy5fbGF5b3V0XG4gICAgaWYgKGJvZHkpIGJvZHkud2lkdGggPSB3XG4gIH1cblxuICAvKipcbiAgICogSGVpZ2h0IG9mIHRoZSBzdmcuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgaGVpZ2h0KCkgeyByZXR1cm4gdGhpcy5faCB9XG4gIHNldCBoZWlnaHQoaCkge1xuICAgIHRoaXMuX2ggPSBoXG4gICAgdGhpcy5lbC5hdHRyKCdoZWlnaHQnLCBoKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFN2Z0xheW91dFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlbmRlcmVyL0xheW91dC9TdmdMYXlvdXQuanMiLCJpbXBvcnQgeyBtYXRyaXggfSBmcm9tICdzbmFwc3ZnJ1xuXG4vKipcbiAqIEJvZHlcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtMYXlvdXR9IGxheW91dFxuICovXG5jbGFzcyBCb2R5TGF5b3V0IHtcbiAgY29uc3RydWN0b3IobGF5b3V0KSB7XG4gICAgdGhpcy5fbGF5b3V0ID0gbGF5b3V0XG4gICAgY29uc3QgeyBzdmcsIG9wdGlvbnMgfSA9IGxheW91dFxuICAgIGNvbnN0IHsgbWFyZ2luVG9wLCBtYXJnaW5SaWdodCwgbWFyZ2luTGVmdCwgd2lkdGggfSA9IG9wdGlvbnNcbiAgICB0aGlzLl9lbCA9IHN2Zy5lbC5nKClcbiAgICAgICAgLnRyYW5zZm9ybShtYXRyaXgoKS50cmFuc2xhdGUobWFyZ2luTGVmdCwgbWFyZ2luVG9wKSlcbiAgICAgICAgLmFkZENsYXNzKCdtdXMtYm9keScpXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIC0gbWFyZ2luTGVmdCAtIG1hcmdpblJpZ2h0XG4gIH1cblxuICBnZXQgZWwoKSB7IHJldHVybiB0aGlzLl9lbCB9XG5cbiAgLyoqXG4gICAqIFdpZHRoIG9mIHRoZSBib2R5LlxuICAgKiAtIChHZXR0ZXIpIEdldCB0aGUgYm9keSB3aWR0aC5cbiAgICogLSAoU2V0dGVyKSBTZXQgdGhlIGJvZHkgd2lkdGggYW5kIHRoaXMgYWxzbyBpbmR1Y2VzIHNldHRpbmcgdGhlXG4gICAqIGhlYWRlciBhbmQgY29udGVudCB3aWR0aCBpZiBvbmUgZXhpc3RzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdpZHRoKCkgeyByZXR1cm4gdGhpcy5fdyB9XG4gIHNldCB3aWR0aCh3KSB7XG4gICAgdGhpcy5fdyA9IHdcbiAgICBjb25zdCBsYXlvdXQgPSB0aGlzLl9sYXlvdXRcbiAgICBpZiAobGF5b3V0LmhlYWRlcikgbGF5b3V0LmhlYWRlci53aWR0aCA9IHdcbiAgICBpZiAobGF5b3V0LmNvbnRlbnQpIGxheW91dC5jb250ZW50LndpZHRoID0gd1xuICB9XG5cbiAgLyoqXG4gICAqIEhlaWdodCBvZiB0aGUgYm9keS5cbiAgICogLSAoR2V0dGVyKSBHZXQgdGhlIGJvZHkgaGVpZ2h0LlxuICAgKiAtIChTZXR0ZXIpIFNldCB0aGUgYm9keSBoZWlnaHQgYW5kIHRoaXMgd2lsbCBhbHNvIGNhdXNlIHRoZSBoZWlnaHQgb2Ygc3ZnIHRvIHZhcnkuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgaGVpZ2h0KCkgeyByZXR1cm4gdGhpcy5faCB9XG4gIHNldCBoZWlnaHQoaCkge1xuICAgIGNvbnN0IGxheW91dCA9IHRoaXMuX2xheW91dFxuICAgIGNvbnN0IHsgbWFyZ2luVG9wLCBtYXJnaW5Cb3R0b20gfSA9IGxheW91dC5vcHRpb25zXG4gICAgbGF5b3V0LnN2Zy5oZWlnaHQgPSBoICsgbWFyZ2luVG9wICsgbWFyZ2luQm90dG9tXG4gICAgdGhpcy5faCA9IGhcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCb2R5TGF5b3V0XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVuZGVyZXIvTGF5b3V0L0JvZHlMYXlvdXQuanMiLCIvKipcbiAqIEhlYWRlciBsYXlvdXQuXG4gKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0XG4gKi9cbmNsYXNzIEhlYWRlckxheW91dCB7XG4gIGNvbnN0cnVjdG9yKGxheW91dCkge1xuICAgIHRoaXMuX2xheW91dCA9IGxheW91dFxuICAgIHRoaXMuZWwgPSBsYXlvdXQuYm9keS5lbC5nKCkuYWRkQ2xhc3MoJ211cy1oZWFkZXInKVxuICAgIHRoaXMud2lkdGggPSBsYXlvdXQuYm9keS53aWR0aFxuICB9XG5cbiAgLyoqXG4gICAqIFdpZHRoIG9mIHRoZSBoZWFkZXIuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2lkdGgoKSB7IHJldHVybiB0aGlzLl93IH1cbiAgc2V0IHdpZHRoKHcpIHsgdGhpcy5fdyA9IHcgfVxuXG4gIC8qKlxuICAgKiBIZWlnaHQgb2YgdGhlIGhlYWRlci5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBoZWlnaHQoKSB7IHJldHVybiB0aGlzLl9oIH1cbiAgc2V0IGhlaWdodChoKSB7XG4gICAgdGhpcy5faCA9IGhcbiAgICBjb25zdCB7IGNvbnRlbnQsIG9wdGlvbnMgfSA9IHRoaXMuX2xheW91dFxuICAgIGNvbnRlbnQueSA9IGggPyBoICsgb3B0aW9ucy5oZWFkZXJTZXAgOiAwXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSGVhZGVyTGF5b3V0XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVuZGVyZXIvTGF5b3V0L0hlYWRlckxheW91dC5qcyIsImltcG9ydCB7IG1hdHJpeCB9IGZyb20gJ3NuYXBzdmcnXG5pbXBvcnQgU3lzdGVtTGF5b3V0IGZyb20gJy4vU3lzdGVtTGF5b3V0J1xuXG4vKipcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtPYmplY3R9IGxheW91dCAtIFJlZmVyZW5jZSB0byB0aGUgcGFyZW50IGxheW91dCBpbnN0YW5jZS5cbiAqL1xuY2xhc3MgQ29udGVudExheW91dCB7XG4gIGNvbnN0cnVjdG9yKGxheW91dCkge1xuICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0XG4gICAgdGhpcy5lbCA9IGxheW91dC5ib2R5LmVsLmcoKS5hZGRDbGFzcygnbXVzLWNvbnRlbnQnKVxuICAgIHRoaXMud2lkdGggPSBsYXlvdXQuYm9keS53aWR0aFxuICB9XG5cbiAgZ2V0IHkoKSB7IHJldHVybiB0aGlzLl95IH1cbiAgc2V0IHkoeSkge1xuICAgIHRoaXMuX3kgPSB5XG4gICAgdGhpcy5lbC50cmFuc2Zvcm0obWF0cml4KCkudHJhbnNsYXRlKDAsIHkpKVxuICAgIHJlc2l6ZUJvZHkodGhpcylcbiAgfVxuXG4gIGdldCB3aWR0aCgpIHsgcmV0dXJuIHRoaXMuX3cgfVxuICBzZXQgd2lkdGgodykgeyB0aGlzLl93ID0gdyB9XG5cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICBjb25zdCBsYXN0ID0gdGhpcy5zeXN0ZW1zW3RoaXMuc3lzdGVtcy5sZW5ndGggLSAxXVxuICAgIHJldHVybiBsYXN0ID8gbGFzdC55ICsgbGFzdC5oZWlnaHQgOiAwXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHNjb3JlTWVhc3VyZSB7bXVzamUuVGltZXdpc2VNZWFzdXJlc30gVGhlIHRpbWV3aXNlIHNjb3JlIG1lYXN1cmUuXG4gICAqL1xuICBmbG93KHNjb3JlTWVhc3VyZXMpIHtcbiAgICBtYWtlU3lzdGVtcyh0aGlzLCBzY29yZU1lYXN1cmVzKVxuICAgIGJhbGFuY2VTeXN0ZW1zKHRoaXMpXG4gICAgdGhpcy5zeXN0ZW1zLmZvckVhY2goc3lzdGVtID0+IHsgc3lzdGVtLmZsb3coKSB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2l6ZUJvZHkodGhhdCkge1xuICBjb25zdCBsYXlvdXQgPSB0aGF0LmxheW91dFxuICBjb25zdCBoSGVpZ2h0ID0gbGF5b3V0LmhlYWRlci5oZWlnaHRcblxuICBsYXlvdXQuYm9keS5oZWlnaHQgPSB0aGF0LmhlaWdodCArXG4gICAgICAgIChoSGVpZ2h0ID8gaEhlaWdodCArIGxheW91dC5vcHRpb25zLmhlYWRlclNlcCA6IDApXG59XG5cbi8qKlxuICogRGl2aWRlIG1lYXN1cmVzIGluIHRpbWV3aXNlIHNjb3JlIGludG8gdGhlIHN5c3RlbXMuXG4gKiBAcGFyYW0gc2NvcmVNZWFzdXJlIHttdXNqZS5UaW1ld2lzZU1lYXN1cmVzfSBUaGUgdGltZXdpc2Ugc2NvcmUgbWVhc3VyZS5cbiAqL1xuZnVuY3Rpb24gbWFrZVN5c3RlbXModGhhdCwgc2NvcmVNZWFzdXJlcykge1xuICBjb25zdCB7IGxheW91dCB9ID0gdGhhdFxuICBjb25zdCB7IG1lYXN1cmVQYWRkaW5nUmlnaHQsIG1lYXN1cmVQYWRkaW5nTGVmdCB9ID0gbGF5b3V0Lm9wdGlvbnNcbiAgY29uc3QgbWVhc3VyZVBhZGRpbmcgPSBtZWFzdXJlUGFkZGluZ0xlZnQgKyBtZWFzdXJlUGFkZGluZ1JpZ2h0XG4gIGNvbnN0IHN5c3RlbXMgPSB0aGF0LnN5c3RlbXMgPSBbXVxuICBsZXQgc3lzdGVtID0gbmV3IFN5c3RlbUxheW91dChsYXlvdXQsIDApXG4gIHN5c3RlbXMucHVzaChzeXN0ZW0pXG5cbiAgc2NvcmVNZWFzdXJlcy5mb3JFYWNoKG1lYXN1cmUgPT4ge1xuICAgIGNvbnN0IG1pbldpZHRoID0gbWVhc3VyZS5taW5XaWR0aCArIG1lYXN1cmVQYWRkaW5nICtcbiAgICAgICAgICAgICAgICAgIChtZWFzdXJlLmJhckxlZnRJblN5c3RlbS53aWR0aCArXG4gICAgICAgICAgICAgICAgICAgbWVhc3VyZS5iYXJSaWdodEluU3lzdGVtLndpZHRoKSAvIDJcblxuICAgIC8vIENvbnRpbnVlIHB1dCB0aGlzIG1lYXN1cmUgaW4gdGhlIHN5c3RlbS5cbiAgICBpZiAoc3lzdGVtLm1pbldpZHRoICsgbWluV2lkdGggPCB0aGF0LndpZHRoKSB7XG4gICAgICBzeXN0ZW0ubWVhc3VyZXMucHVzaChtZWFzdXJlKVxuXG4gICAgLy8gTmV3IHN5c3RlbVxuICAgIH0gZWxzZSB7XG4gICAgICBzeXN0ZW0gPSBuZXcgU3lzdGVtTGF5b3V0KGxheW91dCwgc3lzdGVtcy5sZW5ndGgpXG4gICAgICBzeXN0ZW1zLnB1c2goc3lzdGVtKVxuICAgICAgc3lzdGVtLm1lYXN1cmVzLnB1c2gobWVhc3VyZSlcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGdldE1heExlbmd0aFN5c3RlbSh0aGF0KSB7XG4gIGxldCBtYXhMZW5ndGggPSAwXG4gIGxldCBzeXN0ZW1cblxuICB0aGF0LnN5c3RlbXMuZm9yRWFjaChzeXN0ZW0gPT4ge1xuICAgIG1heExlbmd0aCA9IE1hdGgubWF4KG1heExlbmd0aCwgc3lzdGVtLm1lYXN1cmVzLmxlbmd0aClcbiAgfSlcblxuICAvLyBGaW5kIHRoZSBmaXJzdCBtYXggbGVuZ3RoIHN5c3RlbSBiYWNrd2FyZC5cbiAgZm9yKGxldCBpID0gdGhhdC5zeXN0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgc3lzdGVtID0gdGhhdC5zeXN0ZW1zW2ldXG4gICAgaWYgKHN5c3RlbS5tZWFzdXJlcy5sZW5ndGggPT09IG1heExlbmd0aCkgcmV0dXJuIHN5c3RlbVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzTm90QmFsYW5jYWJsZSh0aGF0KSB7XG4gIGNvbnN0IHsgc3lzdGVtcywgd2lkdGggfSA9IHRoYXRcbiAgY29uc3QgeyBsZW5ndGggfSA9IHN5c3RlbXNcbiAgcmV0dXJuIGxlbmd0aCA9PT0gMSB8fCAgICAgICAvLyBvbmx5IDEgc3lzdGVtXG4gICAgKGxlbmd0aCA9PT0gMiAmJiBzeXN0ZW1zWzFdLm1pbldpZHRoIDwgd2lkdGggKiAwLjQpIC8vIDEgMi81IHN5c3RlbXNcbn1cblxuZnVuY3Rpb24gYmFsYW5jZVN5c3RlbXModGhhdCkge1xuICBpZiAoaXNOb3RCYWxhbmNhYmxlKHRoYXQpKSByZXR1cm5cblxuICBjb25zdCB7IHN5c3RlbXMgfSA9IHRoYXRcbiAgY29uc3QgbGFzdCA9IHN5c3RlbXNbc3lzdGVtcy5sZW5ndGggLSAxXVxuICBsZXQgc3lzdGVtID0gZ2V0TWF4TGVuZ3RoU3lzdGVtKHRoYXQpXG4gIGxldCBuZXh0LCBwcmV2XG5cbiAgLy8gTW92ZSBtZWFzdXJlcyBkb3duIHRvIGJhbGFuY2UgdGhlIGxhc3Qgc3lzdGVtLlxuICB3aGlsZSAobGFzdC5tZWFzdXJlcy5sZW5ndGggPCBzeXN0ZW0ubWVhc3VyZXMubGVuZ3RoIC0gMSkge1xuXG4gICAgLy8gTW92ZSBhIG1lYXN1cmUgdGFpbC10by1oZWFkIGRvd253YXJkIHRvIHRoZSBsYXN0IG1lYXN1cmUuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIG5leHQgPSBzeXN0ZW0ubmV4dFxuICAgICAgaWYgKCFuZXh0KSBicmVha1xuICAgICAgbmV4dC5tZWFzdXJlcy51bnNoaWZ0KHN5c3RlbS5tZWFzdXJlcy5wb3AoKSlcbiAgICAgIHN5c3RlbSA9IG5leHRcbiAgICB9XG4gICAgc3lzdGVtID0gZ2V0TWF4TGVuZ3RoU3lzdGVtKHRoYXQpXG4gIH1cblxuICAvLyBNb3ZlIGJhY2sgbWVhc3VyZXMgaWYgdGhlIHN5c3RlbSBleGNlZWRzIHRoZSBjb250ZW50IHdpZHRoLlxuICBzeXN0ZW0gPSBsYXN0XG4gIHdoaWxlIChzeXN0ZW0pIHtcbiAgICBwcmV2ID0gc3lzdGVtLnByZXZcbiAgICB3aGlsZSAoc3lzdGVtLm1pbldpZHRoID4gdGhhdC53aWR0aCkge1xuICAgICAgcHJldi5tZWFzdXJlcy5wdXNoKHN5c3RlbS5tZWFzdXJlcy5zaGlmdCgpKVxuICAgIH1cbiAgICBzeXN0ZW0gPSBwcmV2XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29udGVudExheW91dFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlbmRlcmVyL0xheW91dC9Db250ZW50TGF5b3V0LmpzIiwiaW1wb3J0IHsgbWF0cml4IH0gZnJvbSAnc25hcHN2ZydcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtMYXlvdXR9IGxheW91dFxuICovXG5jbGFzcyBTeXN0ZW1MYXlvdXQge1xuICBjb25zdHJ1Y3RvcihsYXlvdXQsIGluZGV4KSB7XG4gICAgdGhpcy5faW5kZXggPSBpbmRleFxuICAgIHRoaXMuX2xheW91dCA9IGxheW91dFxuICAgIHRoaXMuX2VsID0gbGF5b3V0LmNvbnRlbnQuZWwuZygpLmFkZENsYXNzKCdtdXMtc3lzdGVtJylcbiAgfVxuXG4gIGdldCBlbCgpIHsgcmV0dXJuIHRoaXMuX2VsIH1cblxuICAvKipcbiAgICogTWVhc3VyZXMgaW4gYSBzeXN0ZW0uXG4gICAqIEB0eXBlIHtBcnJheS48VGltZXdpc2VNZWFzdXJlPn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbWVhc3VyZXMoKSB7IHJldHVybiB0aGlzLl9tZWFzdXJlcyB8fCAodGhpcy5fbWVhc3VyZXMgPSBbXSkgfVxuXG4gIC8qKlxuICAgKiBQcmV2aW91cyBzeXN0ZW0uXG4gICAqIEB0eXBlIHtTeXN0ZW1MYXlvdXR9XG4gICAqL1xuICBnZXQgcHJldigpIHsgcmV0dXJuIHRoaXMuX2xheW91dC5jb250ZW50LnN5c3RlbXNbdGhpcy5faW5kZXggLSAxXSB9XG5cbiAgLyoqXG4gICAqIE5leHQgc3lzdGVtLlxuICAgKiBAdHlwZSB7U3lzdGVtTGF5b3V0fVxuICAgKi9cbiAgZ2V0IG5leHQoKSB7IHJldHVybiB0aGlzLl9sYXlvdXQuY29udGVudC5zeXN0ZW1zW3RoaXMuX2luZGV4ICsgMV0gfVxuXG4gIGdldCB5KCkgeyByZXR1cm4gdGhpcy5feSB9XG4gIHNldCB5KHkpIHtcbiAgICB0aGlzLl95ID0geVxuICAgIHRoaXMuZWwudHJhbnNmb3JtKG1hdHJpeCgpLnRyYW5zbGF0ZSgwLCB5KSlcbiAgfVxuXG4gIGdldCB3aWR0aCgpIHsgcmV0dXJuIHRoaXMuX2xheW91dC5jb250ZW50LndpZHRoIH1cblxuICBnZXQgbWluV2lkdGgoKSB7XG4gICAgbGV0IG1pbiA9IDBcbiAgICB0aGlzLm1lYXN1cmVzLmZvckVhY2gobWVhc3VyZSA9PiB7IG1pbiArPSBtZWFzdXJlLm1pbldpZHRoIH0pXG4gICAgcmV0dXJuIG1pblxuICB9XG5cbiAgZ2V0IGNvbnRlbnQoKSB7IHJldHVybiB0aGlzLl9sYXlvdXQuY29udGVudCB9XG5cbiAgZ2V0IHN5c3RlbXMoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQuc3lzdGVtcyB9XG5cbiAgZmxvdygpIHtcbiAgICBsZXQgbWluSGVpZ2h0ID0gMFxuICAgIGxldCB4ID0gMFxuXG4gICAgdHVuZU1lYXN1cmVzV2lkdGhzKHRoaXMpXG5cbiAgICB0aGlzLm1lYXN1cmVzLmZvckVhY2goKG1lYXN1cmUsIG0pID0+IHtcbiAgICAgIG1lYXN1cmUuc3lzdGVtID0gdGhpc1xuICAgICAgbWVhc3VyZS5fc0luZGV4ID0gbVxuICAgICAgbWVhc3VyZS5mbG93KClcbiAgICAgIG1lYXN1cmUueCA9IHhcbiAgICAgIHggKz0gbWVhc3VyZS53aWR0aFxuICAgICAgbWluSGVpZ2h0ID0gTWF0aC5tYXgobWluSGVpZ2h0LCBtZWFzdXJlLm1pbkhlaWdodClcbiAgICB9KVxuXG4gICAgY29uc3QgeyBwcmV2IH0gPSB0aGlzXG4gICAgdGhpcy55ID0gcHJldiA/IHByZXYueSArIHByZXYuaGVpZ2h0ICsgdGhpcy5fbGF5b3V0Lm9wdGlvbnMuc3lzdGVtU2VwIDogMFxuICAgIHRoaXMuaGVpZ2h0ID0gbWluSGVpZ2h0XG4gIH1cbn1cblxuZnVuY3Rpb24gdHVuZU1lYXN1cmVzV2lkdGhzKHRoYXQpIHtcbiAgaWYgKCFpc1R1bmFibGUodGhhdCkpIHJldHVyblxuXG4gIHZhciBwYWlycyA9IGdldFBhaXJzKHRoYXQubWVhc3VyZXMpXG4gIHZhciBsZW5ndGggPSBwYWlycy5sZW5ndGhcbiAgdmFyIHdpZHRoTGVmdCA9IHRoYXQud2lkdGhcbiAgdmFyIGl0ZW1MZWZ0ID0gbGVuZ3RoXG4gIHZhciBpID0gMCAgICAvLyBpICsgaXRlbUxlZnQgPT09IGxlbmd0aFxuICB2YXIgd2lkdGhcblxuICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgIGlmICh3aWR0aExlZnQgPj0gcGFpcnNbaV0ud2lkdGggKiBpdGVtTGVmdCkge1xuICAgICAgd2lkdGggPSB3aWR0aExlZnQgLyBpdGVtTGVmdFxuICAgICAgZG8ge1xuICAgICAgICBwYWlyc1tpXS5tZWFzdXJlLndpZHRoID0gd2lkdGhcbiAgICAgICAgaSsrXG4gICAgICB9IHdoaWxlIChpIDwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICB9IGVsc2Uge1xuICAgICAgd2lkdGggPSBwYWlyc1tpXS53aWR0aFxuICAgICAgcGFpcnNbaV0ubWVhc3VyZS53aWR0aCA9IHdpZHRoXG4gICAgICB3aWR0aExlZnQgLT0gd2lkdGhcbiAgICAgIGkrK1xuICAgICAgaXRlbUxlZnQtLVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1R1bmFibGUodGhhdCkge1xuICBjb25zdCBjdFdpZHRoID0gdGhhdC5jb250ZW50LndpZHRoXG4gIGNvbnN0IHMgPSB0aGF0Ll9pbmRleFxuICBjb25zdCBzc0xlbiA9IHRoYXQuc3lzdGVtcy5sZW5ndGhcbiAgcmV0dXJuIHNzTGVuID4gMiB8fFxuICAgICAoc3NMZW4gPT09IDEgJiYgdGhhdC5taW5XaWR0aCA+IGN0V2lkdGggKiAwLjcpIHx8XG4gICAgIChzc0xlbiA9PT0gMiAmJiAocyA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgKHMgPT09IDEgJiYgdGhhdC5taW5XaWR0aCA+IGN0V2lkdGggKiAwLjQpKSlcbn1cblxuY29uc3QgZGVzY2VuZGluZ1NvcnQgPSAoYSwgYikgPT4gYi53aWR0aCAtIGEud2lkdGhcblxuY29uc3QgZ2V0UGFpcnMgPSBtZWFzdXJlcyA9PiBtZWFzdXJlcy5tYXAobWVhc3VyZSA9PiAoe1xuICB3aWR0aDogbWVhc3VyZS5taW5XaWR0aCxcbiAgbWVhc3VyZTogbWVhc3VyZVxufSkpLnNvcnQoZGVzY2VuZGluZ1NvcnQpXG5cbmV4cG9ydCBkZWZhdWx0IFN5c3RlbUxheW91dFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlbmRlcmVyL0xheW91dC9TeXN0ZW1MYXlvdXQuanMiLCJpbXBvcnQgeyBtYXRyaXggfSBmcm9tICdzbmFwc3ZnJ1xuXG5mdW5jdGlvbiByZW5kZXJEb3RzKGVsLCB4LCByYWRpdXMsIG1lYXN1cmVIZWlnaHQpIHtcbiAgY29uc3QgY3kgPSBtZWFzdXJlSGVpZ2h0IC8gMlxuICBjb25zdCBkeSA9IG1lYXN1cmVIZWlnaHQgKiAwLjE1XG5cbiAgZWwuY2lyY2xlKHgsIGN5IC0gZHksIHJhZGl1cylcbiAgZWwuY2lyY2xlKHgsIGN5ICsgZHksIHJhZGl1cylcbn1cblxuZnVuY3Rpb24gcmVuZGVyKGJhciwgbWVhc3VyZSwgbG8pIHtcbiAgY29uc3QgeyBiYXJsaW5lRG90UmFkaXVzIH0gPSBsb1xuICBjb25zdCB7IGhlaWdodCB9ID0gbWVhc3VyZVxuICBjb25zdCBlbCA9IG1lYXN1cmUuZWwuZygpLmFkZENsYXNzKCdtdXMtYmFybGluZScpXG4gIGVsLnVzZShiYXIuZGVmLmVsKS50cmFuc2Zvcm0obWF0cml4KCkuc2NhbGUoMSwgaGVpZ2h0KSlcblxuICBzd2l0Y2ggKGJhci52YWx1ZSkge1xuICAgIGNhc2UgJ3JlcGVhdC1iZWdpbic6XG4gICAgICByZW5kZXJEb3RzKGVsLCBiYXIud2lkdGggLSBiYXJsaW5lRG90UmFkaXVzLCBiYXJsaW5lRG90UmFkaXVzLCBoZWlnaHQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3JlcGVhdC1lbmQnOlxuICAgICAgcmVuZGVyRG90cyhlbCwgYmFybGluZURvdFJhZGl1cywgYmFybGluZURvdFJhZGl1cywgaGVpZ2h0KVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdyZXBlYXQtYm90aCc6XG4gICAgICByZW5kZXJEb3RzKGVsLCBiYXIud2lkdGggLSBiYXJsaW5lRG90UmFkaXVzLCBiYXJsaW5lRG90UmFkaXVzLCBoZWlnaHQpXG4gICAgICByZW5kZXJEb3RzKGVsLCBiYXJsaW5lRG90UmFkaXVzLCBiYXJsaW5lRG90UmFkaXVzLCBoZWlnaHQpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gIH1cblxuICByZXR1cm4gZWxcbn1cblxuY29uc3QgdHJhbnNsYXRlID0gKGVsLCB4KSA9PiB7IGVsLnRyYW5zZm9ybShtYXRyaXgoKS50cmFuc2xhdGUoeCwgMCkpIH1cblxuLy8gQHBhcmFtIG0ge251bWJlcn0gTWVhc3VyZSBpbmRleCBpbiBtZWFzdXJlcy5cbi8vIEBwYXJhbSBsZW4ge251bWJlcn0gTGVuZ3RoIG9mIG1lYXN1cmVzLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVuZGVyQmFyKG1lYXN1cmUsIGxvKSB7XG4gIGxldCBiYXIgPSBtZWFzdXJlLmJhclJpZ2h0SW5TeXN0ZW1cbiAgbGV0IGVsXG5cbiAgaWYgKGJhci5kZWYpIHtcbiAgICBlbCA9IHJlbmRlcihiYXIsIG1lYXN1cmUsIGxvKVxuXG4gICAgLy8gQWxpZ24gZW5kIGluIHN5c3RlbSBlbmQuXG4gICAgaWYgKG1lYXN1cmUuaW5TeXN0ZW1FbmQpIHRyYW5zbGF0ZShlbCwgbWVhc3VyZS53aWR0aCAtIGJhci53aWR0aClcbiAgICAvLyBPdGhlcnMgYWxpZ24gbWlkZGxlLlxuICAgIGVsc2UgdHJhbnNsYXRlKGVsLCBtZWFzdXJlLndpZHRoIC0gYmFyLndpZHRoIC8gMilcbiAgfVxuXG4gIC8vIFJlbmRlciByaWdodCBiYXIgYW5kIGFsaWduIGJlZ2luIGluIHN5c3RlbSBiZWdpbi5cbiAgaWYgKG1lYXN1cmUuaW5TeXN0ZW1CZWdpbikge1xuICAgIGJhciA9IG1lYXN1cmUuYmFyTGVmdEluU3lzdGVtXG4gICAgaWYgKGJhci5kZWYpIHJlbmRlcihiYXIsIG1lYXN1cmUsIGxvKVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVuZGVyZXIvUmVuZGVyZXIvcmVuZGVyQmFyLmpzIiwiaW1wb3J0IHsgbWF0cml4IH0gZnJvbSAnc25hcHN2ZydcblxuZnVuY3Rpb24gcmVuZGVyRHVyYXRpb24obm90ZSwgbG8pIHtcbiAgY29uc3QgeyBkdXJhdGlvbkRlZiwgcGl0Y2hEZWYgfSA9IG5vdGUuZGVmXG4gIGNvbnN0IHsgdW5kZXJiYXIgfSA9IG5vdGUuZHVyYXRpb25cbiAgbGV0IHkgPSAwXG5cbiAgLy8gV2hvbGUgYW5kIGhhbGYgbm90ZXNcbiAgaWYgKG5vdGUuZHVyYXRpb24udHlwZSA8IDQpIHtcbiAgICBub3RlLmVsLnVzZShkdXJhdGlvbkRlZi5lbCkuYXR0cih7XG4gICAgICB4OiBwaXRjaERlZi53aWR0aCxcbiAgICAgIHk6IHBpdGNoRGVmLnN0ZXBDeVxuICAgIH0pXG5cbiAgLy8gUXVhcnRlciBvciBzaG9ydGVyIG5vdGVzXG4gIH0gZWxzZSB7XG5cbiAgICAvLyBBZGQgdW5kZXJiYXJzIGZvciBlaWd0aCBvciBzaG9ydGVyIG5vdGVzXG4gICAgaWYgKHVuZGVyYmFyKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVuZGVyYmFyOyBpKyspIHtcblxuICAgICAgICAvLyBPbmx5IHJlbmRlciBiZWFtIGZvciB0aGUgYmVnaW4gb25lLlxuICAgICAgICBpZiAobm90ZS5iZWFtc1tpXSkge1xuICAgICAgICAgIGlmIChub3RlLmJlYW1zW2ldLnZhbHVlID09PSAnYmVnaW4nKSB7XG5cbiAgICAgICAgICAgICAgLy8gcmVuZGVyIHRoZSBiYXIgZnJvbSB0aGUgYmVnaW5uaW5nIG5vdGUgdG8gdGhlIGVuZGluZyBub3RlIGFzc29jaWF0ZWRcbiAgICAgICAgICAgICAgLy8gd2l0aCB0aGUgYmVnaW5uaW5nIG5vdGUuIFkgc3RhbmRzIGZvciB0aGUgc3RhcnRpbmcgaGVpZ2h0LlxuICAgICAgICAgICAgcmVuZGVyVW5kZXJiYXIobm90ZSwgbm90ZS5iZWFtc1tpXS5lbmREdXJhYmxlLCB5LCBsbylcbiAgICAgICAgICB9XG5cbiAgICAgICAgLy8gVW5iZWFtZWQgdW5kZXJiYXJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vcmVuZGVycyBzaW5nbGUgbm90ZVxuICAgICAgICAgIHJlbmRlclVuZGVyYmFyKG5vdGUsIG5vdGUsIHksIGxvKVxuICAgICAgICB9XG4gICAgICAgIHkgLT0gbG8udW5kZXJiYXJTZXBcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgZG90c1xuICAgIGlmIChub3RlLmR1cmF0aW9uLmRvdCkge1xuICAgICAgbm90ZS5lbC5nKCkudHJhbnNmb3JtKG1hdHJpeCgpLnRyYW5zbGF0ZShwaXRjaERlZi53aWR0aCwgMCkpXG4gICAgICAgIC51c2UoZHVyYXRpb25EZWYuZWwpLnRyYW5zZm9ybShwaXRjaERlZi5tYXRyaXgpXG4gICAgfVxuXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyVW5kZXJiYXIobm90ZTEsIG5vdGUyLCB5LCBsbykge1xuICBub3RlMS5lbC5saW5lKDAsIHksIG5vdGUyLnggLSBub3RlMS54ICsgbm90ZTIud2lkdGgsIHkpXG4gICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgbG8udHlwZVN0cm9rZVdpZHRoKVxufVxuXG5leHBvcnQgZGVmYXVsdCByZW5kZXJEdXJhdGlvblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlbmRlcmVyL1JlbmRlcmVyL3JlbmRlckR1cmF0aW9uLmpzIiwiaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAnc25hcHN2ZydcblxuZnVuY3Rpb24gZ2V0Q3VydmVQYXRoKHgxLCB5MSwgeDIsIHkyKSB7XG4gIGNvbnN0IGR4ID0geDIgLSB4MVxuICBjb25zdCBkeSA9IHkyIC0geTFcbiAgY29uc3QgYzF4ID0gMCAvLy0wLjEgKiBkeFxuICBjb25zdCBjMXkgPSAwIC8vLTAuMSAqIGR5XG4gIGNvbnN0IGMyeCA9IGR4IC8vMS4xICogZHhcbiAgY29uc3QgYzJ5ID0gZHkgLy8xLjEgKiBkeVxuXG4gIHJldHVybiBmb3JtYXQoJ017eDF9LHt5MX1je2MxeH0se2MxeX0ge2MyeH0se2MyeX0ge2R4fSx7ZHl9Y3tjM3h9LHtjM3l9IHtjNHh9LHtjNHl9IHtuZWdEeH0se25lZ0R5fScsIHtcbiAgICB4MSxcbiAgICB5MSxcbiAgICBjMXgsXG4gICAgYzF5OiBjMXkgLSA4LFxuICAgIGMyeCxcbiAgICBjMnk6IGMyeSAtIDgsXG4gICAgZHgsXG4gICAgZHksXG4gICAgYzN4OiAtYzF4LFxuICAgIGMzeTogLWMxeSAtIDEwLFxuICAgIGM0eDogLWMyeCxcbiAgICBjNHk6IC1jMnkgLSAxMCxcbiAgICBuZWdEeDogLWR4LFxuICAgIG5lZ0R5OiAtZHlcbiAgfSlcbn1cblxuZnVuY3Rpb24gcmVuZGVyRW5kQ3VydmUobm90ZSwgZXJyb3IpIHtcbiAgY29uc3QgeyBzdGVwQ3g6IHgxLCBzdGVwVG9wOiB5MSB9ID0gbm90ZS5kZWYucGl0Y2hEZWZcbiAgY29uc3QgeDIgPSAtIG5vdGUuc3lzdGVtWCAtIDNcbiAgY29uc3QgZWwgPSBub3RlLmVsLnBhdGgoZ2V0Q3VydmVQYXRoKHgxLCB5MSwgeDIsIHkxIC0gMykpXG5cbiAgaWYgKGVycm9yKSBlbC5hZGRDbGFzcygnbXVzLWVycm9yJylcbiAgcmV0dXJuIGVsXG59XG5cbmZ1bmN0aW9uIHJlbmRlckJlZ2luQ3VydmUobm90ZSwgZXJyb3IpIHtcbiAgY29uc3QgeyBzdGVwQ3g6IHgxLCBzdGVwVG9wOiB5MSB9ID0gbm90ZS5kZWYucGl0Y2hEZWZcbiAgY29uc3QgeDIgPSBub3RlLnN5c3RlbS53aWR0aCAtIG5vdGUuc3lzdGVtWCArIDNcbiAgY29uc3QgZWwgPSBub3RlLmVsLnBhdGgoZ2V0Q3VydmVQYXRoKHgxLCB5MSwgeDIsIHkxIC0gMykpXG5cbiAgaWYgKGVycm9yKSBlbC5hZGRDbGFzcygnbXVzLWVycm9yJylcbiAgcmV0dXJuIGVsXG59XG5cbmZ1bmN0aW9uIHJlbmRlckNvbXBsZXRlQ3VydmUobm90ZTEsIG5vdGUyLCBlcnJvcikge1xuICBjb25zdCB7IHN0ZXBDeDogeDEsIHN0ZXBUb3A6IHkxIH0gPSBub3RlMS5kZWYucGl0Y2hEZWZcbiAgY29uc3QgeyBzdGVwQ3g6IHgyLCBzdGVwVG9wOiB5MiB9ID0gbm90ZTIuZGVmLnBpdGNoRGVmXG4gIGNvbnN0IG5vdGVEeCA9IG5vdGUyLnN5c3RlbVggLSBub3RlMS5zeXN0ZW1YXG4gIGNvbnN0IGVsID0gbm90ZTEuZWwucGF0aChnZXRDdXJ2ZVBhdGgoeDEsIHkxLCBub3RlRHggKyB4MiwgeTIpKVxuXG4gIGlmIChlcnJvcikgZWwuYWRkQ2xhc3MoJ211cy1lcnJvcicpXG4gIHJldHVybiBlbFxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZW5kZXJDdXJ2ZSh0eXBlLCBub3RlKSB7XG4gIGlmIChub3RlW3R5cGVdLmVuZCkge1xuICAgIGNvbnN0IHByZXYgPSBub3RlW3R5cGVdLnByZXZQYXJlbnRcbiAgICBjb25zdCB7IHByZXZIYXNFcnJvciB9ID0gbm90ZVt0eXBlXVxuXG4gICAgaWYgKCFwcmV2IHx8IHByZXYuc3lzdGVtICE9PSBub3RlLnN5c3RlbSkgcmVuZGVyRW5kQ3VydmUobm90ZSwgcHJldkhhc0Vycm9yKVxuICAgIGVsc2UgaWYgKHByZXZIYXNFcnJvcikgcmVuZGVyQ29tcGxldGVDdXJ2ZShub3RlLCBwcmV2LCBwcmV2SGFzRXJyb3IpXG4gIH1cblxuICBpZiAobm90ZVt0eXBlXS5iZWdpbikge1xuICAgIGNvbnN0IG5leHQgPSBub3RlW3R5cGVdLm5leHRQYXJlbnRcbiAgICBjb25zdCB7IG5leHRIYXNFcnJvciB9ID0gbm90ZVt0eXBlXVxuXG4gICAgaWYgKCFuZXh0IHx8IG5leHQuc3lzdGVtICE9PSBub3RlLnN5c3RlbSkgcmVuZGVyQmVnaW5DdXJ2ZShub3RlLCBuZXh0SGFzRXJyb3IpXG4gICAgZWxzZSByZW5kZXJDb21wbGV0ZUN1cnZlKG5vdGUsIG5leHQsIG5leHRIYXNFcnJvcilcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlbmRlcmVyL1JlbmRlcmVyL3JlbmRlckN1cnZlLmpzIiwiaW1wb3J0IE1JREkgZnJvbSAnTUlESSdcblxuY29uc3QgdGltZW91dHMgPSBbXVxuXG5jb25zdCBQbGF5ZXJNaXhpbiA9IHtcblxuICAvKipcbiAgICogU3RhcnQgcGxheWluZyB0aGUgc29uZy5cbiAgICovXG4gIHBsYXkoKSB7XG4gICAgY29uc3QgeyBtZWFzdXJlcyB9ID0gdGhpcy5wYXJ0c1swXVxuICAgIHZhciB0aW1lID0gMCAvL2F1ZGlvQ3R4LmN1cnJlbnRUaW1lXG5cbiAgICBtZWFzdXJlcy5mb3JFYWNoKGNlbGwgPT4ge1xuICAgICAgY2VsbC5kYXRhLmZvckVhY2goZGF0YSA9PiB7XG4gICAgICAgIHN3aXRjaCAoZGF0YS4kdHlwZSkge1xuICAgICAgICAgIGNhc2UgJ25vdGUnOlxuICAgICAgICAgICAgLy8gcGxheU5vdGUodGltZSwgZHVyLCBmcmVxKVxuICAgICAgICAgICAgdGltZW91dHMucHVzaChtaWRpUGxheU5vdGUoZGF0YSwgdGltZSkpXG4gICAgICAgICAgICB0aW1lICs9IGRhdGEuZHVyYXRpb24uc2Vjb25kXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgJ3Jlc3QnOlxuICAgICAgICAgICAgdGltZSArPSBkYXRhLmR1cmF0aW9uLnNlY29uZFxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0b3AgcGxheWluZyB0aGUgc29uZy5cbiAgICovXG4gIHN0b3AoKSB7XG4gICAgdGltZW91dHMuZm9yRWFjaCh0aW1lb3V0ID0+IHsgY2xlYXJUaW1lb3V0KHRpbWVvdXQpIH0pXG4gICAgdGltZW91dHMubGVuZ3RoID0gMFxuICB9XG59XG5cbi8vIGlmICh3aW5kb3cuQXVkaW9Db250ZXh0KSB7XG4vLyAgIHZhciBhdWRpb0N0eCA9IG5ldyB3aW5kb3cuQXVkaW9Db250ZXh0KClcbi8vICAgdmFyIGdhaW5Ob2RlID0gYXVkaW9DdHguY3JlYXRlR2FpbigpXG4vLyAgIGdhaW5Ob2RlLmNvbm5lY3QoYXVkaW9DdHguZGVzdGluYXRpb24pXG4vLyAgIGdhaW5Ob2RlLmdhaW4udmFsdWUgPSAwLjUgIC8vIHNldCB0aGUgdm9sdW1lXG4vLyB9XG5cbi8vIC8vIHZhciBvc2NpbGxhdG9yID0gYXVkaW9DdHguY3JlYXRlT3NjaWxsYXRvcigpXG4vLyAvLyBvc2NpbGxhdG9yLmNvbm5lY3QoZ2Fpbk5vZGUpXG4vLyAvLyBvc2NpbGxhdG9yLnR5cGUgPSAnc3F1YXJlJyAvLyBzaW5lIHwgc3F1YXJlIHwgc2F3dG9vdGggfCB0cmlhbmdsZSB8IGN1c3RvbVxuXG4vLyBmdW5jdGlvbiBwbGF5Tm90ZSh0aW1lLCBkdXIsIGZyZXEpIHtcbi8vICAgaWYgKCFhdWRpb0N0eCkgeyByZXR1cm4gfVxuXG4vLyAgIHZhciBvc2NpbGxhdG9yID0gYXVkaW9DdHguY3JlYXRlT3NjaWxsYXRvcigpXG4vLyAgIG9zY2lsbGF0b3IudHlwZSA9ICdzaW5lJ1xuLy8gICBvc2NpbGxhdG9yLmNvbm5lY3QoYXVkaW9DdHguZGVzdGluYXRpb24pXG4vLyAgIG9zY2lsbGF0b3IuZnJlcXVlbmN5LnZhbHVlID0gZnJlcVxuLy8gICBvc2NpbGxhdG9yLnN0YXJ0KHRpbWUpXG4vLyAgIG9zY2lsbGF0b3Iuc3RvcCh0aW1lICsgZHVyIC0gMC4wNSlcbi8vIH1cblxuZnVuY3Rpb24gbWlkaVBsYXlOb3RlKG5vdGUsIHRpbWUpIHtcbiAgY29uc3QgeyBtaWRpTnVtYmVyIH0gPSBub3RlLnBpdGNoXG4gIGNvbnN0IGR1ciA9IG5vdGUuZHVyYXRpb24uc2Vjb25kXG5cbiAgZnVuY3Rpb24gcGxheSgpIHtcbiAgICBpZiAoIW5vdGUudGllLnByZXZQYXJlbnQgfHwgbm90ZS50aWUucHJldkhhc0Vycm9yKSB7XG4gICAgICBNSURJLm5vdGVPbigwLCBtaWRpTnVtYmVyLCAxMDAsIDApXG4gICAgfVxuICAgIGlmICghbm90ZS50aWUubmV4dFBhcmVudCB8fCBub3RlLnRpZS5uZXh0SGFzRXJyb3IpIHtcbiAgICAgIE1JREkubm90ZU9mZigwLCBtaWRpTnVtYmVyLCBkdXIpXG4gICAgfVxuICAgIG5vdGUuZWwuYWRkQ2xhc3MoJ211cy1wbGF5aW5nJylcbiAgICBzZXRUaW1lb3V0KCgpID0+IHsgbm90ZS5lbC5yZW1vdmVDbGFzcygnbXVzLXBsYXlpbmcnKSB9LCBkdXIgKiA4MDAgKyAxMDApXG4gICAgY29uc29sZS5sb2coJ1BsYXk6ICcgKyBub3RlLCB0aW1lLCBkdXIsIG1pZGlOdW1iZXIpXG4gIH1cblxuICByZXR1cm4gc2V0VGltZW91dChwbGF5LCB0aW1lICogODAwKVxufVxuXG5leHBvcnQgZGVmYXVsdCBQbGF5ZXJNaXhpblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BsYXllci9QbGF5ZXJNaXhpbi5qcyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV80Ml9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiTUlESVwiXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9