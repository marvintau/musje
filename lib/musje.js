(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("snapsvg"), require("MIDI"));
	else if(typeof define === 'function' && define.amd)
		define(["snapsvg", "MIDI"], factory);
	else if(typeof exports === 'object')
		exports["musje"] = factory(require("snapsvg"), require("MIDI"));
	else
		root["musje"] = factory(root["Snap"], root["MIDI"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_8__, __WEBPACK_EXTERNAL_MODULE_42__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Score = exports.parse = undefined;
	
	var _parser = __webpack_require__(1);
	
	var _parser2 = _interopRequireDefault(_parser);
	
	var _Score = __webpack_require__(3);
	
	var _Score2 = _interopRequireDefault(_Score);
	
	var _Renderer = __webpack_require__(23);
	
	var _Renderer2 = _interopRequireDefault(_Renderer);
	
	var _util = __webpack_require__(2);
	
	var _PlayerMixin = __webpack_require__(41);
	
	var _PlayerMixin2 = _interopRequireDefault(_PlayerMixin);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Render the score in jianpu (numbered musical notation).
	 * @member
	 * @function
	 * @param {string} svg
	 * @param {Object} lo - Layout options.
	 */
	_Score2.default.prototype.render = function (svg, lo) {
	  new _Renderer2.default(svg, lo).render(this);
	};
	
	(0, _util.defineProperties)(_Score2.default.prototype, _PlayerMixin2.default);
	
	/**
	 * Parse source musje string to be a Score instance.
	 * @param {string} input - Input of the musje source code.
	 * @return {Score} - A `Score` instance.
	 */
	var parse = exports.parse = function parse(input) {
	  return _parser2.default.parse(input);
	  // var plainScore = parser.parse(input);
	  // return new Score(plainScore);
	};
	
	exports.Score = _Score2.default;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* parser generated by jison 0.4.17 */
	/*
	  Returns a Parser object of the following structure:
	
	  Parser: {
	    yy: {}
	  }
	
	  Parser.prototype: {
	    yy: {},
	    trace: function(),
	    symbols_: {associative list: name ==> number},
	    terminals_: {associative list: number ==> name},
	    productions_: [...],
	    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
	    table: [...],
	    defaultActions: {...},
	    parseError: function(str, hash),
	    parse: function(input),
	
	    lexer: {
	        EOF: 1,
	        parseError: function(str, hash),
	        setInput: function(input),
	        input: function(),
	        unput: function(str),
	        more: function(),
	        less: function(n),
	        pastInput: function(),
	        upcomingInput: function(),
	        showPosition: function(),
	        test_match: function(regex_match_array, rule_index),
	        next: function(),
	        lex: function(),
	        begin: function(condition),
	        popState: function(),
	        _currentRules: function(),
	        topState: function(),
	        pushState: function(condition),
	
	        options: {
	            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
	            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
	            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
	        },
	
	        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
	        rules: [...],
	        conditions: {associative list: name ==> set},
	    }
	  }
	
	
	  token location info (@$, _$, etc.): {
	    first_line: n,
	    last_line: n,
	    first_column: n,
	    last_column: n,
	    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
	  }
	
	
	  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
	    text:        (matched text)
	    token:       (the produced terminal token, if any)
	    line:        (yylineno)
	  }
	  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
	    loc:         (yylloc)
	    expected:    (string describing the set of expected tokens)
	    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
	  }
	*/
	var parser = (function(){
	var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,11],$V1=[1,15],$V2=[1,16],$V3=[1,17],$V4=[1,18],$V5=[1,19],$V6=[1,20],$V7=[1,23],$V8=[1,27],$V9=[1,34],$Va=[1,35],$Vb=[1,33],$Vc=[1,28],$Vd=[1,29],$Ve=[5,9,10,14,21,22,23,24,25,26,29,34,39,41,48,51,58],$Vf=[2,8],$Vg=[5,9,10,21,22,23,24,25,26,29,34,39,41,48,51,58],$Vh=[5,21,22,23,24,25,26],$Vi=[2,47],$Vj=[1,48],$Vk=[1,49],$Vl=[1,50],$Vm=[1,51],$Vn=[1,52],$Vo=[5,9,10,21,22,23,24,25,26,28,29,34,35,39,41,48,51,53,58],$Vp=[5,9,10,21,22,23,24,25,26,28,29,34,35,39,41,43,44,45,46,47,48,51,53,58],$Vq=[5,9,10,21,22,23,24,25,26,28,29,34,35,39,41,43,44,45,46,47,48,50,51,53,58],$Vr=[1,63],$Vs=[1,64],$Vt=[5,21,22,23,24,25,26,29,34,39,41,48,51,58],$Vu=[5,9,10,21,22,23,24,25,26,28,29,34,35,39,41,43,48,51,53,58],$Vv=[5,9,10,21,22,23,24,25,26,28,29,34,39,41,48,51,53,58],$Vw=[39,41,50];
	var parser = {trace: function trace() { },
	yy: {},
	symbols_: {"0":29,"error":2,"e":3,"maybe_musje":4,"EOF":5,"space":6,"maybe_space":7,"musje":8,"S":9,"NL":10,"score_head":11,"part_list":12,"title":13,"TITLE":14,"COMPOSER":15,"part":16,"measure_list":17,"bar":18,"measure":19,"music_data":20,"|":21,"||":22,"|]":23,"|:":24,":|":25,":|:":26,"slurable":27,"TIE":28,"maybe_duration":30,"voice":31,"time_signature":32,"pitchful":33,"(":34,")":35,"note":36,"chord":37,"pitch":38,"STEP":39,"OCTAVE":40,"ACCIDENTAL":41,"type_modifier":42,"DOT":43,"_":44,"=":45,"HALF":46,"WHOLE":47,"<":48,"pitch_list":49,">":50,"{":51,"voice_list":52,"}":53,"voice_data_list":54,":":55,"voice_data":56,"restslurable_list":57,"BEATS":58,"BEAT_TYPE":59,"$accept":0,"$end":1},
	terminals_: {2:"error",5:"EOF",9:"S",10:"NL",14:"TITLE",15:"COMPOSER",21:"|",22:"||",23:"|]",24:"|:",25:":|",26:":|:",28:"TIE",29:"0",34:"(",35:")",39:"STEP",40:"OCTAVE",41:"ACCIDENTAL",43:"DOT",44:"_",45:"=",46:"HALF",47:"WHOLE",48:"<",50:">",51:"{",53:"}",54:"voice_data_list",55:":",57:"restslurable_list",58:"BEATS",59:"BEAT_TYPE"},
	productions_: [0,[3,2],[4,0],[4,2],[4,3],[4,1],[6,1],[6,1],[7,0],[7,2],[7,2],[8,1],[8,1],[8,2],[11,2],[13,1],[13,2],[12,1],[16,1],[16,3],[17,1],[17,4],[17,3],[19,2],[19,3],[18,1],[18,1],[18,1],[18,1],[18,1],[18,1],[20,1],[20,2],[20,2],[20,1],[20,1],[27,2],[27,3],[27,3],[27,4],[33,1],[33,1],[36,1],[38,1],[38,2],[38,2],[38,3],[30,0],[30,1],[30,1],[30,2],[42,1],[42,1],[42,2],[42,2],[42,3],[42,3],[42,1],[42,1],[37,3],[49,1],[49,2],[31,3],[52,1],[52,3],[56,1],[56,2],[32,2]],
	performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
	/* this == yyval */
	
	var $0 = $$.length - 1;
	switch (yystate) {
	case 1:
	 return $$[$0-1]; 
	break;
	case 2: case 3:
	 this.$ = null; 
	break;
	case 4: case 5:
	 this.$ = $$[$0]; removeLastEmptyMeasure($$[$0]); 
	break;
	case 10:
	 this.$ = $$[$0-1] ? $$[$0-1] + 1 : 1; 
	break;
	case 11:
	this.$ = { head: $$[$0] };
	break;
	case 12:
	this.$ = { parts: $$[$0] };
	break;
	case 13:
	this.$ = { head: $$[$0-1], parts: $$[$0] };
	break;
	case 15:
	 this.$ = { title: $$[$0] } 
	break;
	case 16:
	 this.$ =  { title: $$[$0-1], composer: $$[$0] } 
	break;
	case 17: case 60: case 63:
	this.$ = [$$[$0]];
	break;
	case 18:
	this.$ = { measures: $$[$0] };
	break;
	case 19:
	 this.$ = { measures: $$[$0]}; $$[$0][0].data.unshift({ bar: $$[$0-2] }); 
	break;
	case 20:
	 this.$ = [$$[$0]]; 
	break;
	case 21:
	 this.$ = $$[$0-3]; lastItem($$[$0-3]).data.push({ bar: $$[$0-2] }); $$[$0-3].push($$[$0]) 
	break;
	case 22:
	 this.$ = $$[$0-2]; lastItem($$[$0-2]).data.push({ bar: $$[$0-1] }); $$[$0-2].push({ data: [] }) 
	break;
	case 23:
	this.$ = { data: [$$[$0-1]] };
	break;
	case 24:
	 this.$ = $$[$0-2]; $$[$0-2].data.push($$[$0-1]) 
	break;
	case 25:
	this.$ = 'single';
	break;
	case 26:
	this.$ = 'double';
	break;
	case 27:
	this.$ = 'end';
	break;
	case 28:
	this.$ = 'repeat-begin';
	break;
	case 29:
	this.$ = 'repeat-end';
	break;
	case 30:
	this.$ = 'repeat-both';
	break;
	case 32:
	 this.$ = $$[$0-1]; onlyProperty($$[$0-1]).tie = '~' 
	break;
	case 33:
	this.$ = { rest: { duration: $$[$0] } };
	break;
	case 34:
	this.$ = { voice: $$[$0] };
	break;
	case 36:
	 this.$ = $$[$0-1]; onlyProperty($$[$0-1]).duration = $$[$0] 
	break;
	case 37:
	
	      this.$ = $$[$0-1];
	      extend(onlyProperty($$[$0-1]), {
	        duration: $$[$0],
	        slur: { begin: 'solid' }
	      })
	    
	break;
	case 38:
	
	      this.$ = $$[$0-2]
	      extend(onlyProperty($$[$0-2]), {
	        duration: $$[$0-1],
	        slur: { end: 'solid' }
	      })
	    
	break;
	case 39:
	
	      this.$ = $$[$0-2]
	      extend(onlyProperty($$[$0-2]), {
	        duration: $$[$0-1],
	        slur: { begin: 'solid', end: 'solid' }
	      })
	    
	break;
	case 40:
	this.$ = { note: $$[$0] };
	break;
	case 41:
	this.$ = { chord: $$[$0] };
	break;
	case 42:
	this.$ = { pitch: $$[$0] };
	break;
	case 43:
	this.$ = { step: +$$[$0] };
	break;
	case 44:
	this.$ = { step: +$$[$0-1], octave: octave($$[$0]) };
	break;
	case 45:
	this.$ = { accidental: $$[$0-1], step: +$$[$0] };
	break;
	case 46:
	this.$ = { accidental: $$[$0-2], step: +$$[$0-1], octave: octave($$[$0]) };
	break;
	case 48:
	this.$ = { type: $$[$0] };
	break;
	case 49:
	this.$ = { type: 4, dot: $$[$0].length };
	break;
	case 50:
	this.$ = { type: $$[$0-1], dot: $$[$0].length };
	break;
	case 51:
	this.$ = 8;
	break;
	case 52:
	this.$ = 16;
	break;
	case 53:
	this.$ = 32;
	break;
	case 54:
	this.$ = 64;
	break;
	case 55:
	this.$ = 128;
	break;
	case 56:
	this.$ = 256;
	break;
	case 57:
	this.$ = 2;
	break;
	case 58:
	this.$ = 1;
	break;
	case 59:
	this.$ = { pitches: $$[$0-1] };
	break;
	case 61: case 66:
	 this.$ = $$[$0-1]; $$[$0-1].push($$[$0]) 
	break;
	case 62:
	this.$ = $$[$0-1];
	break;
	case 64:
	 this.$ = $$[$0-2]; $$[$0-2].push($$[$0-1]) 
	break;
	case 67:
	this.$ = { time: { beats: +$$[$0-1], beatType: +$$[$0] } };
	break;
	}
	},
	table: [{3:1,4:2,5:[2,2],6:3,8:4,9:[1,5],10:[1,6],11:7,12:8,13:9,14:$V0,16:10,17:12,18:13,19:14,20:21,21:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6,27:22,29:$V7,31:24,32:25,33:26,34:$V8,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd},{1:[3]},{5:[1,36]},o($Ve,$Vf,{7:37}),{5:[2,5]},o($Ve,[2,6]),o($Ve,[2,7]),{5:[2,11],12:38,16:10,17:12,18:13,19:14,20:21,21:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6,27:22,29:$V7,31:24,32:25,33:26,34:$V8,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd},{5:[2,12]},o($Vg,$Vf,{7:39}),{5:[2,17]},o($Vg,[2,15],{15:[1,40]}),{5:[2,18],18:41,21:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6},o([9,10,29,34,39,41,48,51,58],$Vf,{7:42}),o($Vh,[2,20],{27:22,31:24,32:25,33:26,36:30,37:31,38:32,20:43,29:$V7,34:$V8,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd}),o($Vg,[2,25]),o($Vg,[2,26]),o($Vg,[2,27]),o($Vg,[2,28]),o($Vg,[2,29]),o($Vg,[2,30]),o($Vg,$Vf,{7:44}),o($Vg,[2,31],{28:[1,45]}),o($Vg,$Vi,{30:46,42:47,43:$Vj,44:$Vk,45:$Vl,46:$Vm,47:$Vn}),o($Vg,[2,34]),o($Vg,[2,35]),o($Vo,$Vi,{42:47,30:53,43:$Vj,44:$Vk,45:$Vl,46:$Vm,47:$Vn}),{33:54,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb},{52:55,54:[1,56]},{59:[1,57]},o($Vp,[2,40]),o($Vp,[2,41]),o($Vp,[2,42]),{38:59,39:$V9,41:$Va,49:58},o($Vq,[2,43],{40:[1,60]}),{39:[1,61]},{1:[2,1]},{5:[2,3],8:62,9:$Vr,10:$Vs,11:7,12:8,13:9,14:$V0,16:10,17:12,18:13,19:14,20:21,21:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6,27:22,29:$V7,31:24,32:25,33:26,34:$V8,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd},{5:[2,13]},o($Vt,[2,14],{9:$Vr,10:$Vs}),o($Vg,[2,16]),o($Vg,$Vf,{7:65}),{9:$Vr,10:$Vs,17:66,19:14,20:21,27:22,29:$V7,31:24,32:25,33:26,34:$V8,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd},o($Vg,$Vf,{7:67}),o($Vt,[2,23],{9:$Vr,10:$Vs}),o($Vg,[2,32]),o($Vg,[2,33]),o($Vo,[2,48],{43:[1,68]}),o($Vo,[2,49]),o($Vu,[2,51]),o($Vu,[2,52],{44:[1,69],45:[1,70]}),o($Vu,[2,57]),o($Vu,[2,58]),o($Vv,[2,36],{35:[1,71]}),o($Vo,$Vi,{42:47,30:72,43:$Vj,44:$Vk,45:$Vl,46:$Vm,47:$Vn}),{53:[1,73]},{53:[2,63],55:[1,74]},o($Vg,[2,67]),{38:76,39:$V9,41:$Va,50:[1,75]},o($Vw,[2,60]),o($Vq,[2,44]),o($Vq,[2,45],{40:[1,77]}),{5:[2,4]},o($Ve,[2,9]),o($Ve,[2,10]),o($Vh,[2,22],{20:21,27:22,31:24,32:25,33:26,36:30,37:31,38:32,19:78,9:$Vr,10:$Vs,29:$V7,34:$V8,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd}),{5:[2,19],18:41,21:$V1,22:$V2,23:$V3,24:$V4,25:$V5,26:$V6},o($Vt,[2,24],{9:$Vr,10:$Vs}),o($Vo,[2,50]),o($Vu,[2,53]),o($Vu,[2,54],{44:[1,79],45:[1,80]}),o($Vv,[2,38]),o($Vv,[2,37],{35:[1,81]}),o($Vg,[2,62]),{27:83,33:26,34:$V8,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb,56:82,57:[1,84]},o($Vp,[2,59]),o($Vw,[2,61]),o($Vq,[2,46]),o($Vh,[2,21],{27:22,31:24,32:25,33:26,36:30,37:31,38:32,20:43,29:$V7,34:$V8,39:$V9,41:$Va,48:$Vb,51:$Vc,58:$Vd}),o($Vu,[2,55]),o($Vu,[2,56]),o($Vv,[2,39]),{53:[2,64]},{53:[2,65]},{27:85,33:26,34:$V8,36:30,37:31,38:32,39:$V9,41:$Va,48:$Vb},{53:[2,66]}],
	defaultActions: {4:[2,5],8:[2,12],10:[2,17],36:[2,1],38:[2,13],62:[2,4],82:[2,64],83:[2,65],85:[2,66]},
	parseError: function parseError(str, hash) {
	    if (hash.recoverable) {
	        this.trace(str);
	    } else {
	        function _parseError (msg, hash) {
	            this.message = msg;
	            this.hash = hash;
	        }
	        _parseError.prototype = Error;
	
	        throw new _parseError(str, hash);
	    }
	},
	parse: function parse(input) {
	    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
	    var args = lstack.slice.call(arguments, 1);
	    var lexer = Object.create(this.lexer);
	    var sharedState = { yy: {} };
	    for (var k in this.yy) {
	        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
	            sharedState.yy[k] = this.yy[k];
	        }
	    }
	    lexer.setInput(input, sharedState.yy);
	    sharedState.yy.lexer = lexer;
	    sharedState.yy.parser = this;
	    if (typeof lexer.yylloc == 'undefined') {
	        lexer.yylloc = {};
	    }
	    var yyloc = lexer.yylloc;
	    lstack.push(yyloc);
	    var ranges = lexer.options && lexer.options.ranges;
	    if (typeof sharedState.yy.parseError === 'function') {
	        this.parseError = sharedState.yy.parseError;
	    } else {
	        this.parseError = Object.getPrototypeOf(this).parseError;
	    }
	    function popStack(n) {
	        stack.length = stack.length - 2 * n;
	        vstack.length = vstack.length - n;
	        lstack.length = lstack.length - n;
	    }
	    _token_stack:
	        var lex = function () {
	            var token;
	            token = lexer.lex() || EOF;
	            if (typeof token !== 'number') {
	                token = self.symbols_[token] || token;
	            }
	            return token;
	        };
	    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
	    while (true) {
	        state = stack[stack.length - 1];
	        if (this.defaultActions[state]) {
	            action = this.defaultActions[state];
	        } else {
	            if (symbol === null || typeof symbol == 'undefined') {
	                symbol = lex();
	            }
	            action = table[state] && table[state][symbol];
	        }
	                    if (typeof action === 'undefined' || !action.length || !action[0]) {
	                var errStr = '';
	                expected = [];
	                for (p in table[state]) {
	                    if (this.terminals_[p] && p > TERROR) {
	                        expected.push('\'' + this.terminals_[p] + '\'');
	                    }
	                }
	                if (lexer.showPosition) {
	                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
	                } else {
	                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
	                }
	                this.parseError(errStr, {
	                    text: lexer.match,
	                    token: this.terminals_[symbol] || symbol,
	                    line: lexer.yylineno,
	                    loc: yyloc,
	                    expected: expected
	                });
	            }
	        if (action[0] instanceof Array && action.length > 1) {
	            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
	        }
	        switch (action[0]) {
	        case 1:
	            stack.push(symbol);
	            vstack.push(lexer.yytext);
	            lstack.push(lexer.yylloc);
	            stack.push(action[1]);
	            symbol = null;
	            if (!preErrorSymbol) {
	                yyleng = lexer.yyleng;
	                yytext = lexer.yytext;
	                yylineno = lexer.yylineno;
	                yyloc = lexer.yylloc;
	                if (recovering > 0) {
	                    recovering--;
	                }
	            } else {
	                symbol = preErrorSymbol;
	                preErrorSymbol = null;
	            }
	            break;
	        case 2:
	            len = this.productions_[action[1]][1];
	            yyval.$ = vstack[vstack.length - len];
	            yyval._$ = {
	                first_line: lstack[lstack.length - (len || 1)].first_line,
	                last_line: lstack[lstack.length - 1].last_line,
	                first_column: lstack[lstack.length - (len || 1)].first_column,
	                last_column: lstack[lstack.length - 1].last_column
	            };
	            if (ranges) {
	                yyval._$.range = [
	                    lstack[lstack.length - (len || 1)].range[0],
	                    lstack[lstack.length - 1].range[1]
	                ];
	            }
	            r = this.performAction.apply(yyval, [
	                yytext,
	                yyleng,
	                yylineno,
	                sharedState.yy,
	                action[1],
	                vstack,
	                lstack
	            ].concat(args));
	            if (typeof r !== 'undefined') {
	                return r;
	            }
	            if (len) {
	                stack = stack.slice(0, -1 * len * 2);
	                vstack = vstack.slice(0, -1 * len);
	                lstack = lstack.slice(0, -1 * len);
	            }
	            stack.push(this.productions_[action[1]][0]);
	            vstack.push(yyval.$);
	            lstack.push(yyval._$);
	            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
	            stack.push(newState);
	            break;
	        case 3:
	            return true;
	        }
	    }
	    return true;
	}};
	
	
	const extend = __webpack_require__(2).extend
	
	const lastItem = arr => arr[arr.length - 1]
	
	const onlyProperty = obj => obj[Object.keys(obj)[0]]
	
	const octave = str => {
	  const len = str.length
	  return str.charAt(0) === ',' ? -len : len
	}
	
	const removeLastEmptyMeasure = score => {
	  const parts = score.parts
	  if (!parts) return
	
	  parts.forEach(part => {
	    const lastMeasure = lastItem(part.measures)
	    if (lastMeasure.data.length === 0) part.measures.pop()
	  })
	}
	
	/* generated by jison-lex 0.3.4 */
	var lexer = (function(){
	var lexer = ({
	
	EOF:1,
	
	parseError:function parseError(str, hash) {
	        if (this.yy.parser) {
	            this.yy.parser.parseError(str, hash);
	        } else {
	            throw new Error(str);
	        }
	    },
	
	// resets the lexer, sets new input
	setInput:function (input, yy) {
	        this.yy = yy || this.yy || {};
	        this._input = input;
	        this._more = this._backtrack = this.done = false;
	        this.yylineno = this.yyleng = 0;
	        this.yytext = this.matched = this.match = '';
	        this.conditionStack = ['INITIAL'];
	        this.yylloc = {
	            first_line: 1,
	            first_column: 0,
	            last_line: 1,
	            last_column: 0
	        };
	        if (this.options.ranges) {
	            this.yylloc.range = [0,0];
	        }
	        this.offset = 0;
	        return this;
	    },
	
	// consumes and returns one char from the input
	input:function () {
	        var ch = this._input[0];
	        this.yytext += ch;
	        this.yyleng++;
	        this.offset++;
	        this.match += ch;
	        this.matched += ch;
	        var lines = ch.match(/(?:\r\n?|\n).*/g);
	        if (lines) {
	            this.yylineno++;
	            this.yylloc.last_line++;
	        } else {
	            this.yylloc.last_column++;
	        }
	        if (this.options.ranges) {
	            this.yylloc.range[1]++;
	        }
	
	        this._input = this._input.slice(1);
	        return ch;
	    },
	
	// unshifts one char (or a string) into the input
	unput:function (ch) {
	        var len = ch.length;
	        var lines = ch.split(/(?:\r\n?|\n)/g);
	
	        this._input = ch + this._input;
	        this.yytext = this.yytext.substr(0, this.yytext.length - len);
	        //this.yyleng -= len;
	        this.offset -= len;
	        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
	        this.match = this.match.substr(0, this.match.length - 1);
	        this.matched = this.matched.substr(0, this.matched.length - 1);
	
	        if (lines.length - 1) {
	            this.yylineno -= lines.length - 1;
	        }
	        var r = this.yylloc.range;
	
	        this.yylloc = {
	            first_line: this.yylloc.first_line,
	            last_line: this.yylineno + 1,
	            first_column: this.yylloc.first_column,
	            last_column: lines ?
	                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
	                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
	              this.yylloc.first_column - len
	        };
	
	        if (this.options.ranges) {
	            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
	        }
	        this.yyleng = this.yytext.length;
	        return this;
	    },
	
	// When called from action, caches matched text and appends it on next action
	more:function () {
	        this._more = true;
	        return this;
	    },
	
	// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
	reject:function () {
	        if (this.options.backtrack_lexer) {
	            this._backtrack = true;
	        } else {
	            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
	                text: "",
	                token: null,
	                line: this.yylineno
	            });
	
	        }
	        return this;
	    },
	
	// retain first n characters of the match
	less:function (n) {
	        this.unput(this.match.slice(n));
	    },
	
	// displays already matched input, i.e. for error messages
	pastInput:function () {
	        var past = this.matched.substr(0, this.matched.length - this.match.length);
	        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
	    },
	
	// displays upcoming input, i.e. for error messages
	upcomingInput:function () {
	        var next = this.match;
	        if (next.length < 20) {
	            next += this._input.substr(0, 20-next.length);
	        }
	        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
	    },
	
	// displays the character position where the lexing error occurred, i.e. for error messages
	showPosition:function () {
	        var pre = this.pastInput();
	        var c = new Array(pre.length + 1).join("-");
	        return pre + this.upcomingInput() + "\n" + c + "^";
	    },
	
	// test the lexed token: return FALSE when not a match, otherwise return token
	test_match:function (match, indexed_rule) {
	        var token,
	            lines,
	            backup;
	
	        if (this.options.backtrack_lexer) {
	            // save context
	            backup = {
	                yylineno: this.yylineno,
	                yylloc: {
	                    first_line: this.yylloc.first_line,
	                    last_line: this.last_line,
	                    first_column: this.yylloc.first_column,
	                    last_column: this.yylloc.last_column
	                },
	                yytext: this.yytext,
	                match: this.match,
	                matches: this.matches,
	                matched: this.matched,
	                yyleng: this.yyleng,
	                offset: this.offset,
	                _more: this._more,
	                _input: this._input,
	                yy: this.yy,
	                conditionStack: this.conditionStack.slice(0),
	                done: this.done
	            };
	            if (this.options.ranges) {
	                backup.yylloc.range = this.yylloc.range.slice(0);
	            }
	        }
	
	        lines = match[0].match(/(?:\r\n?|\n).*/g);
	        if (lines) {
	            this.yylineno += lines.length;
	        }
	        this.yylloc = {
	            first_line: this.yylloc.last_line,
	            last_line: this.yylineno + 1,
	            first_column: this.yylloc.last_column,
	            last_column: lines ?
	                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
	                         this.yylloc.last_column + match[0].length
	        };
	        this.yytext += match[0];
	        this.match += match[0];
	        this.matches = match;
	        this.yyleng = this.yytext.length;
	        if (this.options.ranges) {
	            this.yylloc.range = [this.offset, this.offset += this.yyleng];
	        }
	        this._more = false;
	        this._backtrack = false;
	        this._input = this._input.slice(match[0].length);
	        this.matched += match[0];
	        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
	        if (this.done && this._input) {
	            this.done = false;
	        }
	        if (token) {
	            return token;
	        } else if (this._backtrack) {
	            // recover context
	            for (var k in backup) {
	                this[k] = backup[k];
	            }
	            return false; // rule action called reject() implying the next rule should be tested instead.
	        }
	        return false;
	    },
	
	// return next match in input
	next:function () {
	        if (this.done) {
	            return this.EOF;
	        }
	        if (!this._input) {
	            this.done = true;
	        }
	
	        var token,
	            match,
	            tempMatch,
	            index;
	        if (!this._more) {
	            this.yytext = '';
	            this.match = '';
	        }
	        var rules = this._currentRules();
	        for (var i = 0; i < rules.length; i++) {
	            tempMatch = this._input.match(this.rules[rules[i]]);
	            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
	                match = tempMatch;
	                index = i;
	                if (this.options.backtrack_lexer) {
	                    token = this.test_match(tempMatch, rules[i]);
	                    if (token !== false) {
	                        return token;
	                    } else if (this._backtrack) {
	                        match = false;
	                        continue; // rule action called reject() implying a rule MISmatch.
	                    } else {
	                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
	                        return false;
	                    }
	                } else if (!this.options.flex) {
	                    break;
	                }
	            }
	        }
	        if (match) {
	            token = this.test_match(match, rules[index]);
	            if (token !== false) {
	                return token;
	            }
	            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
	            return false;
	        }
	        if (this._input === "") {
	            return this.EOF;
	        } else {
	            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
	                text: "",
	                token: null,
	                line: this.yylineno
	            });
	        }
	    },
	
	// return next match that has a token
	lex:function lex() {
	        var r = this.next();
	        if (r) {
	            return r;
	        } else {
	            return this.lex();
	        }
	    },
	
	// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
	begin:function begin(condition) {
	        this.conditionStack.push(condition);
	    },
	
	// pop the previously active lexer condition state off the condition stack
	popState:function popState() {
	        var n = this.conditionStack.length - 1;
	        if (n > 0) {
	            return this.conditionStack.pop();
	        } else {
	            return this.conditionStack[0];
	        }
	    },
	
	// produce the lexer rule set which is active for the currently active lexer condition state
	_currentRules:function _currentRules() {
	        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
	            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
	        } else {
	            return this.conditions["INITIAL"].rules;
	        }
	    },
	
	// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
	topState:function topState(n) {
	        n = this.conditionStack.length - 1 - Math.abs(n || 0);
	        if (n >= 0) {
	            return this.conditionStack[n];
	        } else {
	            return "INITIAL";
	        }
	    },
	
	// alias for begin(condition)
	pushState:function pushState(condition) {
	        this.begin(condition);
	    },
	
	// return the number of states currently on the stack
	stateStackSize:function stateStackSize() {
	        return this.conditionStack.length;
	    },
	options: {},
	performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
	var YYSTATE=YY_START;
	switch($avoiding_name_collisions) {
	case 0:return 9
	break;
	case 1:return 9
	break;
	case 2:return 9
	break;
	case 3: this.begin('title') 
	break;
	case 4: yy_.yytext = yy_.yytext.substr(0, yy_.yyleng - 2).trim()
	                          return 14 
	break;
	case 5: this.begin('INITIAL') 
	break;
	case 6: this.begin('INITIAL')
	                          yy_.yytext = yy_.yytext.trim()
	                          return 15 
	break;
	case 7: this.begin('time')
	                          yy_.yytext = yy_.yytext.substr(0, yy_.yyleng - 1)
	                          return 58 
	break;
	case 8: this.begin('INITIAL'); return 59 
	break;
	case 9:return 41
	break;
	case 10:return 39
	break;
	case 11:return 40
	break;
	case 12:return 43
	break;
	case 13:return 47
	break;
	case 14:return 46
	break;
	case 15:return 28
	break;
	case 16:return 44
	break;
	case 17:return 45
	break;
	case 18:return '.'
	break;
	case 19:return 29
	break;
	case 20:return 48
	break;
	case 21:return 50
	break;
	case 22:return 34
	break;
	case 23:return 35
	break;
	case 24:return '/'
	break;
	case 25:return '\\'
	break;
	case 26:return 23
	break;
	case 27:return 22
	break;
	case 28:return '[|'
	break;
	case 29:return 24
	break;
	case 30:return 26
	break;
	case 31:return 25
	break;
	case 32:return 21
	break;
	case 33:return 51
	break;
	case 34:return 53
	break;
	case 35:return 55
	break;
	case 36:return 10
	break;
	case 37:return 9
	break;
	case 38:return 5
	break;
	case 39:return 'INVALID'
	break;
	}
	},
	rules: [/^(?:\/\/[^\n]*)/,/^(?:\/\*([\s\S]*?)\*\/)/,/^(?:\/\*[\s\S]*)/,/^(?:<<)/,/^(?:.*>>)/,/^(?:([ \t])*([\n\r]))/,/^(?:.*)/,/^(?:(([1-9]\d{0,2})\/))/,/^(?:([1-9]\d{0,2})[^\d])/,/^(?:(#{1,2}|n|b{1,2}))/,/^(?:[1-7])/,/^(?:,+|'+)/,/^(?:\.+)/,/^(?:( *- *){3})/,/^(?:( *- *))/,/^(?: *~)/,/^(?:[_])/,/^(?:=)/,/^(?:\.)/,/^(?:[0])/,/^(?:<)/,/^(?:>)/,/^(?:\()/,/^(?:\))/,/^(?:\/)/,/^(?:\\)/,/^(?:\|\])/,/^(?:\|\|)/,/^(?:\[\|)/,/^(?:\|:)/,/^(?::\|:)/,/^(?::\|)/,/^(?:\|)/,/^(?:\{)/,/^(?:\})/,/^(?::)/,/^(?:([\n\r]))/,/^(?:([ \t]))/,/^(?:$)/,/^(?:.)/],
	conditions: {"time":{"rules":[8],"inclusive":false},"title":{"rules":[4,5,6],"inclusive":false},"INITIAL":{"rules":[0,1,2,3,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39],"inclusive":true}}
	});
	return lexer;
	})();
	parser.lexer = lexer;
	function Parser () {
	  this.yy = {};
	}
	Parser.prototype = parser;parser.Parser = Parser;
	return new Parser;
	})();
	module.exports = parser

/***/ },
/* 2 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var IS_OBJECT = { 'funtion': true, 'object': true };
	var isObject = function isObject(obj) {
	  return IS_OBJECT[typeof obj === 'undefined' ? 'undefined' : _typeof(obj)] && !!obj;
	};
	
	var objEach = exports.objEach = function objEach(obj, callback) {
	  if (isObject(obj)) {
	    Object.keys(obj).forEach(function (key) {
	      callback(obj[key], key);
	    });
	  }
	};
	
	var extend = exports.extend = function extend(obj, ext) {
	  objEach(ext, function (val, key) {
	    obj[key] = val;
	  });
	  return obj;
	};
	
	var near = exports.near = function near(a, b) {
	  return Math.abs(a - b) < 0.00001;
	};
	
	var isAccessorProperty = function isAccessorProperty(value) {
	  return isObject(value) && (typeof value.get === 'function' || typeof value.set === 'function');
	};
	
	/**
	 * Define ES5 getter/setter properties
	 * @param {Object} obj - The object to be defined.
	 * @param {Object} props - ES5 getter/setter properties.
	 * For example:
	 * ```
	 * {
	 *   name: {
	 *     get: function () {...},
	 *     set: function () {...}
	 *   },
	 *   age: {
	 *      get:...
	 *   }
	 * }
	 * ```
	 */
	var defineProperties = exports.defineProperties = function defineProperties(obj, props) {
	  objEach(props, function (value, prop) {
	    var descriptor;
	    if (isAccessorProperty(value)) {
	      descriptor = value;
	    } else if (typeof value === 'function') {
	      descriptor = { value: value };
	    } else if (isObject(value) && value.constant) {
	      descriptor = { value: value.constant };
	    } else {
	      descriptor = {
	        value: value,
	        writable: true,
	        enumerable: true
	      };
	    }
	    Object.defineProperty(obj, prop, descriptor);
	  });
	};
	
	var toJSONWithDefault = true;
	
	var makeToJSON = exports.makeToJSON = function makeToJSON(values, elName) {
	  return function () {
	    var _this = this;
	
	    if (this.isEmpty) return;
	
	    var result = {};
	
	    objEach(values, function (defaultValue, prop) {
	      if (toJSONWithDefault || _this[prop] !== defaultValue) {
	        result[prop] = _this[prop];
	      }
	    });
	    if (!elName) return result;
	
	    var res = {};
	    res[elName] = result;
	    return res;
	  };
	};

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	var _ScoreHead = __webpack_require__(4);
	
	var _ScoreHead2 = _interopRequireDefault(_ScoreHead);
	
	var _PartwiseParts = __webpack_require__(5);
	
	var _PartwiseParts2 = _interopRequireDefault(_PartwiseParts);
	
	var _TimewiseMeasures = __webpack_require__(21);
	
	var _TimewiseMeasures2 = _interopRequireDefault(_TimewiseMeasures);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @param {Object} score - plain score object.
	 * @mixes PlayerMixin
	 */
	var Score = function () {
	  function Score(score) {
	    _classCallCheck(this, Score);
	
	    this.toJSON = (0, _util.makeToJSON)({
	      head: undefined,
	      parts: undefined
	    });
	
	    (0, _util.extend)(this, score);
	  }
	
	  /**
	   * Head of the score.
	   * @type {ScoreHead}
	   */
	
	
	  _createClass(Score, [{
	    key: 'walkCells',
	
	
	    /**
	     * A cell is identically a measure in a part or a part in a measure.
	     * @param {Function}
	     */
	    value: function walkCells(callback) {
	      this.parts.forEach(function (part, p) {
	        part.measures.forEach(function (cell, m) {
	          callback(cell, m, p);
	        });
	      });
	    }
	
	    /**
	     * Walk each music data.
	     * @param {Function} callback
	     */
	
	  }, {
	    key: 'walkMusicData',
	    value: function walkMusicData(callback) {
	      this.walkCells(function (cell, m, p) {
	        cell.data.forEach(function (data, d) {
	          callback(data, d, m, p);
	        });
	      });
	    }
	
	    /**
	     * Convert score to string.
	     * @return {string} Musje source code.
	     */
	
	  }, {
	    key: 'toString',
	    value: function toString() {
	      return this.head + this.parts.map(function (part) {
	        return part.toString();
	      }).join('\n\n');
	    }
	
	    /**
	     * Custom toJSON method.
	     * @method
	     * @return {Object}
	     */
	
	  }, {
	    key: 'head',
	    get: function get() {
	      return this._head || (this._head = new _ScoreHead2.default());
	    },
	    set: function set(head) {
	      this._head = new _ScoreHead2.default(head);
	    }
	
	    /**
	     * Partwise parts.
	     * - (Getter)
	     * - (Setter)
	     * @type {PartwiseParts}
	     */
	
	  }, {
	    key: 'parts',
	    get: function get() {
	      return this._parts || (this._parts = new _PartwiseParts2.default(this));
	    },
	    set: function set(parts) {
	      this.parts.removeAll();
	      this.parts.addParts(parts);
	      this.measures.fromPartwise();
	    }
	
	    /**
	     * Timewise measures, generated by the initialize function.
	     * @type {TimewiseMeasures}
	     * @readonly
	     */
	
	  }, {
	    key: 'measures',
	    get: function get() {
	      return this._measures || (this._measures = new _TimewiseMeasures2.default(this));
	    }
	  }]);
	
	  return Score;
	}();
	
	exports.default = Score;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Construct head of the score.
	 * @class
	 * @param {Object} head
	 */
	var ScoreHead = function () {
	  function ScoreHead(head) {
	    _classCallCheck(this, ScoreHead);
	
	    this.title = '';
	    this.subtitle = '';
	    this.subsubtitle = '';
	    this.composer = undefined;
	    this.arranger = undefined;
	    this.lyricist = undefined;
	    this.toJSON = (0, _util.makeToJSON)({
	      title: undefined,
	      subtitle: undefined,
	      subsubtitle: undefined,
	      composer: undefined,
	      lyricist: undefined
	    });
	
	    (0, _util.extend)(this, head);
	  }
	
	  /**
	   * Title of the score.
	   * @type {string}
	   * @default ''
	   */
	
	
	  /**
	   * Subtitle of the score.
	   * @type {string}
	   * @default ''
	   */
	
	
	  /**
	   * Subsubtitle of the score.
	   * @type {string}
	   * @default ''
	   */
	
	
	  /**
	   * Composer of the score.
	   * @type {string}
	   */
	
	
	  /**
	   * Arranger of the score.
	   * @type {string}
	   */
	
	
	  /**
	   * Lyricist of the score.
	   * @type {string}
	   */
	
	
	  _createClass(ScoreHead, [{
	    key: 'toString',
	
	
	    /**
	     * Convert score head to string.
	     * @return {string} The converted musje head source code.
	     */
	    value: function toString() {
	      var title = this.title ? '<<' + this.title + '>>' : '';
	      return title + ' ' + (this.composer || '') + '\n';
	    }
	  }, {
	    key: 'isEmpty',
	
	
	    /**
	     * Check if the score head is empty.
	     * @type {boolean}
	     * @readonly
	     */
	    get: function get() {
	      return !this.title && !this.subtitle && !this.subsubtitle && !this.composer && !this.arranger && !this.lyricist;
	    }
	  }]);
	
	  return ScoreHead;
	}();
	
	exports.default = ScoreHead;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _PartwisePart = __webpack_require__(6);
	
	var _PartwisePart2 = _interopRequireDefault(_PartwisePart);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _extendableBuiltin(cls) {
	  function ExtendableBuiltin() {
	    cls.apply(this, arguments);
	  }
	
	  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
	    constructor: {
	      value: cls,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	
	  if (Object.setPrototypeOf) {
	    Object.setPrototypeOf(ExtendableBuiltin, cls);
	  } else {
	    ExtendableBuiltin.__proto__ = cls;
	  }
	
	  return ExtendableBuiltin;
	}
	
	var PartwiseParts = function (_extendableBuiltin2) {
	  _inherits(PartwiseParts, _extendableBuiltin2);
	
	  function PartwiseParts(score) {
	    _classCallCheck(this, PartwiseParts);
	
	    var _this = _possibleConstructorReturn(this, (PartwiseParts.__proto__ || Object.getPrototypeOf(PartwiseParts)).call(this));
	
	    _this._score = score;
	    return _this;
	  }
	
	  /**
	   * Reference to the parent score.
	   * @type {Score}
	   * @readonly
	   */
	
	
	  _createClass(PartwiseParts, [{
	    key: 'addParts',
	
	
	    /**
	     * Add parts.
	     * @param {Object}
	     */
	    value: function addParts(parts) {
	      var _this2 = this;
	
	      parts.forEach(function (part) {
	        _this2.append(part);
	      });
	    }
	
	    /**
	     * Append a partwise part.
	     * @param {Object} part - Plain partwise part object.
	     * @override
	     */
	
	  }, {
	    key: 'append',
	    value: function append(part) {
	      var index = this.length;
	      var musjePart = new _PartwisePart2.default(index, this);
	      this.push(musjePart);
	      musjePart.measures = part.measures;
	    }
	
	    /**
	     * Remove all parts.
	     */
	
	  }, {
	    key: 'removeAll',
	    value: function removeAll() {
	      this.length = 0;
	    }
	  }, {
	    key: 'score',
	    get: function get() {
	      return this._score;
	    }
	  }]);
	
	  return PartwiseParts;
	}(_extendableBuiltin(Array));
	
	exports.default = PartwiseParts;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	var _Cell = __webpack_require__(7);
	
	var _Cell2 = _interopRequireDefault(_Cell);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @class
	 * @param part {Object}
	 * @param index {number} - Index of this part in the parts.
	 * @param parts {PartwiseParts}
	 */
	var PartwisePart = function () {
	  function PartwisePart(index, parts) {
	    _classCallCheck(this, PartwisePart);
	
	    this.toJSON = (0, _util.makeToJSON)({
	      measures: undefined
	    });
	
	    this._index = index;
	    this._parts = parts;
	  }
	
	  // head: { $ref: '#/objects/PartHead' },
	
	  /**
	   * Reference to the parent parts instance.
	   * @type {PartwiseParts}
	   * @readonly
	   */
	
	
	  _createClass(PartwisePart, [{
	    key: 'toString',
	
	
	    /**
	     * Convert a partwise part to sting.
	     * @return {string} Musje partwise part source code.
	     */
	    value: function toString() {
	      return this.measures.map(function (cell) {
	        return cell;
	      }).join(' ');
	    }
	
	    /**
	     * Custom toJSON method.
	     * @return {Object}
	     */
	
	  }, {
	    key: 'parts',
	    get: function get() {
	      return this._parts;
	    }
	
	    /**
	     * Measure in a partwise part is cells.
	     * @type {Array.<Cell>}
	     */
	
	  }, {
	    key: 'measures',
	    get: function get() {
	      return this._measures || (this._measures = []);
	    },
	    set: function set(measures) {
	      var p = this._index;
	      var score = this.parts.score;
	
	      var mea = this._measures = [];
	      measures.forEach(function (cell, m) {
	        mea.push(new _Cell2.default(cell, m, p, score));
	      });
	    }
	  }]);
	
	  return PartwisePart;
	}();
	
	exports.default = PartwisePart;

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _snapsvg = __webpack_require__(8);
	
	var _Time = __webpack_require__(9);
	
	var _Time2 = _interopRequireDefault(_Time);
	
	var _Bar = __webpack_require__(11);
	
	var _Bar2 = _interopRequireDefault(_Bar);
	
	var _Note = __webpack_require__(12);
	
	var _Note2 = _interopRequireDefault(_Note);
	
	var _Rest = __webpack_require__(17);
	
	var _Rest2 = _interopRequireDefault(_Rest);
	
	var _Chord = __webpack_require__(18);
	
	var _Chord2 = _interopRequireDefault(_Chord);
	
	var _Voice = __webpack_require__(19);
	
	var _Voice2 = _interopRequireDefault(_Voice);
	
	var _Beam = __webpack_require__(20);
	
	var _Beam2 = _interopRequireDefault(_Beam);
	
	var _util = __webpack_require__(2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Classes = { time: _Time2.default, bar: _Bar2.default, note: _Note2.default, rest: _Rest2.default, chord: _Chord2.default, voice: _Voice2.default };
	var Bar = _Bar2.default;
	
	/**
	 * Cell is either a measure in a partwise part, or
	 * a part in a timewise measure.
	 * @param cell {Object}
	 * @param mIndex {number} - Measure index of this cell.
	 * @param pIndex {number} - Part index of this cell.
	 */
	
	var Cell = function () {
	  function Cell(cell, mIndex, pIndex, score) {
	    _classCallCheck(this, Cell);
	
	    this.toJSON = (0, _util.makeToJSON)({
	      data: undefined
	    });
	
	    this._mIndex = mIndex;
	    this._pIndex = pIndex;
	    this._score = score;
	    (0, _util.extend)(this, cell);
	    makeBeams(this, 1);
	  }
	
	  /**
	   * Reference to the root score instance.
	   * @type {Score}
	   * @readonly
	   */
	
	
	  _createClass(Cell, [{
	    key: 'append',
	
	
	    /**
	     * Append a music data to the cell.
	     * @param  {Object} musicData - Music data
	     */
	    value: function append(musicData) {
	      var type = Object.keys(musicData)[0]; // musicData has only one key
	      var instance = new Classes[type](musicData[type]);
	      instance._cell = this;
	      instance._index = this.data.length;
	      this.data.push(instance);
	    }
	
	    /**
	     * Width
	     * - (Getter) Get the cell width.
	     * - (Setter) Set the cell width, and this will cause the cell to reflow.
	     * @type {number}
	     */
	
	  }, {
	    key: 'flow',
	
	
	    /**
	     * Flow the cell.
	     */
	    value: function flow() {
	      var _layout = this.layout,
	          defs = _layout.defs,
	          options = _layout.options;
	      var musicDataSep = options.musicDataSep;
	
	      var x = 0;
	      var minHeight = void 0;
	
	      this.data.forEach(function (data) {
	        var def = data.def = defs.get(data);
	        data.x = x;
	        data.y = 0;
	        x += def.width + musicDataSep;
	        minHeight = Math.min(minHeight, def.height);
	      });
	
	      this.minWidth = x;
	      this.minHeight = minHeight;
	    }
	
	    /**
	     * Draw box of the cell.
	     * @return {Element} The box SVG rect element.
	     */
	
	  }, {
	    key: 'drawBox',
	    value: function drawBox() {
	      this._boxEl = this.el.rect(0, -this.height, this.width, this.height).addClass('bbox');
	      return this._boxEl;
	    }
	
	    /**
	     * Clear the box SVG element.
	     */
	
	  }, {
	    key: 'clearBox',
	    value: function clearBox() {
	      this._boxEl.remove();
	      this._boxEl = undefined;
	    }
	
	    /**
	     * Convert cell to string.
	     * @return {string} Converted cell in musje source code.
	     */
	
	  }, {
	    key: 'toString',
	    value: function toString() {
	      return this.data.map(function (musicData) {
	        return musicData.toString();
	      }).join(' ');
	    }
	  }, {
	    key: 'score',
	    get: function get() {
	      return this._score;
	    }
	
	    /**
	     * Music data
	     * @type {Array.<MusicDataMixin>}
	     */
	
	  }, {
	    key: 'data',
	    get: function get() {
	      return this._data || (this._data = []);
	    },
	    set: function set(data) {
	      var _this = this;
	
	      this.length = 0;
	      data.forEach(function (datum) {
	        _this.append(datum);
	      });
	    }
	
	    /**
	     * Reference to the parent measures.
	     * @type {TimewiseMeasures}
	     * @readonly
	     */
	
	  }, {
	    key: 'measures',
	    get: function get() {
	      return this.score.measures;
	    }
	
	    /**
	     * Reference to the parent measure.
	     * @type {TimewiseMeasure}
	     * @readonly
	     */
	
	  }, {
	    key: 'measure',
	    get: function get() {
	      return this.measures[this._mIndex];
	    }
	
	    /**
	     * Reference to the parent parts.
	     * @type {PartwiseParts}
	     * @readonly
	     */
	
	  }, {
	    key: 'parts',
	    get: function get() {
	      return this.score.parts;
	    }
	
	    /**
	     * Reference to the parent part.
	     * @type {PartwisePart}
	     * @readonly
	     */
	
	  }, {
	    key: 'part',
	    get: function get() {
	      return this.parts[this._pIndex];
	    }
	
	    /**
	     * Previous cell in the part.
	     * @type {Cell|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'prev',
	    get: function get() {
	      return this.part.measures[this._mIndex - 1];
	    }
	
	    /**
	     * Next cell in the part.
	     * @type {Cell|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'next',
	    get: function get() {
	      return this.part.measures[this._mIndex + 1];
	    }
	
	    /**
	     * The first music data in the cell.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'firstData',
	    get: function get() {
	      return this.data[0];
	    }
	
	    /**
	     * The last music data in the cell.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'lastData',
	    get: function get() {
	      return this.data[this.data.length - 1];
	    }
	
	    /**
	     * The left bar of this cell.
	     * @type {Bar|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'barLeft',
	    get: function get() {
	      var firstData = this.firstData;
	
	      if (firstData && firstData.$type === 'bar') return firstData;
	
	      // Take from the previous measure.
	      var prevCell = this.prev;
	      if (prevCell) return prevCell.barRight;
	    }
	
	    /**
	     * The right bar of this cell.
	     * @type {Bar|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'barRight',
	    get: function get() {
	      var lastData = this.lastData;
	
	      if (lastData && lastData.$type === 'bar') return lastData;
	    }
	  }, {
	    key: 'width',
	    get: function get() {
	      return this._w;
	    },
	    set: function set(w) {
	      this._w = w;
	      reflow(this);
	    }
	  }, {
	    key: 'height',
	    get: function get() {
	      return this.layout.options.partHeight;
	    }
	
	    /**
	     * The x position of the cell in parent timewise measure.
	     * - Set the x value will cause the cell element translate.
	     * @type {number}
	     */
	
	  }, {
	    key: 'x',
	    get: function get() {
	      return this._x;
	    },
	    set: function set(x) {
	      this._x = x;
	      this.el.transform((0, _snapsvg.matrix)().translate(x, this.y2));
	    }
	
	    /**
	     * The y2 position of the cell in parent timewise measure.
	     * - Set the y2 value will cause the cell element translate.
	     * @type {number}
	     */
	
	  }, {
	    key: 'y2',
	    get: function get() {
	      var _layout$options = this.layout.options,
	          partHeight = _layout$options.partHeight,
	          partSep = _layout$options.partSep;
	
	      var p = this._pIndex;
	
	      return p ? (p + 1) * partHeight + p * partSep : partHeight;
	    }
	
	    /**
	     * The left bar of this cell.
	     * - barLeft at first measure of a system:
	     * ```
	     * |]  -> |
	     * :|  -> |
	     * :|: -> |:
	     * ```
	     * @type {Bar}
	     * @readonly
	     */
	
	  }, {
	    key: 'barLeftInSystem',
	    get: function get() {
	      var bar = this.barLeft;
	      if (!bar) return { width: 0, height: 0 };
	
	      // First measure in the system.
	      if (this.measure.inSystemBegin) {
	        if (bar.value === 'end' || bar.value === 'repeat-end') {
	          bar = new Bar('single');
	        } else if (bar.value === 'repeat-both') {
	          bar = new Bar('repeat-begin');
	        }
	      }
	      bar.def = this.layout.defs.get(bar);
	      return bar;
	    }
	
	    /**
	     * The right bar of this cell.
	     * - barRight at last measure of a system:
	     * ```
	     *  |: ->  |
	     * :|: -> :|
	     * ```
	     * @type {musje.Bar}
	     * @readonly
	     */
	
	  }, {
	    key: 'barRightInSystem',
	    get: function get() {
	      var system = this.measure.system;
	
	      var bar = this.barRight;
	
	      if (!bar) return { width: 0, height: 0 };
	
	      // Last measure in the system.
	      if (system && this.measure.inSystemEnd) {
	        if (bar.value === 'repeat-begin') {
	          bar = new Bar('single');
	        } else if (bar.value === 'repeat-both') {
	          bar = new Bar('repeat-end');
	        }
	      }
	      bar.def = this.layout.defs.get(bar);
	      return bar;
	    }
	  }]);
	
	  return Cell;
	}();
	
	// Reflow the cell.
	
	
	function reflow(that) {
	  that.data.forEach(function (data) {
	    data.x *= that.width / that.minWidth;
	  });
	}
	
	/**
	 * Make beams automatically in group by the groupDur.
	 * @param {number} groupDur - Duration of a beam group in quarter.
	 */
	function makeBeams(that, groupDur) {
	
	  getBeamGroups(that, groupDur).forEach(function (group) {
	    var beamLevel = {}; // it starts from 0, while underbar starts from 1
	
	    var nextHasSameBeamlevel = function nextHasSameBeamlevel(index, level) {
	      var next = group[index + 1];
	      return next && next.duration.underbar > level;
	    };
	
	    group.forEach(function (data, i) {
	      var underbar = data.duration.underbar;
	
	
	      for (var level = 0; level < underbar; level++) {
	        if (nextHasSameBeamlevel(i, level)) {
	
	          /**
	           * Beams of the note.
	           * - Produced by the {@link Cell#makeBeams} method.
	           * - The above method is call in {@link Score#prepareCells}.
	           * @memberof Note#
	           * @alias beams
	           * @type {Array.<Beam>}
	           */
	          data.beams = data.beams || [];
	
	          if (beamLevel[level]) {
	            data.beams[level] = new _Beam2.default('continue', level, data);
	          } else {
	            beamLevel[level] = true;
	            data.beams[level] = new _Beam2.default('begin', level, data);
	          }
	        } else {
	          if (beamLevel[level]) {
	            data.beams = data.beams || [];
	            data.beams[level] = new _Beam2.default('end', level, data);
	            delete beamLevel[level];
	          }
	        }
	      }
	    });
	  });
	}
	
	function getBeamGroups(that, groupDur) {
	  var groups = [];
	  var group = [];
	  var counter = 0;
	
	  var inGroup = function inGroup() {
	    return counter < groupDur && !(0, _util.near)(counter, groupDur);
	  };
	  var putGroup = function putGroup() {
	    if (group.length > 1) groups.push(group);
	    group = [];
	  };
	
	  that.data.forEach(function (musicData) {
	    if (musicData.$type !== 'note' && musicData.$type !== 'rest') return;
	
	    var duration = musicData.duration;
	
	    var dur = duration.quarter;
	
	    counter += dur;
	
	    if (inGroup()) {
	      if (duration.underbar) group.push(musicData);
	    } else if ((0, _util.near)(counter, groupDur)) {
	      group.push(musicData);
	      putGroup();
	      counter = 0;
	    } else {
	      putGroup();
	      counter %= groupDur;
	    }
	  });
	
	  putGroup();
	
	  return groups;
	}
	
	exports.default = Cell;

/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_8__;

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	var _MusicData2 = __webpack_require__(10);
	
	var _MusicData3 = _interopRequireDefault(_MusicData2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * Time signature.
	 * @class
	 * @param time {Object}
	 * @mixes MusicDataMixin
	 * @mixes MusicDataLayoutMixin
	 */
	var Time = function (_MusicData) {
	  _inherits(Time, _MusicData);
	
	  function Time(time) {
	    _classCallCheck(this, Time);
	
	    var _this = _possibleConstructorReturn(this, (Time.__proto__ || Object.getPrototypeOf(Time)).call(this));
	
	    _this.$type = 'time';
	    _this.beats = 4;
	    _this.beatType = 4;
	    _this.toJSON = (0, _util.makeToJSON)({
	      beats: 4,
	      beatType: 4
	    }, 'time');
	
	    (0, _util.extend)(_this, time);
	    return _this;
	  }
	
	  /**
	   * Type of time.
	   * @constant
	   * @default time
	   */
	
	
	  /**
	   * How many beats per measure.
	   * @type {number}
	   * @default
	   */
	
	
	  /**
	   * Beat type
	   * @type {number}
	   * @default
	   */
	
	
	  _createClass(Time, [{
	    key: 'toString',
	
	
	    /**
	     * Convert to musje source code.
	     * @return {string} Musje source code.
	     */
	    value: function toString() {
	      return this.beats + '/' + this.beatType;
	    }
	  }, {
	    key: 'defId',
	
	
	    /**
	     * Def id used in the SVG <defs> element.
	     * ```
	     * id := 't' beats '-' beatType
	     * ```
	     * E.g. `t3-4`
	     * @type {string}
	     * @readonly
	     */
	    get: function get() {
	      return 't' + this.beats + '-' + this.beatType;
	    }
	  }]);
	
	  return Time;
	}(_MusicData3.default);
	
	exports.default = Time;

/***/ },
/* 10 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var MusicData = function () {
	  function MusicData() {
	    _classCallCheck(this, MusicData);
	  }
	
	  _createClass(MusicData, [{
	    key: 'cell',
	
	
	    /**
	     * Reference to the parent cell.
	     * @type {Cell}
	     */
	    get: function get() {
	      return this._cell;
	    }
	
	    /**
	     * The ascendant system of the music data.
	     * @type {SystemLayout}
	     * @readonly
	     */
	
	  }, {
	    key: 'system',
	    get: function get() {
	      return this.cell.measure.system;
	    }
	
	    /**
	     * Previous music data.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'prev',
	    get: function get() {
	      return this.cell.data[this._index - 1];
	    }
	
	    /**
	     * Next music data.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'next',
	    get: function get() {
	      return this.cell.data[this._index + 1];
	    }
	
	    /**
	     * Previous music data in part, across measure.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'prevInPart',
	    get: function get() {
	      var prev = this.prev,
	          cell = this.cell;
	
	      while (!prev && cell.prev) {
	        if (!prev) {
	          cell = cell.prev;
	          prev = cell.lastData;
	        }
	      }
	      return prev;
	    }
	
	    /**
	     * Next music data in part, across measure.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'nextInPart',
	    get: function get() {
	      var next = this.next,
	          cell = this.cell;
	
	      while (!next && cell.next) {
	        if (!next) {
	          cell = cell.next;
	          next = cell.firstData;
	        }
	      }
	      return next;
	    }
	
	    /**
	     * Previous music data which has a duration.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'prevDurable',
	    get: function get() {
	      var prev = this.prev;
	
	      while (prev && !prev.duration) {
	        prev = prev.prev;
	      }return prev;
	    }
	
	    /**
	     * Next music data which has a duration.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'nextDurable',
	    get: function get() {
	      var next = this.next;
	
	      while (next && !next.duration) {
	        next = next.next;
	      }return next;
	    }
	
	    /**
	     * Previous music data which has a duration in part, across measure.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'prevDurableInPart',
	    get: function get() {
	      var prev = this.prevInPart;
	      while (prev && !prev.duration) {
	        prev = prev.prevInPart;
	      }return prev;
	    }
	
	    /**
	     * Next music data which has a duration in part, across measure.
	     * @type {MusicDataMixin|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'nextDurableInPart',
	    get: function get() {
	      var next = this.nextInPart;
	      while (next && !next.duration) {
	        next = next.nextInPart;
	      }return next;
	    }
	
	    /**
	     * The x position of the music data in the cell.
	     * @type {number}
	     */
	
	  }, {
	    key: 'x',
	    get: function get() {
	      return this._x;
	    },
	    set: function set(x) {
	      this._x = x;
	      if (this.el) this.el.attr('x', x);
	    }
	
	    /**
	     * The y position of the music data in the cell.
	     * @type {number}
	     */
	
	  }, {
	    key: 'y',
	    get: function get() {
	      return this._y;
	    },
	    set: function set(y) {
	      this._y = y;
	      if (this.el) this.el.attr('y', y);
	    }
	
	    /**
	     * The x position of the music data in the system.
	     * @type {number}
	     */
	
	  }, {
	    key: 'systemX',
	    get: function get() {
	      return this.x + this.cell.x + this.cell.measure.x;
	    }
	
	    /**
	     * The width of the music data.
	     * @type {number}
	     * @readonly
	     */
	
	  }, {
	    key: 'width',
	    get: function get() {
	      return this.def.width;
	    }
	  }]);
	
	  return MusicData;
	}();
	
	exports.default = MusicData;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _MusicData2 = __webpack_require__(10);
	
	var _MusicData3 = _interopRequireDefault(_MusicData2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var BAR_TO_STRING = {
	  single: '|', double: '||', end: '|]',
	  'repeat-begin': '|:', 'repeat-end': ':|', 'repeat-both': ':|:'
	};
	var BAR_TO_ID = {
	  single: 'bs', double: 'bd', end: 'be',
	  'repeat-begin': 'brb', 'repeat-end': 'bre', 'repeat-both': 'brbe'
	};
	
	/**
	 * @param {string} bar - The bar value, which can be either of
	 * - 'single' - `|`
	 * - 'double' - `||`
	 * - 'end' - `|]`
	 * - 'repeat-begin' - `|:`
	 * - 'repeat-end' - `:|`
	 * - 'repeat-both' - `:|:`
	 */
	
	var Bar = function (_MusicData) {
	  _inherits(Bar, _MusicData);
	
	  function Bar(bar) {
	    _classCallCheck(this, Bar);
	
	    var _this = _possibleConstructorReturn(this, (Bar.__proto__ || Object.getPrototypeOf(Bar)).call(this));
	
	    _this.$type = 'bar';
	
	    _this._value = bar;
	    return _this;
	  }
	
	  /**
	   * Type of bar.
	   * @constant
	   * @readonly
	   * @default bar
	   */
	
	
	  _createClass(Bar, [{
	    key: 'toString',
	
	
	    /**
	     * Convert bar to string.
	     * @return {string} Converted string of the barline in musje source code.
	     */
	    value: function toString() {
	      return BAR_TO_STRING[this.value];
	    }
	
	    /**
	     * [toJSON description]
	     * @return {Object} { bar: value }
	     */
	
	  }, {
	    key: 'toJSON',
	    value: function toJSON() {
	      return { bar: this.value };
	    }
	  }, {
	    key: 'value',
	
	
	    /**
	     * Value of the bar, which is the same as the bar parameter in the constructor.
	     * @type {string}
	     * @default single
	     * @readonly
	     */
	    get: function get() {
	      return this._value || (this._value = 'single');
	    }
	
	    /**
	     * Def id used in the SVG <defs> element.
	     * ```
	     * defId    Bar value
	     * ----------------------
	     * 'bs'   - single
	     * 'bd'   - double
	     * 'be'   - repeat-end
	     * 'brb'  - repeat-begin
	     * 'bre'  - repeat-end
	     * 'brbe' - repeat-both
	     * ```
	     * @type {string}
	     * @readonly
	     */
	
	  }, {
	    key: 'defId',
	    get: function get() {
	      return BAR_TO_ID[this.value];
	    }
	  }]);
	
	  return Bar;
	}(_MusicData3.default);
	
	exports.default = Bar;

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	var _MusicData2 = __webpack_require__(10);
	
	var _MusicData3 = _interopRequireDefault(_MusicData2);
	
	var _Pitch = __webpack_require__(13);
	
	var _Pitch2 = _interopRequireDefault(_Pitch);
	
	var _Duration = __webpack_require__(14);
	
	var _Duration2 = _interopRequireDefault(_Duration);
	
	var _Tie = __webpack_require__(15);
	
	var _Tie2 = _interopRequireDefault(_Tie);
	
	var _Slur = __webpack_require__(16);
	
	var _Slur2 = _interopRequireDefault(_Slur);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * @class
	 * @param {Object} note
	 * @mixes MusicDataMixin
	 * @mixes MusicDataLayoutMixin
	 */
	var Note = function (_MusicData) {
	  _inherits(Note, _MusicData);
	
	  function Note(note) {
	    _classCallCheck(this, Note);
	
	    var _this = _possibleConstructorReturn(this, (Note.__proto__ || Object.getPrototypeOf(Note)).call(this));
	
	    _this.$type = 'note';
	    _this.toJSON = (0, _util.makeToJSON)({
	      pitch: undefined,
	      duration: undefined,
	      tie: undefined,
	      slur: undefined
	    }, 'note');
	
	    (0, _util.extend)(_this, note);
	    return _this;
	  }
	
	  /**
	   * Type of note.
	   * @constant
	   * @default note
	   */
	
	
	  _createClass(Note, [{
	    key: 'toString',
	
	
	    /** @method */
	    value: function toString() {
	      return this.slur.begin + this.pitch + this.duration + this.slur.end + this.tie.value;
	    }
	  }, {
	    key: 'defId',
	
	
	    /**
	     * Unique def id of the note used in the SVG <defs> element.
	     * ```
	     * defId := 'n' accidental step octave type dot
	     * ```
	     * E.g.
	     * ```
	     * Note     defId
	     * ------------------
	     * 1        n1040
	     * b3-      nb3020
	     * #5'_.    ns5181
	     * 6,,      n6-2
	     * ```
	     * @type {string}
	     * @readonly
	     */
	    get: function get() {
	      var _pitch = this.pitch,
	          accidental = _pitch.accidental,
	          step = _pitch.step,
	          octave = _pitch.octave;
	      var _duration = this.duration,
	          type = _duration.type,
	          dot = _duration.dot;
	
	      return 'n' + accidental.replace(/#/g, 's') + step + octave + type + dot;
	    }
	
	    /**
	     * Pitch of the note.
	     * @type {musje.Pitch}
	     */
	
	  }, {
	    key: 'pitch',
	    get: function get() {
	      return this._pitch || (this._pitch = new _Pitch2.default(this));
	    },
	    set: function set(pitch) {
	      this._pitch = new _Pitch2.default(this, pitch);
	    }
	
	    /**
	     * Duration of the note.
	     * @type {musje.Duration}
	     */
	
	  }, {
	    key: 'duration',
	    get: function get() {
	      return this._duration || (this._duration = new _Duration2.default());
	    },
	    set: function set(duration) {
	      this._duration = new _Duration2.default(duration);
	    }
	  }, {
	    key: 'beams',
	    get: function get() {
	      return this._beams || (this._beams = []);
	    },
	    set: function set(beams) {
	      this._beams = beams;
	    }
	
	    /**
	     * Tie
	     * @type {musje.Tie}
	     */
	
	  }, {
	    key: 'tie',
	    get: function get() {
	      return this._tie || (this._tie = new _Tie2.default(this));
	    },
	    set: function set(tie) {
	      /**
	       * Value of the tie.
	       * @memberof Tie#
	       * @alias value
	       * @type {boolean}
	       */
	      this.tie.value = tie;
	    }
	
	    /**
	     * Slur
	     * @type {Slur}
	     */
	
	  }, {
	    key: 'slur',
	    get: function get() {
	      return this._slur || (this._slur = new _Slur2.default(this));
	    },
	    set: function set(slur) {
	      (0, _util.extend)(this.slur, slur);
	    }
	  }]);
	
	  return Note;
	}(_MusicData3.default);
	
	exports.default = Note;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var A4_FREQUENCY = 440;
	var A4_MIDI_NUMBER = 69;
	var STEP_TO_MIDI_NUMBER = [undefined, 0, 2, 4, 5, 7, 9, 11];
	var ACCIDENTAL_TO_ALTER = { '#': 1, '##': 2, n: 0, b: -1, bb: -2 };
	
	var chars = function chars(ch, num) {
	  return new Array(num + 1).join(ch);
	};
	var octaveString = function octaveString(octave) {
	  return octave > 0 ? chars('\'', octave) : octave < 0 ? chars(',', -octave) : '';
	};
	
	// /**
	//  * Step is a value of `1`, `2`, `3`, `4`, `5`, `6`, or `7`.
	//  * @type {number}
	//  * @default
	//  */
	// step = 1
	
	// /**
	//  * Octave is an integer value from `-5` to `5` inclusive.
	//  * @type {number}
	//  * @default
	//  */
	// octave = 0
	
	// /**
	//  * Accidental is either of
	//  * - `'#'` - sharp
	//  * - `'##'` - double sharp
	//  * - `'b'` - flat
	//  * - `'bb'` - double flat
	//  * - `'n'` - natural
	//  * - `''` - (none)
	//  * @type {string}
	//  */
	// accidental = ''
	
	/**
	 * @class
	 * @param parent {Note|Chord}
	 * @param pitch {Object}
	 */
	
	var Pitch = function () {
	  function Pitch(parent, _ref) {
	    var _ref$step = _ref.step,
	        step = _ref$step === undefined ? 1 : _ref$step,
	        _ref$octave = _ref.octave,
	        octave = _ref$octave === undefined ? 0 : _ref$octave,
	        _ref$accidental = _ref.accidental,
	        accidental = _ref$accidental === undefined ? '' : _ref$accidental;
	
	    _classCallCheck(this, Pitch);
	
	    this.toJSON = (0, _util.makeToJSON)({
	      step: 1,
	      octave: 0,
	      accidental: ''
	    });
	
	    this._parent = parent;
	    (0, _util.extend)(this, { step: step, octave: octave, accidental: accidental });
	  }
	
	  /**
	   * Reference to the parent parent.
	   * @type {Note|Chord}
	   * @readonly
	   */
	
	
	  _createClass(Pitch, [{
	    key: 'toString',
	
	
	    /**
	     * Convert to musje source code string.
	     * @return {string} Converted musje source code string.
	     */
	    value: function toString() {
	      return this.accidental + this.step + octaveString(this.octave);
	    }
	  }, {
	    key: 'parent',
	    get: function get() {
	      return this._parent;
	    }
	
	    /**
	     * Def id used in the SVG <defs> element.
	     * ```
	     * defId := 'p' accidental step octave
	     * ```
	     * @type {string}
	     * @readonly
	     */
	
	  }, {
	    key: 'defId',
	    get: function get() {
	      return 'p' + this.accidental.replace(/#/g, 's') + this.step + this.octave;
	    }
	
	    /**
	     * Alter (from -2 to 2 inclusive).
	     *
	     * If no accidental in this pitch, it might be affected by a previous note in the same cell (the same part and the same measure).
	     * @type {number}
	     * @readonly
	     */
	
	  }, {
	    key: 'alter',
	    get: function get() {
	      if (this.accidental) return ACCIDENTAL_TO_ALTER[this.accidental];
	      var alterLink = this.alterLink;
	
	      return alterLink ? alterLink.alter : 0;
	    }
	
	    /**
	     * Pitch linked that will affect the alter in this pitch.
	     * @type {Pitch|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'alterLink',
	    get: function get() {
	      var prevData = this.parent.prev;
	
	      while (prevData) {
	        if (prevData.$type === 'note' && prevData.pitch.step === this.step && prevData.pitch.accidental) {
	          return prevData.pitch;
	        }
	        prevData = prevData.prev;
	      }
	    }
	
	    /**
	     * The MIDI note number of the pitch
	     * @type {number}
	     */
	
	  }, {
	    key: 'midiNumber',
	    get: function get() {
	      return (this.octave + 5) * 12 + STEP_TO_MIDI_NUMBER[this.step] + this.alter;
	    }
	
	    /**
	     * Frequency of the pitch
	     * @type {number}
	     * @readonly
	     */
	
	  }, {
	    key: 'frequency',
	    get: function get() {
	      return A4_FREQUENCY * Math.pow(2, (this.midiNumber - A4_MIDI_NUMBER) / 12);
	    }
	  }]);
	
	  return Pitch;
	}();
	
	exports.default = Pitch;

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var TYPE_TO_STRING = {
	  1: ' - - - ', 2: ' - ', 4: '', 8: '_', 16: '=', 32: '=_',
	  64: '==', 128: '==_', 256: '===', 512: '===_', 1024: '===='
	};
	var TYPE_TO_UNDERBAR = {
	  1: 0, 2: 0, 4: 0, 8: 1, 16: 2, 32: 3,
	  64: 4, 128: 5, 256: 6, 512: 7, 1024: 8
	};
	var DOT_TO_STRING = ['', '.', '..'];
	
	// /**
	//  * Beat type
	//  * @type {number}
	//  * @default
	//  */
	// type = 4
	
	// *
	//  * Dot with value of 0, 1, or 2.
	//  * @type {number}
	//  * @default
	
	// dot = 0
	
	var Duration = function () {
	  function Duration() {
	    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        _ref$type = _ref.type,
	        type = _ref$type === undefined ? 4 : _ref$type,
	        _ref$dot = _ref.dot,
	        dot = _ref$dot === undefined ? 0 : _ref$dot;
	
	    _classCallCheck(this, Duration);
	
	    this.$type = 'duration';
	    this.toJSON = (0, _util.makeToJSON)({
	      type: 4,
	      dot: 0
	    });
	
	    (0, _util.extend)(this, { type: type, dot: dot });
	  }
	
	  /**
	   * Type of duration.
	   * @constant
	   * @default duration
	   */
	
	
	  _createClass(Duration, [{
	    key: 'toString',
	
	
	    /**
	     * @return {string}
	     */
	    value: function toString() {
	      return TYPE_TO_STRING[this.type] + DOT_TO_STRING[this.dot];
	    }
	
	    /**
	     * [toJSON description]
	     * @return {Object}
	     */
	
	  }, {
	    key: 'defId',
	
	
	    /**
	     * Def id used in the SVG <defs> element.
	     * ```
	     * defId := 'd' type dot
	     * ```
	     * *E.g.*
	     * ```
	     * Note     defId
	     * ----------------
	     * 1.       d41
	     * 1_       d80
	     * 1=       d160
	     * 1-..     d22
	     * ```
	     * @type {string}
	     * @readonly
	     */
	    get: function get() {
	      return 'd' + this.type + this.dot;
	    }
	
	    /**
	     * `(Getter)` Duration measured in quarter note.
	     * @type {number}
	     */
	
	  }, {
	    key: 'quarter',
	    get: function get() {
	      var d = 4 / this.type;
	      return this.dot === 0 ? d : this.dot === 1 ? d * 1.5 : d * 1.75;
	    }
	
	    /**
	     * `(Getter)` Duration in second
	     * Affected by the tempo.
	     * @type {number}
	     * @readonly
	     */
	
	  }, {
	    key: 'second',
	    get: function get() {
	      return this.quarter * 60 / 80; // / TEMPO;
	    }
	
	    /**
	     * `(Getter)` Number of underbars in the beam.
	     * @type {number}
	     * @readonly
	     */
	
	  }, {
	    key: 'underbar',
	    get: function get() {
	      return TYPE_TO_UNDERBAR[this.type] || 0;
	    }
	  }]);
	
	  return Duration;
	}();
	
	exports.default = Duration;

/***/ },
/* 15 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Tie of the note.
	 * @param parent {Note|Chord}
	 */
	var Tie = function () {
	  function Tie(parent) {
	    _classCallCheck(this, Tie);
	
	    this.value = '';
	
	    this._parent = parent;
	  }
	
	  _createClass(Tie, [{
	    key: 'toJSON',
	    value: function toJSON() {
	      return this.value;
	    }
	  }, {
	    key: 'parent',
	    get: function get() {
	      return this._parent;
	    }
	  }, {
	    key: 'begin',
	    get: function get() {
	      return this.value;
	    }
	  }, {
	    key: 'end',
	    get: function get() {
	      return this.prevParent;
	    }
	
	    /**
	     * The previous durable music data in part, if it is a tie begin.
	     * @type {Durable|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'prevParent',
	    get: function get() {
	      var prev = this.parent.prevDurableInPart;
	      return prev && prev.tie && prev.tie.value && prev;
	    }
	
	    /**
	     * The next durable music data in part.
	     * @type {Durable|undefined}
	     * @readonly
	     */
	
	  }, {
	    key: 'nextParent',
	    get: function get() {
	      return this.value && this.parent.nextDurableInPart;
	    }
	
	    /**
	     * If previous durable music data in part has error.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'prevHasError',
	    get: function get() {
	      var prev = this.prevParent;
	      if (!prev || !prev.pitch) return true;
	      return prev.pitch && prev.pitch.midiNumber !== this.parent.pitch.midiNumber;
	    }
	
	    /**
	     * If next durable music data in part has error.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'nextHasError',
	    get: function get() {
	      var next = this.nextParent;
	      if (!next || !next.pitch) return true;
	      return next.pitch.midiNumber !== this.parent.pitch.midiNumber;
	    }
	  }]);
	
	  return Tie;
	}();
	
	exports.default = Tie;

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Slur
	 * @class
	 * @param parent {Note|Chord}
	 */
	var Slur = function () {
	  function Slur(parent) {
	    _classCallCheck(this, Slur);
	
	    this.begin = '';
	    this.end = '';
	    this.toJSON = (0, _util.makeToJSON)({
	      begin: undefined,
	      end: undefined
	    });
	
	    this._parent = parent;
	  }
	
	  _createClass(Slur, [{
	    key: 'parent',
	
	
	    /**
	     * Parent music data.
	     * @type {Note|Chord}
	     * @readonly
	     */
	    get: function get() {
	      return this._parent;
	    }
	
	    /**
	     * Previous slurred parent.
	     * @type {Note|Chord}
	     * @readonly
	     */
	
	  }, {
	    key: 'prevParent',
	    get: function get() {
	      if (!this.end) return;
	
	      var prev = this.parent.prevInPart;
	      while (prev) {
	        if (prev.slur && !prev.slur.isEmpty) return prev;
	        prev = prev.prevInPart;
	      }
	    }
	
	    /**
	     * Next Slurred parent.
	     * @type {Note|Chord}
	     * @readonly
	     */
	
	  }, {
	    key: 'nextParent',
	    get: function get() {
	      if (!this.begin) return;
	
	      var next = this.parent.nextInPart;
	      while (next) {
	        if (next.slur && !next.slur.isEmpty) return next;
	        next = next.nextInPart;
	      }
	    }
	
	    /**
	     * @todo Nested tie in slur.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'prevCrossTie',
	    get: function get() {}
	
	    /**
	     * @todo Nested tie in slur.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'nextCrossTie',
	    get: function get() {}
	
	    /**
	     * If the previous slur has error.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'prevHasError',
	    get: function get() {
	      var prevParent = this.prevParent;
	
	      return !prevParent || !prevParent.slur.begin;
	    }
	
	    /**
	     * If the next slur has error.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'nextHasError',
	    get: function get() {
	      var nextParent = this.nextParent;
	
	      return !nextParent || !nextParent.slur.end;
	    }
	
	    /**
	     * If the slur is empty.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'isEmpty',
	    get: function get() {
	      return !(this.begin || this.end);
	    }
	
	    /**
	     * Convert the slur to JSON object.
	     * @method
	     * @return {Object} JSON object.
	     */
	
	  }]);
	
	  return Slur;
	}();
	
	exports.default = Slur;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	var _MusicData2 = __webpack_require__(10);
	
	var _MusicData3 = _interopRequireDefault(_MusicData2);
	
	var _Duration = __webpack_require__(14);
	
	var _Duration2 = _interopRequireDefault(_Duration);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * @class
	 * @param {rest} rest
	 * @mixes MusicDataMixin
	 * @mixes MusicDataLayoutMixin
	 */
	var Rest = function (_MusicData) {
	  _inherits(Rest, _MusicData);
	
	  function Rest(rest) {
	    _classCallCheck(this, Rest);
	
	    var _this = _possibleConstructorReturn(this, (Rest.__proto__ || Object.getPrototypeOf(Rest)).call(this));
	
	    _this.$type = 'rest';
	    _this.toJSON = (0, _util.makeToJSON)({
	      duration: undefined
	    }, 'rest');
	
	    (0, _util.extend)(_this, rest);
	    return _this;
	  }
	
	  /**
	   * Type of rest.
	   * @constant
	   * @default rest
	   */
	
	
	  _createClass(Rest, [{
	    key: 'toString',
	
	
	    /**
	     * Convert the rest to musje source code string.
	     * @return {string} Converted musje source code.
	     */
	    value: function toString() {
	      return '0' + this.duration;
	    }
	  }, {
	    key: 'defId',
	
	
	    /**
	     * Unique def id of the rest used in the SVG <defs> element.
	     * ```
	     * defId := 'r' type dot
	     * ```
	     * E.g.
	     * ```
	     * Rest     defId
	     * ----------------
	     * 0        r40
	     * 0 -      r20
	     * 0=.      r161
	     * ```
	     * @type {string}
	     * @readonly
	     */
	    get: function get() {
	      var _duration = this.duration,
	          type = _duration.type,
	          dot = _duration.dot;
	
	      return 'r' + type + dot;
	    }
	
	    /**
	     * Duration of the rest.
	     * @type {Duration}
	     */
	
	  }, {
	    key: 'duration',
	    get: function get() {
	      return this._duration || (this._duration = new _Duration2.default());
	    },
	    set: function set(duration) {
	      this._duration = new _Duration2.default(duration);
	    }
	  }, {
	    key: 'beams',
	    get: function get() {
	      return this._beams || (this._beams = []);
	    },
	    set: function set(beams) {
	      this._beams = beams;
	    }
	  }]);
	
	  return Rest;
	}(_MusicData3.default);
	
	exports.default = Rest;

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	var _MusicData2 = __webpack_require__(10);
	
	var _MusicData3 = _interopRequireDefault(_MusicData2);
	
	var _Pitch = __webpack_require__(13);
	
	var _Pitch2 = _interopRequireDefault(_Pitch);
	
	var _Duration = __webpack_require__(14);
	
	var _Duration2 = _interopRequireDefault(_Duration);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * @class
	 * @param {Object} chord
	 * @mixes MusicDataMixin
	 * @mixes MusicDataLayoutMixin
	 */
	var Chord = function (_MusicData) {
	  _inherits(Chord, _MusicData);
	
	  function Chord(chord) {
	    _classCallCheck(this, Chord);
	
	    var _this = _possibleConstructorReturn(this, (Chord.__proto__ || Object.getPrototypeOf(Chord)).call(this));
	
	    _this.$type = 'chord';
	    _this.toJSON = (0, _util.makeToJSON)({
	      pitches: undefined,
	      duration: undefined
	    }, 'chord');
	
	    (0, _util.extend)(_this, chord);
	    return _this;
	  }
	
	  /**
	   * Type of chord.
	   * @constant
	   * @default chord
	   */
	
	
	  _createClass(Chord, [{
	    key: 'toString',
	
	
	    /**
	     * Convert chord to the musje source code string.
	     * @return {string} Converted musje source code of the chord.
	     */
	    value: function toString() {
	      return '<' + this.pitches.map(function (pitch) {
	        return pitch.toString();
	      }).join('') + '>' + this.duration;
	    }
	  }, {
	    key: 'pitches',
	
	
	    /**
	     * Pitches in the chord.
	     * @type {Array.<Pitch>}
	     */
	    get: function get() {
	      return this._pitches || (this._pitches = []);
	    },
	    set: function set(pitches) {
	      this._pitches = pitches.map(function (pitch) {
	        return new _Pitch2.default(pitch);
	      });
	    }
	
	    /**
	     * Duration of the chord.
	     * @type {Duration}
	     */
	
	  }, {
	    key: 'duration',
	    get: function get() {
	      return this._duration || (this._duration = new _Duration2.default());
	    },
	    set: function set(duration) {
	      this._duration = new _Duration2.default(duration);
	    }
	  }]);
	
	  return Chord;
	}(_MusicData3.default);
	
	exports.default = Chord;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _util = __webpack_require__(2);
	
	var _MusicData2 = __webpack_require__(10);
	
	var _MusicData3 = _interopRequireDefault(_MusicData2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	/**
	 * @class
	 * @param {Object} voice
	 */
	var Voice = function (_MusicData) {
	  _inherits(Voice, _MusicData);
	
	  function Voice(voice) {
	    _classCallCheck(this, Voice);
	
	    var _this = _possibleConstructorReturn(this, (Voice.__proto__ || Object.getPrototypeOf(Voice)).call(this));
	
	    _this.$type = 'voice';
	
	    (0, _util.extend)(_this, voice);
	    return _this;
	  }
	
	  /**
	   * Type of voice.
	   * @constant
	   * @default voice
	   */
	
	
	  _createClass(Voice, [{
	    key: 'toString',
	
	
	    /**
	     * Convert the voice to musje source code string.
	     * @return {string} Converted musje source code string.
	     */
	    value: function toString() {}
	  }]);
	
	  return Voice;
	}(_MusicData3.default);
	
	exports.default = Voice;

/***/ },
/* 20 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * A [beam][wiki] is a horizontal or diagonal line used to connect multiple consecutive notes (and occasionally rests) in order to indicate rhythmic grouping. Only eighth notes (quavers) or shorter can be beamed.
	 *
	 * [wiki]: https://en.wikipedia.org/wiki/Beam_(music)
	 *
	 * Beam is created by {@link Cell#makeBeams} and
	 * attached to {@link Durable} in {@link Durable#beams}[level]
	 * @class
	 * @param {string} value - Beam value: `'begin'`, `'continue'` or `'end'`.
	 * @param {number} level - Beam level starting from 0 to up.
	 * @param {Durable} parent - The parent durable music data.
	 */
	var Beam = function () {
	  function Beam(value, level, parent) {
	    _classCallCheck(this, Beam);
	
	    this._value = value;
	    this._level = level;
	    this._parent = parent;
	  }
	
	  /**
	   * Parent
	   * @type {Note|Rest|Chord}
	   * @readonly
	   */
	
	
	  _createClass(Beam, [{
	    key: 'parent',
	    get: function get() {
	      return this._parent;
	    }
	
	    /**
	     * Beam value: `'begin'`, `'continue'` or `'end'`.
	     * @type {string}
	     * @readonly
	     */
	
	  }, {
	    key: 'value',
	    get: function get() {
	      return this._value;
	    }
	
	    /**
	     * Beam level starting from 0 to up.
	     * @type {number}
	     * @readonly
	     */
	
	  }, {
	    key: 'level',
	    get: function get() {
	      return this._level;
	    }
	
	    /**
	     * The end parent music data of the beam group.
	     * @type {MusicDataMixin}
	     */
	
	  }, {
	    key: 'endDurable',
	    get: function get() {
	      var nextData = this.parent.next;
	      while (nextData && nextData.beams[this.level].value !== 'end') {
	        nextData = nextData.next;
	      }
	      return nextData;
	    }
	  }]);
	
	  return Beam;
	}();
	
	exports.default = Beam;

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _TimewiseMeasure = __webpack_require__(22);
	
	var _TimewiseMeasure2 = _interopRequireDefault(_TimewiseMeasure);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _extendableBuiltin(cls) {
	  function ExtendableBuiltin() {
	    cls.apply(this, arguments);
	  }
	
	  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
	    constructor: {
	      value: cls,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	
	  if (Object.setPrototypeOf) {
	    Object.setPrototypeOf(ExtendableBuiltin, cls);
	  } else {
	    ExtendableBuiltin.__proto__ = cls;
	  }
	
	  return ExtendableBuiltin;
	}
	
	/**
	 * Construct timewise score measures.
	 * @class
	 * @classdesc Timewise score measures.
	 * @param score {Score}
	 * @augments {Array}
	 */
	var TimewiseMeasures = function (_extendableBuiltin2) {
	  _inherits(TimewiseMeasures, _extendableBuiltin2);
	
	  function TimewiseMeasures(score) {
	    _classCallCheck(this, TimewiseMeasures);
	
	    var _this = _possibleConstructorReturn(this, (TimewiseMeasures.__proto__ || Object.getPrototypeOf(TimewiseMeasures)).call(this));
	
	    _this._score = score;
	    return _this;
	  }
	
	  /**
	   * Reference to the parent score.
	   * @type {Score}
	   * @readonly
	   */
	
	
	  _createClass(TimewiseMeasures, [{
	    key: 'fromPartwise',
	
	
	    /**
	     * Make timewise score measures from the partwise parts.
	     */
	    value: function fromPartwise() {
	      var _this2 = this;
	
	      this.removeAll();
	      this.score.walkCells(function (cell, m) {
	        if (m === _this2.length && !_this2[m]) _this2.push(new _TimewiseMeasure2.default(m, _this2));
	        _this2[m].parts.push(cell);
	      });
	    }
	
	    /**
	     * Remove all measures.
	     */
	
	  }, {
	    key: 'removeAll',
	    value: function removeAll() {
	      this.length = 0;
	    }
	  }, {
	    key: 'score',
	    get: function get() {
	      return this._score;
	    }
	  }]);
	
	  return TimewiseMeasures;
	}(_extendableBuiltin(Array));
	
	exports.default = TimewiseMeasures;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _snapsvg = __webpack_require__(8);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @class
	 * @param measure {Object}
	 * @mixes TimewiseMeasureLayoutMixin
	 */
	var TimewiseMeasure = function () {
	  function TimewiseMeasure(index, measures) {
	    _classCallCheck(this, TimewiseMeasure);
	
	    // this._index = index
	    this._measures = measures;
	  }
	
	  /**
	   * Reference to the parent measures instance.
	   * @member {TimewiseMeasures}
	   */
	
	
	  _createClass(TimewiseMeasure, [{
	    key: 'flow',
	
	
	    /**
	     * Flow the measure.
	     */
	    value: function flow() {
	      var _this = this;
	
	      this.parts.forEach(function (cell) {
	
	        /**
	         * Cell SVG group element.
	         * @memberof CellLayout#
	         * @alias el
	         * @type {Snap.Element}
	         * @readonly
	         */
	        cell.el = _this.el.g().addClass('mus-cell');
	
	        cell.x = _this.outerWidthLeft;
	
	        // cell.drawBox()
	      });
	    }
	
	    /**
	     * Draw box of the cell.
	     * @return {Snap.Element} The box SVG rect element.
	     */
	
	  }, {
	    key: 'drawBox',
	    value: function drawBox() {
	      this._boxEl = this.el.rect(0, 0, this.width, this.height).attr({ stroke: 'green', fill: 'none' });
	    }
	
	    /**
	     * Clear the box SVG element.
	     */
	
	  }, {
	    key: 'clearBox',
	    value: function clearBox() {
	      this._boxEl.remove();
	      this._boxEl = undefined;
	    }
	  }, {
	    key: 'measures',
	    get: function get() {
	      return this._measures;
	    }
	
	    /**
	     * Parts in timewise measure.
	     * @type {Array.<Cell>}
	     */
	
	  }, {
	    key: 'parts',
	    get: function get() {
	      return this._parts || (this._parts = []);
	    },
	    set: function set(parts) {
	      this._parts = parts;
	    }
	
	    /**
	     * Left bar of the measure.
	     * @type {Bar}
	     * @readonly
	     */
	
	  }, {
	    key: 'barLeft',
	    get: function get() {
	      return this.parts[0].barLeft;
	    }
	
	    /**
	     * Right bar of the measure.
	     * @type {Bar}
	     * @readonly
	     */
	
	  }, {
	    key: 'barRight',
	    get: function get() {
	      return this.parts[0].barRight;
	    }
	
	    /**
	     * Measure SVG group element.
	     * @type {Snap.Element}
	     * @readonly
	     */
	
	  }, {
	    key: 'el',
	    get: function get() {
	      return this._el;
	    }
	
	    /**
	     * Minimun width of the measure.
	     * @type {number}
	     */
	
	  }, {
	    key: 'minWidth',
	    get: function get() {
	      var minWidth = 0;
	      this.parts.forEach(function (cell) {
	        minWidth = Math.max(minWidth, cell.minWidth);
	      });
	      return minWidth + this.padding;
	    }
	
	    /**
	     * Reference to the parent system of this measure.
	     * - (Getter)
	     * - (Setter) The measure el will be created, and the height of the measure will be set.
	     * @type {SystemLayout}
	     */
	
	  }, {
	    key: 'system',
	    get: function get() {
	      return this._s;
	    },
	    set: function set(system) {
	      this._s = system;
	      this._el = system.el.g().addClass('mus-measure');
	    }
	  }, {
	    key: 'padding',
	    get: function get() {
	      var lo = this.layout.options;
	      return lo.measurePaddingRight + lo.measurePaddingLeft;
	    }
	  }, {
	    key: 'outerWidth',
	    get: function get() {
	      return this.outerWidthLeft + this.outerWidthRight;
	    }
	  }, {
	    key: 'outerWidthLeft',
	    get: function get() {
	      return this.layout.options.measurePaddingLeft + this.barLeftInSystem.width / 2;
	    }
	  }, {
	    key: 'outerWidthRight',
	    get: function get() {
	      return this.layout.options.measurePaddingRight + this.barRightInSystem.width / 2;
	    }
	
	    /**
	     * Width of the measure.
	     * @type {number}
	     */
	
	  }, {
	    key: 'width',
	    get: function get() {
	      return this._w || (this._w = this.minWidth);
	    },
	    set: function set(w) {
	      var _this2 = this;
	
	      this._w = w;
	      this.parts.forEach(function (cell) {
	        cell.width = w - _this2.outerWidth;
	      });
	    }
	  }, {
	    key: 'height',
	    get: function get() {
	      return this.system.height;
	    }
	  }, {
	    key: 'minHeight',
	    get: function get() {
	      var partSep = this.layout.options.partSep;
	
	      var minHeight = 0;
	
	      this.parts.forEach(function (cell) {
	        minHeight += cell.height + partSep;
	      });
	      return minHeight ? minHeight - partSep : 0;
	    }
	
	    /**
	     * The x position of the measure in the system.
	     * - (Getter)
	     * - (Setter) Set x cause the measure element to translate.
	     * @type {number}
	     */
	
	  }, {
	    key: 'x',
	    get: function get() {
	      return this._x;
	    },
	    set: function set(x) {
	      this._x = x;
	      this.el.transform(Snap.matrix().translate(x, 0));
	    }
	
	    /**
	     * If the measure in the beginning of the system.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'inSystemBegin',
	    get: function get() {
	      return this._sIndex === 0;
	    }
	
	    /**
	     * If the measure in the end of the system.
	     * @type {boolean}
	     * @readonly
	     */
	
	  }, {
	    key: 'inSystemEnd',
	    get: function get() {
	      return this._sIndex === this.system.measures.length - 1;
	    }
	
	    /**
	     * Left bar of the measure in system.
	     * @type {musje.Bar}
	     * @readonly
	     */
	
	  }, {
	    key: 'barLeftInSystem',
	    get: function get() {
	      return this.parts[0].barLeftInSystem;
	    }
	
	    /**
	     * Right bar of the measure in system.
	     * @type {Bar}
	     * @readonly
	     */
	
	  }, {
	    key: 'barRightInSystem',
	    get: function get() {
	      return this.parts[0].barRightInSystem;
	    }
	  }]);
	
	  return TimewiseMeasure;
	}();
	
	exports.default = TimewiseMeasure;

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _snapsvg = __webpack_require__(8);
	
	var _util = __webpack_require__(2);
	
	var _Layout = __webpack_require__(24);
	
	var _Layout2 = _interopRequireDefault(_Layout);
	
	var _renderBar = __webpack_require__(38);
	
	var _renderBar2 = _interopRequireDefault(_renderBar);
	
	var _renderDuration = __webpack_require__(39);
	
	var _renderDuration2 = _interopRequireDefault(_renderDuration);
	
	var _renderCurve = __webpack_require__(40);
	
	var _renderCurve2 = _interopRequireDefault(_renderCurve);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Renderer = function () {
	  function Renderer(svg, lo) {
	    _classCallCheck(this, Renderer);
	
	    this._lo = (0, _util.extend)(_Layout2.default.options, lo);
	    this.layout = new _Layout2.default(svg, this._lo);
	  }
	
	  _createClass(Renderer, [{
	    key: 'render',
	    value: function render(score) {
	      this._score = score;
	      this.layout.flow(score);
	      this.renderHeader();
	      this.renderContent();
	    }
	  }, {
	    key: 'renderHeader',
	    value: function renderHeader() {
	      var lo = this._lo;
	      var header = this.layout.header;
	      var el = header.el,
	          width = header.width;
	
	
	      el.text(width / 2, lo.titleFontSize, this._score.head.title).attr({
	        fontSize: lo.titleFontSize * 2,
	        fontWeight: lo.titleFontWeight,
	        textAnchor: 'middle'
	      });
	
	      el.text(width, lo.titleFontSize * 1.5, this._score.head.composer).attr({
	        fontSize: lo.composerFontSize,
	        fontWeight: lo.composerFontWeight,
	        textAnchor: 'end'
	      });
	
	      header.height = el.getBBox().height;
	    }
	  }, {
	    key: 'renderContent',
	    value: function renderContent() {
	      var lo = this._lo;
	
	      this.layout.content.systems.forEach(function (system) {
	        var measures = system.measures;
	
	        measures.forEach(function (measure) {
	          (0, _renderBar2.default)(measure, lo);
	          measure.parts.forEach(function (cell) {
	            renderCell(cell, lo);
	          });
	        });
	      });
	    }
	  }]);
	
	  return Renderer;
	}();
	
	function renderNote(note, cell, lo) {
	  note.el = cell.el.g().transform((0, _snapsvg.matrix)().translate(note.x, note.y));
	  note.el.use(note.def.pitchDef.el);
	  (0, _renderDuration2.default)(note, lo);
	}
	
	function renderCell(cell, lo) {
	  cell.data.forEach(function (data) {
	    switch (data.$type) {
	      case 'rest':
	        renderNote(data, cell, lo);
	        break;
	      case 'note':
	        renderNote(data, cell, lo);
	        (0, _renderCurve2.default)('tie', data);
	        (0, _renderCurve2.default)('slur', data);
	        break;
	      case 'time':
	        data.el = cell.el.use(data.def.el).attr({ x: data.x, y: data.y });
	        break;
	      default:
	    }
	  });
	}
	
	exports.default = Renderer;

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _layoutOptions = __webpack_require__(25);
	
	var _layoutOptions2 = _interopRequireDefault(_layoutOptions);
	
	var _Defs = __webpack_require__(26);
	
	var _Defs2 = _interopRequireDefault(_Defs);
	
	var _SvgLayout = __webpack_require__(33);
	
	var _SvgLayout2 = _interopRequireDefault(_SvgLayout);
	
	var _BodyLayout = __webpack_require__(34);
	
	var _BodyLayout2 = _interopRequireDefault(_BodyLayout);
	
	var _HeaderLayout = __webpack_require__(35);
	
	var _HeaderLayout2 = _interopRequireDefault(_HeaderLayout);
	
	var _ContentLayout = __webpack_require__(36);
	
	var _ContentLayout2 = _interopRequireDefault(_ContentLayout);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @class
	 * @param svg {string}
	 * @param options {Object} Layout options
	 */
	var Layout = function () {
	  function Layout(svg, options) {
	    _classCallCheck(this, Layout);
	
	    this.options = options;
	    this.svg = svg;
	
	    this.svg = new _SvgLayout2.default(this);
	    this.body = new _BodyLayout2.default(this);
	    this.header = new _HeaderLayout2.default(this);
	    this.content = new _ContentLayout2.default(this);
	
	    this.defs = new _Defs2.default(this);
	  }
	
	  /**
	   * @param  {Score} score
	   */
	
	
	  _createClass(Layout, [{
	    key: 'flow',
	    value: function flow(score) {
	      init(this, score);
	      this.content.flow(score.measures);
	    }
	  }]);
	
	  return Layout;
	}();
	
	Layout.options = _layoutOptions2.default;
	
	function init(that, score) {
	  var measures = score.measures;
	
	  measures.forEach(function (measure, m) {
	    measure = measures[m];
	    measure.layout = that;
	    measure.parts.forEach(function (cell) {
	      cell.layout = that;
	      cell.flow();
	    });
	  });
	}
	
	exports.default = Layout;

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _util = __webpack_require__(2);
	
	var layoutOptions = {
	  mode: 'block', // inline | block | paper
	  // width: 650,
	  // height: 600,
	  marginTop: 25,
	  marginRight: 30,
	  marginBottom: 25,
	  marginLeft: 30,
	
	  fontSize: 20,
	  fontFamily: 'Helvetica, Arial, Sans Serif',
	
	  titleFontSize: '110%',
	  // titleFontFamily
	  titleFontWeight: 'bold',
	  composerFontSize: '90%',
	  // composerFontFamily:
	  composerFontWeight: 'bold',
	  // composerFontStyle,
	  timeFontSize: '95%',
	  timeFontWeight: 'bold',
	
	  headerSep: '100%',
	  systemSep: '180%',
	  musicDataSep: '20%',
	
	  partHeight: '120%',
	  partSep: '80%',
	
	  measurePaddingLeft: '50%',
	  measurePaddingRight: '50%',
	
	  barlineHeight: '120%',
	  thinBarlineWidth: '4%',
	  thickBarlineWidth: '16%',
	  barlineSep: '18%',
	  barlineDotRadius: '7.5%',
	  barlineDotSep: '22%',
	
	  accidentalFontSize: '95%',
	  accidentalShift: '10%',
	
	  octaveRadius: '6.6%',
	  octaveOffset: '0%',
	  octaveSep: '23%',
	
	  stepBaselineShift: '12%', // for step without lower octave and underline
	
	  typeStrokeWidth: '5%',
	  typebarOffset: '30%', // 1 - - -
	  typebarLength: '55%', // off len sep len sep len (dot) ext
	  typebarSep: '45%', // 1 -
	  typebarExt: '20%', // off len (dot) ext
	  underbarSep: '17%',
	
	  dotOffset: '60%', // for type = 2
	  dotRadius: '6.6%', // 1 - . .
	  dotSep: '60%', // off len dotOff . dotSep . ext
	  t4DotOffset: '30%',
	  t4DotSep: '50%',
	  t4DotExt: '25%',
	  t4DotBaselineShift: '20%'
	};
	
	var fontSize = layoutOptions.fontSize;
	
	
	(0, _util.objEach)(layoutOptions, function (value, key) {
	  if (typeof value !== 'string') return;
	
	  var unit = value.replace(/[\d\.]+/, '');
	  value = +value.replace(/[^\d\.]+/, '');
	
	  switch (unit) {
	    case '%':
	      layoutOptions[key] = fontSize * value / 100;
	      break;
	    case '':
	    // fall through
	    case 'px':
	      layoutOptions[key] = value;
	      break;
	    case 'others to be implemented':
	      break;
	    default:
	  }
	});
	
	exports.default = layoutOptions;

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _AccidentalDef = __webpack_require__(27);
	
	var _AccidentalDef2 = _interopRequireDefault(_AccidentalDef);
	
	var _BarDef = __webpack_require__(29);
	
	var _BarDef2 = _interopRequireDefault(_BarDef);
	
	var _DurationDef = __webpack_require__(30);
	
	var _DurationDef2 = _interopRequireDefault(_DurationDef);
	
	var _PitchDef = __webpack_require__(31);
	
	var _PitchDef2 = _interopRequireDefault(_PitchDef);
	
	var _TimeDef = __webpack_require__(32);
	
	var _TimeDef2 = _interopRequireDefault(_TimeDef);
	
	var _Note = __webpack_require__(12);
	
	var _Note2 = _interopRequireDefault(_Note);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @class
	 * @param {Layout} layout
	 */
	var Defs = function () {
	  function Defs(layout) {
	    _classCallCheck(this, Defs);
	
	    this._layout = layout;
	  }
	
	  /**
	   * Get the svg def of the music data.
	   * @param  musicData {MusicDataMixin} music data
	   * @return {Def}
	   */
	
	
	  _createClass(Defs, [{
	    key: 'get',
	    value: function get(musicData) {
	      var id = musicData.defId;
	      return this[id] || (this[id] = makeDef(id, musicData, this));
	    }
	  }, {
	    key: 'getAccidental',
	    value: function getAccidental(accidental) {
	      var id = 'a' + accidental.replace(/#/g, 's');
	      return this[id] || (this[id] = new _AccidentalDef2.default(id, accidental, this._layout));
	    }
	  }, {
	    key: '_getPitch',
	    value: function _getPitch(id, pitch, underbar) {
	      return this[id] || (this[id] = new _PitchDef2.default(id, pitch, underbar, this));
	    }
	  }]);
	
	  return Defs;
	}();
	
	function makeDef(id, musicData, defs) {
	  switch (musicData.$type) {
	    case 'bar':
	      return new _BarDef2.default(id, musicData, defs._layout);
	    case 'time':
	      return new _TimeDef2.default(id, musicData, defs._layout);
	    case 'note':
	      return makeNoteDef(musicData, defs);
	    case 'rest':
	      return makeRestDef(musicData, defs);
	    case 'duration':
	      return new _DurationDef2.default(id, musicData, defs._layout);
	    default:
	      return { width: 0, height: 0 };
	  }
	}
	
	function makeNoteDef(note, defs) {
	  var underbar = note.duration.underbar;
	  var pitchId = note.pitch.defId + underbar;
	  var pitchDef = defs._getPitch(pitchId, note.pitch, underbar);
	  var durationDef = defs.get(note.duration);
	  return {
	    pitchDef: pitchDef,
	    durationDef: durationDef,
	    height: pitchDef.height,
	    width: pitchDef.width + durationDef.width * 1
	    // (underbar ? pitchDef.scale.x : 1)
	  };
	}
	
	function makeRestDef(rest, defs) {
	  var restNote = new _Note2.default({ pitch: { step: 0 }, duration: rest.duration });
	  return makeNoteDef(restNote, defs);
	}
	
	exports.default = Defs;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _snapsvg = __webpack_require__(8);
	
	var _snapsvg2 = _interopRequireDefault(_snapsvg);
	
	var _svgPaths = __webpack_require__(28);
	
	var _svgPaths2 = _interopRequireDefault(_svgPaths);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * SVG definition for accidental.
	 * @class
	 * @param {string} id         [description]
	 * @param {string} accidental [description]
	 * @param {Layout} layout     [description]
	 */
	function AccidentalDef(id, accidental, layout) {
	  var _layout$options = layout.options,
	      accidentalShift = _layout$options.accidentalShift,
	      accidentalFontSize = _layout$options.accidentalFontSize;
	
	  var el = this.el = layout.svg.el.g().attr('id', id);
	  var accKey = accidental.replace(/bb/, 'b'); // double flat to be synthesized
	  var pathData = _svgPaths2.default[accKey];
	  var ratio = _svgPaths2.default.ACCIDENTAL_RATIOS[accKey];
	  var shift = _svgPaths2.default.ACCIDENTAL_SHIFTS[accKey];
	  var path = el.path(pathData);
	  var bb = el.getBBox();
	
	  path.transform(_snapsvg2.default.matrix().translate(0.1 * accidentalShift, -accidentalShift).scale(ratio * accidentalFontSize).translate(-bb.x, shift - bb.y2));
	
	  // Combine two flat to be double flat.
	  if (accidental === 'bb') {
	    el.use(path).attr('x', accidentalFontSize * 0.24);
	    el.transform('scale(0.9,1)');
	  }
	
	  bb = el.getBBox();
	  this.width = bb.width * 1.2;
	
	  el.toDefs();
	}
	
	exports.default = AccidentalDef;

/***/ },
/* 28 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var svgPaths = {
	  // https://upload.wikimedia.org/wikipedia/commons/a/a6/Sharp.svg
	  '#': 'M6.102,7.457V2.753L8.102,2.201V6.881L6.102,7.457zM10.04,6.319L8.665,6.713V2.033L10.04,1.649V-0.295L8.665,0.089V-4.69277H8.102V0.234L6.102,0.809V-3.84077H5.571V0.986L4.196,1.371V3.319L5.571,2.935V7.606L4.196,7.989V9.929L5.571,9.545V14.299L6.102,14.29977V9.375L8.102,8.825V13.45077H8.665V8.651L10.04,8.266V6.319z',
	
	  // https://upload.wikimedia.org/wikipedia/commons/3/3a/DoubleSharp.svg
	  '##': 'M5.009,8.30721C4.27443,8.19192 3.52769,8.19209 2.7858,8.19294C2.77007,7.65011 2.85674,7.0729 2.6415,6.56343C2.49821,6.22426 2.22532,5.95665 1.98269,5.68155C1.59552,6.0278 1.27751,6.48475 1.24704,7.01638C1.21706,7.40767 1.23902,7.80085 1.2322,8.19294C0.4904,8.20416-0.25918,8.16828-0.991,8.314C-0.84988,7.5863-0.88195,6.84171-0.86917,6.1048C-0.3043,6.08953 0.30023,6.17101 0.82484,5.92526C1.13441,5.78023 1.39653,5.55295 1.6591,5.33676C1.3173,4.94965 0.87346,4.60861 0.33665,4.57651C-0.06427,4.54485-0.46734,4.56793-0.86917,4.56097C-0.89434,3.82949-0.80895,3.08855-0.96079,2.3663C-0.23733,2.49697 0.50065,2.46343 1.2322,2.47284C1.24306,2.99383 1.18483,3.53381 1.33191,4.0355C1.44414,4.41838 1.74978,4.71293 2.0051,5.01521C2.36553,4.70111 2.69057,4.30706 2.75011,3.81412C2.804,3.36793 2.76123,2.91977 2.7858,2.47284C3.52263,2.45348 4.28215,2.54713 4.99535,2.314C4.88891,3.05711 4.87889,3.81152 4.88717,4.56097C4.36127,4.57582 3.80954,4.51747 3.30955,4.69457C2.92975,4.8291 2.63114,5.12341 2.32869,5.38325C2.65661,5.71867 3.0516,6.02802 3.5403,6.07368C3.98834,6.11554 4.43829,6.09658 4.88717,6.1048C4.89828,6.83958 4.86193,7.5825 5.009,8.30721z',
	
	  // https://upload.wikimedia.org/wikipedia/commons/b/ba/Flat.svg
	  b: 'M8.166,3.657C8.166,4.232 7.950425,4.78273 7.359,5.52188C6.732435,6.30494 6.205,6.75313 5.51,7.28013V3.848C5.668,3.449 5.901,3.126 6.21,2.878C6.518,2.631 6.83,2.507 7.146,2.507C7.668,2.507 7.999,2.803 8.142,3.393C8.158,3.441 8.166,3.529 8.166,3.657zM8.091,1.257C7.66,1.257 7.222,1.376 6.776,1.615C6.33,1.853 5.908,2.172 5.51,2.569V-4.70267H4.947 V7.75213C4.947,8.10413 5.043,8.28013 5.235,8.28013C5.346,8.28013 5.483913,8.18713 5.69,8.06413C6.27334,7.71598 6.636935,7.48332 7.032,7.23788C7.482617,6.95792 7.99,6.631 8.661,5.991C9.124,5.526 9.459,5.057 9.667,4.585C9.874,4.112 9.978,3.644 9.978,3.179C9.978,2.491 9.795,2.002 9.429,1.713C9.015,1.409 8.568,1.257 8.091,1.257z',
	
	  // https://upload.wikimedia.org/wikipedia/commons/f/f4/Music-natural.svg
	  n: 'M 0,14.112V41.52h-1.248V31.248l-6.672,1.728V5.232h1.2v10.704l6.72,-1.824zm-6.72,6.432v7.536l5.472,-1.44v-7.536l-5.472,1.44z',
	
	  ACCIDENTAL_RATIOS: { '#': 0.043, 'n': 0.023, '##': 0.062, b: 0.057 },
	  ACCIDENTAL_SHIFTS: { '#': 1, 'n': 2, '##': -4, b: 0 }
	};
	
	exports.default = svgPaths;

/***/ },
/* 29 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * SVG definition for barline.
	 * @class
	 * @param {string} id     [description]
	 * @param {Bar} bar    [description]
	 * @param {Layout} layout [description]
	 */
	function BarDef(id, bar, layout) {
	  var _layout$options = layout.options,
	      thinBarlineWidth = _layout$options.thinBarlineWidth,
	      thickBarlineWidth = _layout$options.thickBarlineWidth,
	      barlineSep = _layout$options.barlineSep,
	      barlineDotSep = _layout$options.barlineDotSep,
	      barlineDotRadius = _layout$options.barlineDotRadius;
	
	  var x = 0;
	  var lineWidth = void 0;
	  this.el = layout.svg.el.g().attr('id', id).toDefs();
	
	  switch (bar.value) {
	    case 'single':
	      lineWidth = thinBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth;
	      break;
	    case 'double':
	      lineWidth = thinBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth + barlineSep;
	      addBarline(this, x, lineWidth);
	      x += lineWidth;
	      break;
	    case 'end':
	      lineWidth = thinBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth + barlineSep;
	      lineWidth = thickBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth;
	      break;
	    case 'repeat-begin':
	      lineWidth = thickBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth + barlineSep;
	      lineWidth = thinBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth + barlineDotSep + barlineDotRadius;
	      break;
	    case 'repeat-end':
	      x = barlineDotSep + barlineDotRadius;
	      lineWidth = thinBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth + barlineSep;
	      lineWidth = thickBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth;
	      break;
	    case 'repeat-both':
	      x = barlineDotSep + barlineDotRadius;
	      lineWidth = thinBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth + barlineSep;
	      lineWidth = thickBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth + barlineSep;
	      lineWidth = thinBarlineWidth;
	      addBarline(this, x, lineWidth);
	      x += lineWidth + barlineDotSep + barlineDotRadius;
	      break;
	    default:
	  }
	  this.width = x;
	}
	
	function addBarline(that, x, width) {
	  that.el.rect(x, 0, width, 1);
	}
	
	exports.default = BarDef;

/***/ },
/* 30 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * SVG definition for duration.
	 * @class
	 * @param {string} id       [description]
	 * @param {Duration} duration [description]
	 * @param {Layout} layout   [description]
	 */
	function DurationDef(id, duration, layout) {
	  this._id = id;
	  this._layout = layout;
	
	  // only make def el for:
	  // id = d10, d11, d12, d20, d21, d20, d41, d40
	  switch (duration.type) {
	    case 1:
	      // whole note
	      makeEl(this);
	      makeType1(this, id, duration.dot);
	      break;
	    case 2:
	      // half note
	      makeEl(this);
	      makeType2(this, id, duration.dot);
	      break;
	    default:
	      // other note types type quarter note def
	      if (duration.dot === 0) {
	        this.width = 0;
	      } else {
	        makeEl(this);
	        makeType4(this, id, duration.dot);
	      }
	  }
	}
	
	function makeType1(that, id, dot) {
	  var _that$_layout$options = that._layout.options,
	      typebarLength = _that$_layout$options.typebarLength,
	      typebarSep = _that$_layout$options.typebarSep,
	      typebarOffset = _that$_layout$options.typebarOffset;
	
	  var x = typebarOffset;
	
	  addLine(that, x);
	  x += typebarLength + typebarSep;
	  addLine(that, x);
	  x += typebarLength + typebarSep;
	  addLine(that, x);
	  x += typebarLength;
	
	  that.width = addDot(that, x, dot, 1);
	}
	
	function makeType2(that, id, dot) {
	  var _that$_layout$options2 = that._layout.options,
	      typebarOffset = _that$_layout$options2.typebarOffset,
	      typebarLength = _that$_layout$options2.typebarLength;
	
	  var x = typebarOffset;
	
	  addLine(that, typebarOffset);
	  x += typebarLength;
	  that.width = addDot(that, x, dot, 2);
	}
	
	function makeType4(that, id, dot) {
	  var _that$_layout$options3 = that._layout.options,
	      t4DotOffset = _that$_layout$options3.t4DotOffset,
	      t4DotBaselineShift = _that$_layout$options3.t4DotBaselineShift,
	      t4DotSep = _that$_layout$options3.t4DotSep,
	      t4DotExt = _that$_layout$options3.t4DotExt,
	      dotRadius = _that$_layout$options3.dotRadius;
	
	  var x = t4DotOffset;
	
	  that.el.circle(x, -t4DotBaselineShift, dotRadius);
	
	  if (dot > 1) {
	    x += t4DotSep;
	    that.el.circle(x, -t4DotBaselineShift, dotRadius);
	  }
	  that.width = x + t4DotExt;
	}
	
	function makeEl(that) {
	  that.el = that._layout.svg.el.g().attr('id', that._id).toDefs();
	}
	
	function addLine(that, x) {
	  var _that$_layout$options4 = that._layout.options,
	      typeStrokeWidth = _that$_layout$options4.typeStrokeWidth,
	      typebarLength = _that$_layout$options4.typebarLength;
	
	  that.el.rect(x, -typeStrokeWidth, typebarLength, typeStrokeWidth);
	}
	
	// Add dot for type 1 (whole) or type 2 (half) note.
	function addDot(that, x, dot, type) {
	  var _that$_layout$options5 = that._layout.options,
	      dotOffset = _that$_layout$options5.dotOffset,
	      dotSep = _that$_layout$options5.dotSep,
	      dotRadius = _that$_layout$options5.dotRadius,
	      typebarExt = _that$_layout$options5.typebarExt;
	
	
	  if (dot > 0) {
	    x += dotOffset * (type === 1 ? 1.2 : 1);
	    that.el.circle(x, 0, dotRadius);
	  }
	  if (dot > 1) {
	    x += dotSep * (type === 1 ? 1.2 : 1);
	    that.el.circle(x, 0, dotRadius);
	  }
	  return x + typebarExt;
	}
	
	exports.default = DurationDef;

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _snapsvg = __webpack_require__(8);
	
	var _snapsvg2 = _interopRequireDefault(_snapsvg);
	
	var _util = __webpack_require__(2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * SVG definition for pitch.
	 * The `PitchDef` is defined by properties: a s o u
	 * accidental step octave underbar
	 * @class
	 * @param id {string}     [description]
	 * @param pitch {Pitch}   [description]
	 * @param layout {Layout} [description]
	 */
	function PitchDef(id, pitch, underbar, defs) {
	  var layout = this._layout = defs._layout;
	  var accidental = pitch.accidental,
	      octave = pitch.octave;
	  // const scale = getScale(accidental, octave, underbar)
	
	  var el = this.el = layout.svg.el.g().attr({
	    id: id,
	    stroke: 'black',
	    strokeWidth: 0.1 // - (scale.x + scale.y)
	  });
	  var matrix = void 0,
	      sbbox = void 0,
	      pbbox = void 0;
	
	  this._defs = defs;
	  addAccidental(this, accidental);
	  addStep(this, pitch.step);
	  addOctave(this, octave);
	
	  matrix = getMatrix(this, octave, underbar);
	  el.transform(matrix);
	
	  sbbox = this._sbbox;
	  sbbox = getBBoxAfterTransform(this.el, sbbox, matrix);
	
	  pbbox = el.getBBox();
	  el.toDefs();
	
	  (0, _util.extend)(this, {
	    // scale,
	    matrix: matrix,
	    width: pbbox.width,
	    height: -pbbox.y,
	    stepCx: sbbox.cx,
	    stepY: sbbox.y,
	    stepCy: sbbox.cy,
	    stepY2: sbbox.y2,
	    stepTop: octave > 0 ? pbbox.y : sbbox.y + layout.options.fontSize * 0.2
	  });
	}
	
	function addAccidental(that, accidental) {
	  if (!accidental) {
	    that._accidentalX2 = 0;
	    return;
	  }
	  var accDef = that._defs.getAccidental(accidental);
	  that.el.use(accDef.el).attr('y', -that._layout.options.accidentalShift);
	  that._accidentalX2 = accDef.width;
	}
	
	// step在这里就是音阶的数字
	function addStep(that, step) {
	  that._sbbox = that.el.text(that._accidentalX2, 0, '' + step).attr('font-size', that._layout.options.fontSize).getBBox();
	}
	
	function addOctave(that, octave) {
	  if (!octave) return;
	
	  var _that$_layout$options = that._layout.options,
	      octaveRadius = _that$_layout$options.octaveRadius,
	      octaveOffset = _that$_layout$options.octaveOffset,
	      octaveSep = _that$_layout$options.octaveSep;
	
	  var octaveEl = that.el.g();
	
	  // 加上八度和音的点
	  if (octave > 0) {
	    for (var i = 0; i < octave; i++) {
	      octaveEl.circle(that._sbbox.cx, that._sbbox.y + octaveOffset - octaveSep * i, octaveRadius);
	    }
	  } else {
	    for (var _i = 0; _i > octave; _i--) {
	      octaveEl.circle(that._sbbox.cx, that._sbbox.y2 - octaveOffset - octaveSep * _i, octaveRadius);
	    }
	  }
	  that.el.add(octaveEl);
	}
	
	// Transform the pitch to be in a good baseline position and
	// scale it to be more square.
	function getMatrix(that, octave, underbar) {
	  var _that$_layout$options2 = that._layout.options,
	      stepBaselineShift = _that$_layout$options2.stepBaselineShift,
	      underbarSep = _that$_layout$options2.underbarSep;
	
	  var pbbox = that.el.getBBox();
	  var dy = (octave >= 0 && underbar === 0 ? -stepBaselineShift : 0) - underbar * underbarSep;
	  return _snapsvg2.default.matrix().translate(-pbbox.x, dy)
	  //缩小音符的比例
	  // .scale(scale.x, scale.y)
	  //把音符抬到更高的位置上，注释后低音就不再提高了（关键是y2）的工作
	  .translate(0, (0, _util.near)(pbbox.y2, that._sbbox.y2) ? 0 : -pbbox.y2);
	}
	
	function getBBoxAfterTransform(container, bbox, matrix) {
	  var rect = container.rect(bbox.x, bbox.y, bbox.width, bbox.height);
	  var g = container.g(rect);
	  rect.transform(matrix);
	  bbox = g.getBBox();
	  g.remove();
	  return bbox;
	}
	
	function getScale(hasAccidental, octave, underbar) {
	  var absOctave = Math.abs(octave);
	  return {
	    x: Math.pow(0.97, absOctave + underbar + (hasAccidental ? 2 : 0)),
	    y: Math.pow(0.95, absOctave + underbar + (hasAccidental ? 1 : 0))
	  };
	}
	
	exports.default = PitchDef;

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _snapsvg = __webpack_require__(8);
	
	var _snapsvg2 = _interopRequireDefault(_snapsvg);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * SVG definition for time signature.
	 * @class
	 * @param {string} id     [description]
	 * @param {Time} time   [description]
	 * @param {Layout} layout [description]
	 */
	function TimeDef(id, time, layout) {
	  var _layout$options = layout.options,
	      fontSize = _layout$options.timeFontSize,
	      fontWeight = _layout$options.timeFontWeight;
	
	  var lineExtend = fontSize * 0.1;
	  var el = this.el = layout.svg.el.g().attr({
	    id: id,
	    fontSize: fontSize,
	    fontWeight: fontWeight,
	    textAnchor: 'middle'
	  });
	  var lineY = -0.85 * fontSize;
	  var bb = void 0;
	
	  el.text(0, -1 * fontSize, time.beats);
	  el.text(0, 0, time.beatType); // baseline y = 0
	  bb = el.getBBox();
	  el.line(bb.x - lineExtend, lineY, bb.x2 + lineExtend, lineY);
	  el.transform(_snapsvg2.default.matrix().scale(1, 0.8).translate(lineExtend - bb.x, 0));
	
	  bb = el.getBBox();
	  el.toDefs();
	
	  this.width = bb.width;
	  this.height = -bb.y;
	}
	
	exports.default = TimeDef;

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _snapsvg = __webpack_require__(8);
	
	var _snapsvg2 = _interopRequireDefault(_snapsvg);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @class
	 * @param layout {Layout}
	 */
	var SvgLayout = function () {
	  function SvgLayout(layout) {
	    _classCallCheck(this, SvgLayout);
	
	    this._layout = layout;
	    var _layout$options = layout.options,
	        fontFamily = _layout$options.fontFamily,
	        width = _layout$options.width;
	
	    this._el = (0, _snapsvg2.default)(layout.svg).attr({ fontFamily: fontFamily }).addClass('musje');
	    this.el.clear();
	    this.width = width;
	  }
	
	  _createClass(SvgLayout, [{
	    key: 'el',
	    get: function get() {
	      return this._el;
	    }
	
	    /**
	     * Width of the svg.
	     * @type {number}
	     */
	
	  }, {
	    key: 'width',
	    get: function get() {
	      return this._w;
	    },
	    set: function set(w) {
	      this._w = w;
	      this.el.attr('width', w);
	      var body = this._layout.body;
	
	      if (body) body.width = w;
	    }
	
	    /**
	     * Height of the svg.
	     * @type {number}
	     */
	
	  }, {
	    key: 'height',
	    get: function get() {
	      return this._h;
	    },
	    set: function set(h) {
	      this._h = h;
	      this.el.attr('height', h);
	    }
	  }]);
	
	  return SvgLayout;
	}();
	
	exports.default = SvgLayout;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _snapsvg = __webpack_require__(8);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Body
	 * @class
	 * @param {Layout} layout
	 */
	var BodyLayout = function () {
	  function BodyLayout(layout) {
	    _classCallCheck(this, BodyLayout);
	
	    this._layout = layout;
	    var svg = layout.svg,
	        options = layout.options;
	    var marginTop = options.marginTop,
	        marginRight = options.marginRight,
	        marginLeft = options.marginLeft,
	        width = options.width;
	
	    this._el = svg.el.g().transform((0, _snapsvg.matrix)().translate(marginLeft, marginTop)).addClass('mus-body');
	    this.width = width - marginLeft - marginRight;
	  }
	
	  _createClass(BodyLayout, [{
	    key: 'el',
	    get: function get() {
	      return this._el;
	    }
	
	    /**
	     * Width of the body.
	     * - (Getter) Get the body width.
	     * - (Setter) Set the body width and this also induces setting the
	     * header and content width if one exists.
	     * @type {number}
	     */
	
	  }, {
	    key: 'width',
	    get: function get() {
	      return this._w;
	    },
	    set: function set(w) {
	      this._w = w;
	      var layout = this._layout;
	      if (layout.header) layout.header.width = w;
	      if (layout.content) layout.content.width = w;
	    }
	
	    /**
	     * Height of the body.
	     * - (Getter) Get the body height.
	     * - (Setter) Set the body height and this will also cause the height of svg to vary.
	     * @type {number}
	     */
	
	  }, {
	    key: 'height',
	    get: function get() {
	      return this._h;
	    },
	    set: function set(h) {
	      var layout = this._layout;
	      var _layout$options = layout.options,
	          marginTop = _layout$options.marginTop,
	          marginBottom = _layout$options.marginBottom;
	
	      layout.svg.height = h + marginTop + marginBottom;
	      this._h = h;
	    }
	  }]);
	
	  return BodyLayout;
	}();
	
	exports.default = BodyLayout;

/***/ },
/* 35 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Header layout.
	 * @param {Layout} layout
	 */
	var HeaderLayout = function () {
	  function HeaderLayout(layout) {
	    _classCallCheck(this, HeaderLayout);
	
	    this._layout = layout;
	    this.el = layout.body.el.g().addClass('mus-header');
	    this.width = layout.body.width;
	  }
	
	  /**
	   * Width of the header.
	   * @type {number}
	   */
	
	
	  _createClass(HeaderLayout, [{
	    key: 'width',
	    get: function get() {
	      return this._w;
	    },
	    set: function set(w) {
	      this._w = w;
	    }
	
	    /**
	     * Height of the header.
	     * @type {number}
	     */
	
	  }, {
	    key: 'height',
	    get: function get() {
	      return this._h;
	    },
	    set: function set(h) {
	      this._h = h;
	      var _layout = this._layout,
	          content = _layout.content,
	          options = _layout.options;
	
	      content.y = h ? h + options.headerSep : 0;
	    }
	  }]);
	
	  return HeaderLayout;
	}();
	
	exports.default = HeaderLayout;

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _snapsvg = __webpack_require__(8);
	
	var _SystemLayout = __webpack_require__(37);
	
	var _SystemLayout2 = _interopRequireDefault(_SystemLayout);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @class
	 * @param {Object} layout - Reference to the parent layout instance.
	 */
	var ContentLayout = function () {
	  function ContentLayout(layout) {
	    _classCallCheck(this, ContentLayout);
	
	    this.layout = layout;
	    this.el = layout.body.el.g().addClass('mus-content');
	    this.width = layout.body.width;
	  }
	
	  _createClass(ContentLayout, [{
	    key: 'flow',
	
	
	    /**
	     * @param scoreMeasure {musje.TimewiseMeasures} The timewise score measure.
	     */
	    value: function flow(scoreMeasures) {
	      makeSystems(this, scoreMeasures);
	      balanceSystems(this);
	      this.systems.forEach(function (system) {
	        system.flow();
	      });
	    }
	  }, {
	    key: 'y',
	    get: function get() {
	      return this._y;
	    },
	    set: function set(y) {
	      this._y = y;
	      this.el.transform((0, _snapsvg.matrix)().translate(0, y));
	      resizeBody(this);
	    }
	  }, {
	    key: 'width',
	    get: function get() {
	      return this._w;
	    },
	    set: function set(w) {
	      this._w = w;
	    }
	  }, {
	    key: 'height',
	    get: function get() {
	      var last = this.systems[this.systems.length - 1];
	      return last ? last.y + last.height : 0;
	    }
	  }]);
	
	  return ContentLayout;
	}();
	
	function resizeBody(that) {
	  var layout = that.layout;
	  var hHeight = layout.header.height;
	
	  layout.body.height = that.height + (hHeight ? hHeight + layout.options.headerSep : 0);
	}
	
	/**
	 * Divide measures in timewise score into the systems.
	 * @param scoreMeasure {musje.TimewiseMeasures} The timewise score measure.
	 */
	function makeSystems(that, scoreMeasures) {
	  var layout = that.layout;
	  var _layout$options = layout.options,
	      measurePaddingRight = _layout$options.measurePaddingRight,
	      measurePaddingLeft = _layout$options.measurePaddingLeft;
	
	  var measurePadding = measurePaddingLeft + measurePaddingRight;
	  var systems = that.systems = [];
	  var system = new _SystemLayout2.default(layout, 0);
	  systems.push(system);
	
	  scoreMeasures.forEach(function (measure) {
	    var minWidth = measure.minWidth + measurePadding + (measure.barLeftInSystem.width + measure.barRightInSystem.width) / 2;
	
	    // Continue put this measure in the system.
	    if (system.minWidth + minWidth < that.width) {
	      system.measures.push(measure);
	
	      // New system
	    } else {
	      system = new _SystemLayout2.default(layout, systems.length);
	      systems.push(system);
	      system.measures.push(measure);
	    }
	  });
	}
	
	function getMaxLengthSystem(that) {
	  var maxLength = 0;
	  var system = void 0;
	
	  that.systems.forEach(function (system) {
	    maxLength = Math.max(maxLength, system.measures.length);
	  });
	
	  // Find the first max length system backward.
	  for (var i = that.systems.length - 1; i >= 0; i--) {
	    system = that.systems[i];
	    if (system.measures.length === maxLength) return system;
	  }
	}
	
	function isNotBalancable(that) {
	  var systems = that.systems,
	      width = that.width;
	  var length = systems.length;
	
	  return length === 1 || // only 1 system
	  length === 2 && systems[1].minWidth < width * 0.4; // 1 2/5 systems
	}
	
	function balanceSystems(that) {
	  if (isNotBalancable(that)) return;
	
	  var systems = that.systems;
	
	  var last = systems[systems.length - 1];
	  var system = getMaxLengthSystem(that);
	  var next = void 0,
	      prev = void 0;
	
	  // Move measures down to balance the last system.
	  while (last.measures.length < system.measures.length - 1) {
	
	    // Move a measure tail-to-head downward to the last measure.
	    while (true) {
	      next = system.next;
	      if (!next) break;
	      next.measures.unshift(system.measures.pop());
	      system = next;
	    }
	    system = getMaxLengthSystem(that);
	  }
	
	  // Move back measures if the system exceeds the content width.
	  system = last;
	  while (system) {
	    prev = system.prev;
	    while (system.minWidth > that.width) {
	      prev.measures.push(system.measures.shift());
	    }
	    system = prev;
	  }
	}
	
	exports.default = ContentLayout;

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _snapsvg = __webpack_require__(8);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @class
	 * @param {number} index
	 * @param {Layout} layout
	 */
	var SystemLayout = function () {
	  function SystemLayout(layout, index) {
	    _classCallCheck(this, SystemLayout);
	
	    this._index = index;
	    this._layout = layout;
	    this._el = layout.content.el.g().addClass('mus-system');
	  }
	
	  _createClass(SystemLayout, [{
	    key: 'flow',
	    value: function flow() {
	      var _this = this;
	
	      var minHeight = 0;
	      var x = 0;
	
	      tuneMeasuresWidths(this);
	
	      this.measures.forEach(function (measure, m) {
	        measure.system = _this;
	        measure._sIndex = m;
	        measure.flow();
	        measure.x = x;
	        x += measure.width;
	        minHeight = Math.max(minHeight, measure.minHeight);
	      });
	
	      var prev = this.prev;
	
	      this.y = prev ? prev.y + prev.height + this._layout.options.systemSep : 0;
	      this.height = minHeight;
	    }
	  }, {
	    key: 'el',
	    get: function get() {
	      return this._el;
	    }
	
	    /**
	     * Measures in a system.
	     * @type {Array.<TimewiseMeasure>}
	     * @readonly
	     */
	
	  }, {
	    key: 'measures',
	    get: function get() {
	      return this._measures || (this._measures = []);
	    }
	
	    /**
	     * Previous system.
	     * @type {SystemLayout}
	     */
	
	  }, {
	    key: 'prev',
	    get: function get() {
	      return this._layout.content.systems[this._index - 1];
	    }
	
	    /**
	     * Next system.
	     * @type {SystemLayout}
	     */
	
	  }, {
	    key: 'next',
	    get: function get() {
	      return this._layout.content.systems[this._index + 1];
	    }
	  }, {
	    key: 'y',
	    get: function get() {
	      return this._y;
	    },
	    set: function set(y) {
	      this._y = y;
	      this.el.transform((0, _snapsvg.matrix)().translate(0, y));
	    }
	  }, {
	    key: 'width',
	    get: function get() {
	      return this._layout.content.width;
	    }
	  }, {
	    key: 'minWidth',
	    get: function get() {
	      var min = 0;
	      this.measures.forEach(function (measure) {
	        min += measure.minWidth;
	      });
	      return min;
	    }
	  }, {
	    key: 'content',
	    get: function get() {
	      return this._layout.content;
	    }
	  }, {
	    key: 'systems',
	    get: function get() {
	      return this.content.systems;
	    }
	  }]);
	
	  return SystemLayout;
	}();
	
	function tuneMeasuresWidths(that) {
	  if (!isTunable(that)) return;
	
	  var pairs = getPairs(that.measures);
	  var length = pairs.length;
	  var widthLeft = that.width;
	  var itemLeft = length;
	  var i = 0; // i + itemLeft === length
	  var width;
	
	  while (i < length) {
	    if (widthLeft >= pairs[i].width * itemLeft) {
	      width = widthLeft / itemLeft;
	      do {
	        pairs[i].measure.width = width;
	        i++;
	      } while (i < length);
	      break;
	    } else {
	      width = pairs[i].width;
	      pairs[i].measure.width = width;
	      widthLeft -= width;
	      i++;
	      itemLeft--;
	    }
	  }
	}
	
	function isTunable(that) {
	  var ctWidth = that.content.width;
	  var s = that._index;
	  var ssLen = that.systems.length;
	  return ssLen > 2 || ssLen === 1 && that.minWidth > ctWidth * 0.7 || ssLen === 2 && (s === 0 || s === 1 && that.minWidth > ctWidth * 0.4);
	}
	
	var descendingSort = function descendingSort(a, b) {
	  return b.width - a.width;
	};
	
	var getPairs = function getPairs(measures) {
	  return measures.map(function (measure) {
	    return {
	      width: measure.minWidth,
	      measure: measure
	    };
	  }).sort(descendingSort);
	};
	
	exports.default = SystemLayout;

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = renderBar;
	
	var _snapsvg = __webpack_require__(8);
	
	function renderDots(el, x, radius, measureHeight) {
	  var cy = measureHeight / 2;
	  var dy = measureHeight * 0.15;
	
	  el.circle(x, cy - dy, radius);
	  el.circle(x, cy + dy, radius);
	}
	
	function render(bar, measure, lo) {
	  var barlineDotRadius = lo.barlineDotRadius;
	  var height = measure.height;
	
	  var el = measure.el.g().addClass('mus-barline');
	  el.use(bar.def.el).transform((0, _snapsvg.matrix)().scale(1, height));
	
	  switch (bar.value) {
	    case 'repeat-begin':
	      renderDots(el, bar.width - barlineDotRadius, barlineDotRadius, height);
	      break;
	    case 'repeat-end':
	      renderDots(el, barlineDotRadius, barlineDotRadius, height);
	      break;
	    case 'repeat-both':
	      renderDots(el, bar.width - barlineDotRadius, barlineDotRadius, height);
	      renderDots(el, barlineDotRadius, barlineDotRadius, height);
	      break;
	    default:
	  }
	
	  return el;
	}
	
	var translate = function translate(el, x) {
	  el.transform((0, _snapsvg.matrix)().translate(x, 0));
	};
	
	// @param m {number} Measure index in measures.
	// @param len {number} Length of measures.
	function renderBar(measure, lo) {
	  var bar = measure.barRightInSystem;
	  var el = void 0;
	
	  if (bar.def) {
	    el = render(bar, measure, lo);
	
	    // Align end in system end.
	    if (measure.inSystemEnd) translate(el, measure.width - bar.width);
	    // Others align middle.
	    else translate(el, measure.width - bar.width / 2);
	  }
	
	  // Render right bar and align begin in system begin.
	  if (measure.inSystemBegin) {
	    bar = measure.barLeftInSystem;
	    if (bar.def) render(bar, measure, lo);
	  }
	}

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _snapsvg = __webpack_require__(8);
	
	function renderDuration(note, lo) {
	  var _note$def = note.def,
	      durationDef = _note$def.durationDef,
	      pitchDef = _note$def.pitchDef;
	  var underbar = note.duration.underbar;
	
	  var y = 0;
	
	  // Whole and half notes
	  if (note.duration.type < 4) {
	    note.el.use(durationDef.el).attr({
	      x: pitchDef.width,
	      y: pitchDef.stepCy
	    });
	
	    // Quarter or shorter notes
	  } else {
	
	    // Add underbars for eigth or shorter notes
	    if (underbar) {
	      for (var i = 0; i < underbar; i++) {
	
	        // Only render beam for the begin one.
	        if (note.beams[i]) {
	          if (note.beams[i].value === 'begin') {
	
	            // render the bar from the beginning note to the ending note associated
	            // with the beginning note. Y stands for the starting height.
	            renderUnderbar(note, note.beams[i].endDurable, y, lo);
	          }
	
	          // Unbeamed underbar
	        } else {
	          //renders single note
	          renderUnderbar(note, note, y, lo);
	        }
	        y -= lo.underbarSep;
	      }
	    }
	
	    // Add dots
	    if (note.duration.dot) {
	      note.el.g().transform((0, _snapsvg.matrix)().translate(pitchDef.width, 0)).use(durationDef.el).transform(pitchDef.matrix);
	    }
	  }
	}
	
	function renderUnderbar(note1, note2, y, lo) {
	  note1.el.line(0, y, note2.x - note1.x + note2.width, y).attr('stroke-width', lo.typeStrokeWidth);
	}
	
	exports.default = renderDuration;

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = renderCurve;
	
	var _snapsvg = __webpack_require__(8);
	
	function getCurvePath(x1, y1, x2, y2) {
	  var dx = x2 - x1;
	  var dy = y2 - y1;
	  var c1x = 0; //-0.1 * dx
	  var c1y = 0; //-0.1 * dy
	  var c2x = dx; //1.1 * dx
	  var c2y = dy; //1.1 * dy
	
	  return (0, _snapsvg.format)('M{x1},{y1}c{c1x},{c1y} {c2x},{c2y} {dx},{dy}c{c3x},{c3y} {c4x},{c4y} {negDx},{negDy}', {
	    x1: x1,
	    y1: y1,
	    c1x: c1x,
	    c1y: c1y - 8,
	    c2x: c2x,
	    c2y: c2y - 8,
	    dx: dx,
	    dy: dy,
	    c3x: -c1x,
	    c3y: -c1y - 10,
	    c4x: -c2x,
	    c4y: -c2y - 10,
	    negDx: -dx,
	    negDy: -dy
	  });
	}
	
	function renderEndCurve(note, error) {
	  var _note$def$pitchDef = note.def.pitchDef,
	      x1 = _note$def$pitchDef.stepCx,
	      y1 = _note$def$pitchDef.stepTop;
	
	  var x2 = -note.systemX - 3;
	  var el = note.el.path(getCurvePath(x1, y1, x2, y1 - 3));
	
	  if (error) el.addClass('mus-error');
	  return el;
	}
	
	function renderBeginCurve(note, error) {
	  var _note$def$pitchDef2 = note.def.pitchDef,
	      x1 = _note$def$pitchDef2.stepCx,
	      y1 = _note$def$pitchDef2.stepTop;
	
	  var x2 = note.system.width - note.systemX + 3;
	  var el = note.el.path(getCurvePath(x1, y1, x2, y1 - 3));
	
	  if (error) el.addClass('mus-error');
	  return el;
	}
	
	function renderCompleteCurve(note1, note2, error) {
	  var _note1$def$pitchDef = note1.def.pitchDef,
	      x1 = _note1$def$pitchDef.stepCx,
	      y1 = _note1$def$pitchDef.stepTop;
	  var _note2$def$pitchDef = note2.def.pitchDef,
	      x2 = _note2$def$pitchDef.stepCx,
	      y2 = _note2$def$pitchDef.stepTop;
	
	  var noteDx = note2.systemX - note1.systemX;
	  var el = note1.el.path(getCurvePath(x1, y1, noteDx + x2, y2));
	
	  if (error) el.addClass('mus-error');
	  return el;
	}
	
	function renderCurve(type, note) {
	  if (note[type].end) {
	    var prev = note[type].prevParent;
	    var prevHasError = note[type].prevHasError;
	
	
	    if (!prev || prev.system !== note.system) renderEndCurve(note, prevHasError);else if (prevHasError) renderCompleteCurve(note, prev, prevHasError);
	  }
	
	  if (note[type].begin) {
	    var next = note[type].nextParent;
	    var nextHasError = note[type].nextHasError;
	
	
	    if (!next || next.system !== note.system) renderBeginCurve(note, nextHasError);else renderCompleteCurve(note, next, nextHasError);
	  }
	}

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _MIDI = __webpack_require__(42);
	
	var _MIDI2 = _interopRequireDefault(_MIDI);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var timeouts = [];
	
	var PlayerMixin = {
	
	  /**
	   * Start playing the song.
	   */
	  play: function play() {
	    var measures = this.parts[0].measures;
	
	    var time = 0; //audioCtx.currentTime
	
	    measures.forEach(function (cell) {
	      cell.data.forEach(function (data) {
	        switch (data.$type) {
	          case 'note':
	            // playNote(time, dur, freq)
	            timeouts.push(midiPlayNote(data, time));
	            time += data.duration.second;
	            break;
	          case 'rest':
	            time += data.duration.second;
	            break;
	          default:
	        }
	      });
	    });
	  },
	
	
	  /**
	   * Stop playing the song.
	   */
	  stop: function stop() {
	    timeouts.forEach(function (timeout) {
	      clearTimeout(timeout);
	    });
	    timeouts.length = 0;
	  }
	};
	
	// if (window.AudioContext) {
	//   var audioCtx = new window.AudioContext()
	//   var gainNode = audioCtx.createGain()
	//   gainNode.connect(audioCtx.destination)
	//   gainNode.gain.value = 0.5  // set the volume
	// }
	
	// // var oscillator = audioCtx.createOscillator()
	// // oscillator.connect(gainNode)
	// // oscillator.type = 'square' // sine | square | sawtooth | triangle | custom
	
	// function playNote(time, dur, freq) {
	//   if (!audioCtx) { return }
	
	//   var oscillator = audioCtx.createOscillator()
	//   oscillator.type = 'sine'
	//   oscillator.connect(audioCtx.destination)
	//   oscillator.frequency.value = freq
	//   oscillator.start(time)
	//   oscillator.stop(time + dur - 0.05)
	// }
	
	function midiPlayNote(note, time) {
	  var midiNumber = note.pitch.midiNumber;
	
	  var dur = note.duration.second;
	
	  function play() {
	    if (!note.tie.prevParent || note.tie.prevHasError) {
	      _MIDI2.default.noteOn(0, midiNumber, 100, 0);
	    }
	    if (!note.tie.nextParent || note.tie.nextHasError) {
	      _MIDI2.default.noteOff(0, midiNumber, dur);
	    }
	    note.el.addClass('mus-playing');
	    setTimeout(function () {
	      note.el.removeClass('mus-playing');
	    }, dur * 800 + 100);
	    console.log('Play: ' + note, time, dur, midiNumber);
	  }
	
	  return setTimeout(play, time * 800);
	}
	
	exports.default = PlayerMixin;

/***/ },
/* 42 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_42__;

/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBiY2IxZmE3NzAxMTdiZjk3NDVlNCIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGFyc2VyL3BhcnNlci5qaXNvbiIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvU2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVsL1Njb3JlSGVhZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvUGFydHdpc2VQYXJ0cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvUGFydHdpc2VQYXJ0LmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbC9DZWxsLmpzIiwid2VicGFjazovLy9leHRlcm5hbCB7XCJyb290XCI6XCJTbmFwXCIsXCJjb21tb25qczJcIjpcInNuYXBzdmdcIixcImNvbW1vbmpzXCI6XCJzbmFwc3ZnXCIsXCJhbWRcIjpcInNuYXBzdmdcIn0iLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVsL1RpbWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVsL011c2ljRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvQmFyLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbC9Ob3RlLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbC9QaXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvRHVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVsL1RpZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvU2x1ci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvUmVzdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvQ2hvcmQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVsL1ZvaWNlLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbC9CZWFtLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbC9UaW1ld2lzZU1lYXN1cmVzLmpzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbC9UaW1ld2lzZU1lYXN1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlcmVyL1JlbmRlcmVyL1JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXJlci9MYXlvdXQvTGF5b3V0LmpzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXJlci9MYXlvdXQvbGF5b3V0T3B0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvZGVmcy9EZWZzLmpzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXJlci9kZWZzL0FjY2lkZW50YWxEZWYuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlcmVyL3N2Z1BhdGhzLmpzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXJlci9kZWZzL0JhckRlZi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvZGVmcy9EdXJhdGlvbkRlZi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvZGVmcy9QaXRjaERlZi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvZGVmcy9UaW1lRGVmLmpzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXJlci9MYXlvdXQvU3ZnTGF5b3V0LmpzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXJlci9MYXlvdXQvQm9keUxheW91dC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvTGF5b3V0L0hlYWRlckxheW91dC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvTGF5b3V0L0NvbnRlbnRMYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlcmVyL0xheW91dC9TeXN0ZW1MYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlcmVyL1JlbmRlcmVyL3JlbmRlckJhci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyZXIvUmVuZGVyZXIvcmVuZGVyRHVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlcmVyL1JlbmRlcmVyL3JlbmRlckN1cnZlLmpzIiwid2VicGFjazovLy8uL3NyYy9wbGF5ZXIvUGxheWVyTWl4aW4uanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiTUlESVwiIl0sIm5hbWVzIjpbInByb3RvdHlwZSIsInJlbmRlciIsInN2ZyIsImxvIiwicGFyc2UiLCJpbnB1dCIsIlNjb3JlIiwiSVNfT0JKRUNUIiwiaXNPYmplY3QiLCJvYmoiLCJvYmpFYWNoIiwiY2FsbGJhY2siLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImV4dGVuZCIsImV4dCIsInZhbCIsIm5lYXIiLCJhIiwiYiIsIk1hdGgiLCJhYnMiLCJpc0FjY2Vzc29yUHJvcGVydHkiLCJ2YWx1ZSIsImdldCIsInNldCIsImRlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsInByb3AiLCJkZXNjcmlwdG9yIiwiY29uc3RhbnQiLCJ3cml0YWJsZSIsImVudW1lcmFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsInRvSlNPTldpdGhEZWZhdWx0IiwibWFrZVRvSlNPTiIsInZhbHVlcyIsImVsTmFtZSIsImlzRW1wdHkiLCJyZXN1bHQiLCJkZWZhdWx0VmFsdWUiLCJyZXMiLCJzY29yZSIsInRvSlNPTiIsImhlYWQiLCJ1bmRlZmluZWQiLCJwYXJ0cyIsInBhcnQiLCJwIiwibWVhc3VyZXMiLCJjZWxsIiwibSIsIndhbGtDZWxscyIsImRhdGEiLCJkIiwibWFwIiwidG9TdHJpbmciLCJqb2luIiwiX2hlYWQiLCJfcGFydHMiLCJyZW1vdmVBbGwiLCJhZGRQYXJ0cyIsImZyb21QYXJ0d2lzZSIsIl9tZWFzdXJlcyIsIlNjb3JlSGVhZCIsInRpdGxlIiwic3VidGl0bGUiLCJzdWJzdWJ0aXRsZSIsImNvbXBvc2VyIiwiYXJyYW5nZXIiLCJseXJpY2lzdCIsIlBhcnR3aXNlUGFydHMiLCJfc2NvcmUiLCJhcHBlbmQiLCJpbmRleCIsImxlbmd0aCIsIm11c2plUGFydCIsInB1c2giLCJBcnJheSIsIlBhcnR3aXNlUGFydCIsIl9pbmRleCIsIm1lYSIsIkNsYXNzZXMiLCJ0aW1lIiwiYmFyIiwibm90ZSIsInJlc3QiLCJjaG9yZCIsInZvaWNlIiwiQmFyIiwiQ2VsbCIsIm1JbmRleCIsInBJbmRleCIsIl9tSW5kZXgiLCJfcEluZGV4IiwibWFrZUJlYW1zIiwibXVzaWNEYXRhIiwidHlwZSIsImluc3RhbmNlIiwiX2NlbGwiLCJsYXlvdXQiLCJkZWZzIiwib3B0aW9ucyIsIm11c2ljRGF0YVNlcCIsIngiLCJtaW5IZWlnaHQiLCJkZWYiLCJ5Iiwid2lkdGgiLCJtaW4iLCJoZWlnaHQiLCJtaW5XaWR0aCIsIl9ib3hFbCIsImVsIiwicmVjdCIsImFkZENsYXNzIiwicmVtb3ZlIiwiX2RhdGEiLCJkYXR1bSIsImZpcnN0RGF0YSIsIiR0eXBlIiwicHJldkNlbGwiLCJwcmV2IiwiYmFyUmlnaHQiLCJsYXN0RGF0YSIsIl93IiwidyIsInJlZmxvdyIsInBhcnRIZWlnaHQiLCJfeCIsInRyYW5zZm9ybSIsInRyYW5zbGF0ZSIsInkyIiwicGFydFNlcCIsImJhckxlZnQiLCJtZWFzdXJlIiwiaW5TeXN0ZW1CZWdpbiIsInN5c3RlbSIsImluU3lzdGVtRW5kIiwidGhhdCIsImdyb3VwRHVyIiwiZ2V0QmVhbUdyb3VwcyIsImJlYW1MZXZlbCIsIm5leHRIYXNTYW1lQmVhbWxldmVsIiwibGV2ZWwiLCJuZXh0IiwiZ3JvdXAiLCJkdXJhdGlvbiIsInVuZGVyYmFyIiwiaSIsImJlYW1zIiwiZ3JvdXBzIiwiY291bnRlciIsImluR3JvdXAiLCJwdXRHcm91cCIsImR1ciIsInF1YXJ0ZXIiLCJUaW1lIiwiYmVhdHMiLCJiZWF0VHlwZSIsIk11c2ljRGF0YSIsInByZXZJblBhcnQiLCJuZXh0SW5QYXJ0IiwiYXR0ciIsIl95IiwiQkFSX1RPX1NUUklORyIsInNpbmdsZSIsImRvdWJsZSIsImVuZCIsIkJBUl9UT19JRCIsIl92YWx1ZSIsIk5vdGUiLCJwaXRjaCIsInRpZSIsInNsdXIiLCJiZWdpbiIsImFjY2lkZW50YWwiLCJzdGVwIiwib2N0YXZlIiwiZG90IiwicmVwbGFjZSIsIl9waXRjaCIsIl9kdXJhdGlvbiIsIl9iZWFtcyIsIl90aWUiLCJfc2x1ciIsIkE0X0ZSRVFVRU5DWSIsIkE0X01JRElfTlVNQkVSIiwiU1RFUF9UT19NSURJX05VTUJFUiIsIkFDQ0lERU5UQUxfVE9fQUxURVIiLCJuIiwiYmIiLCJjaGFycyIsImNoIiwibnVtIiwib2N0YXZlU3RyaW5nIiwiUGl0Y2giLCJwYXJlbnQiLCJfcGFyZW50IiwiYWx0ZXJMaW5rIiwiYWx0ZXIiLCJwcmV2RGF0YSIsInBvdyIsIm1pZGlOdW1iZXIiLCJUWVBFX1RPX1NUUklORyIsIlRZUEVfVE9fVU5ERVJCQVIiLCJET1RfVE9fU1RSSU5HIiwiRHVyYXRpb24iLCJUaWUiLCJwcmV2UGFyZW50IiwicHJldkR1cmFibGVJblBhcnQiLCJuZXh0RHVyYWJsZUluUGFydCIsIm5leHRQYXJlbnQiLCJTbHVyIiwiUmVzdCIsIkNob3JkIiwicGl0Y2hlcyIsIl9waXRjaGVzIiwiVm9pY2UiLCJCZWFtIiwiX2xldmVsIiwibmV4dERhdGEiLCJUaW1ld2lzZU1lYXN1cmVzIiwiVGltZXdpc2VNZWFzdXJlIiwiZyIsIm91dGVyV2lkdGhMZWZ0Iiwic3Ryb2tlIiwiZmlsbCIsIl9lbCIsIm1heCIsInBhZGRpbmciLCJfcyIsIm1lYXN1cmVQYWRkaW5nUmlnaHQiLCJtZWFzdXJlUGFkZGluZ0xlZnQiLCJvdXRlcldpZHRoUmlnaHQiLCJiYXJMZWZ0SW5TeXN0ZW0iLCJiYXJSaWdodEluU3lzdGVtIiwib3V0ZXJXaWR0aCIsIlNuYXAiLCJtYXRyaXgiLCJfc0luZGV4IiwiUmVuZGVyZXIiLCJfbG8iLCJmbG93IiwicmVuZGVySGVhZGVyIiwicmVuZGVyQ29udGVudCIsImhlYWRlciIsInRleHQiLCJ0aXRsZUZvbnRTaXplIiwiZm9udFNpemUiLCJmb250V2VpZ2h0IiwidGl0bGVGb250V2VpZ2h0IiwidGV4dEFuY2hvciIsImNvbXBvc2VyRm9udFNpemUiLCJjb21wb3NlckZvbnRXZWlnaHQiLCJnZXRCQm94IiwiY29udGVudCIsInN5c3RlbXMiLCJyZW5kZXJDZWxsIiwicmVuZGVyTm90ZSIsInVzZSIsInBpdGNoRGVmIiwiTGF5b3V0IiwiYm9keSIsImluaXQiLCJsYXlvdXRPcHRpb25zIiwibW9kZSIsIm1hcmdpblRvcCIsIm1hcmdpblJpZ2h0IiwibWFyZ2luQm90dG9tIiwibWFyZ2luTGVmdCIsImZvbnRGYW1pbHkiLCJ0aW1lRm9udFNpemUiLCJ0aW1lRm9udFdlaWdodCIsImhlYWRlclNlcCIsInN5c3RlbVNlcCIsImJhcmxpbmVIZWlnaHQiLCJ0aGluQmFybGluZVdpZHRoIiwidGhpY2tCYXJsaW5lV2lkdGgiLCJiYXJsaW5lU2VwIiwiYmFybGluZURvdFJhZGl1cyIsImJhcmxpbmVEb3RTZXAiLCJhY2NpZGVudGFsRm9udFNpemUiLCJhY2NpZGVudGFsU2hpZnQiLCJvY3RhdmVSYWRpdXMiLCJvY3RhdmVPZmZzZXQiLCJvY3RhdmVTZXAiLCJzdGVwQmFzZWxpbmVTaGlmdCIsInR5cGVTdHJva2VXaWR0aCIsInR5cGViYXJPZmZzZXQiLCJ0eXBlYmFyTGVuZ3RoIiwidHlwZWJhclNlcCIsInR5cGViYXJFeHQiLCJ1bmRlcmJhclNlcCIsImRvdE9mZnNldCIsImRvdFJhZGl1cyIsImRvdFNlcCIsInQ0RG90T2Zmc2V0IiwidDREb3RTZXAiLCJ0NERvdEV4dCIsInQ0RG90QmFzZWxpbmVTaGlmdCIsInVuaXQiLCJEZWZzIiwiX2xheW91dCIsImlkIiwiZGVmSWQiLCJtYWtlRGVmIiwibWFrZU5vdGVEZWYiLCJtYWtlUmVzdERlZiIsInBpdGNoSWQiLCJfZ2V0UGl0Y2giLCJkdXJhdGlvbkRlZiIsInJlc3ROb3RlIiwiQWNjaWRlbnRhbERlZiIsImFjY0tleSIsInBhdGhEYXRhIiwicmF0aW8iLCJBQ0NJREVOVEFMX1JBVElPUyIsInNoaWZ0IiwiQUNDSURFTlRBTF9TSElGVFMiLCJwYXRoIiwic2NhbGUiLCJ0b0RlZnMiLCJzdmdQYXRocyIsIkJhckRlZiIsImxpbmVXaWR0aCIsImFkZEJhcmxpbmUiLCJEdXJhdGlvbkRlZiIsIl9pZCIsIm1ha2VFbCIsIm1ha2VUeXBlMSIsIm1ha2VUeXBlMiIsIm1ha2VUeXBlNCIsImFkZExpbmUiLCJhZGREb3QiLCJjaXJjbGUiLCJQaXRjaERlZiIsInN0cm9rZVdpZHRoIiwic2Jib3giLCJwYmJveCIsIl9kZWZzIiwiYWRkQWNjaWRlbnRhbCIsImFkZFN0ZXAiLCJhZGRPY3RhdmUiLCJnZXRNYXRyaXgiLCJfc2Jib3giLCJnZXRCQm94QWZ0ZXJUcmFuc2Zvcm0iLCJzdGVwQ3giLCJjeCIsInN0ZXBZIiwic3RlcEN5IiwiY3kiLCJzdGVwWTIiLCJzdGVwVG9wIiwiX2FjY2lkZW50YWxYMiIsImFjY0RlZiIsImdldEFjY2lkZW50YWwiLCJvY3RhdmVFbCIsImFkZCIsImR5IiwiY29udGFpbmVyIiwiYmJveCIsImdldFNjYWxlIiwiaGFzQWNjaWRlbnRhbCIsImFic09jdGF2ZSIsIlRpbWVEZWYiLCJsaW5lRXh0ZW5kIiwibGluZVkiLCJsaW5lIiwieDIiLCJTdmdMYXlvdXQiLCJjbGVhciIsIl9oIiwiaCIsIkJvZHlMYXlvdXQiLCJIZWFkZXJMYXlvdXQiLCJDb250ZW50TGF5b3V0Iiwic2NvcmVNZWFzdXJlcyIsIm1ha2VTeXN0ZW1zIiwiYmFsYW5jZVN5c3RlbXMiLCJyZXNpemVCb2R5IiwibGFzdCIsImhIZWlnaHQiLCJtZWFzdXJlUGFkZGluZyIsImdldE1heExlbmd0aFN5c3RlbSIsIm1heExlbmd0aCIsImlzTm90QmFsYW5jYWJsZSIsInVuc2hpZnQiLCJwb3AiLCJTeXN0ZW1MYXlvdXQiLCJ0dW5lTWVhc3VyZXNXaWR0aHMiLCJpc1R1bmFibGUiLCJwYWlycyIsImdldFBhaXJzIiwid2lkdGhMZWZ0IiwiaXRlbUxlZnQiLCJjdFdpZHRoIiwicyIsInNzTGVuIiwiZGVzY2VuZGluZ1NvcnQiLCJzb3J0IiwicmVuZGVyQmFyIiwicmVuZGVyRG90cyIsInJhZGl1cyIsIm1lYXN1cmVIZWlnaHQiLCJyZW5kZXJEdXJhdGlvbiIsInJlbmRlclVuZGVyYmFyIiwiZW5kRHVyYWJsZSIsIm5vdGUxIiwibm90ZTIiLCJyZW5kZXJDdXJ2ZSIsImdldEN1cnZlUGF0aCIsIngxIiwieTEiLCJkeCIsImMxeCIsImMxeSIsImMyeCIsImMyeSIsImMzeCIsImMzeSIsImM0eCIsImM0eSIsIm5lZ0R4IiwibmVnRHkiLCJyZW5kZXJFbmRDdXJ2ZSIsImVycm9yIiwic3lzdGVtWCIsInJlbmRlckJlZ2luQ3VydmUiLCJyZW5kZXJDb21wbGV0ZUN1cnZlIiwibm90ZUR4IiwicHJldkhhc0Vycm9yIiwibmV4dEhhc0Vycm9yIiwidGltZW91dHMiLCJQbGF5ZXJNaXhpbiIsInBsYXkiLCJtaWRpUGxheU5vdGUiLCJzZWNvbmQiLCJzdG9wIiwiY2xlYXJUaW1lb3V0IiwidGltZW91dCIsIm5vdGVPbiIsIm5vdGVPZmYiLCJzZXRUaW1lb3V0IiwicmVtb3ZlQ2xhc3MiLCJjb25zb2xlIiwibG9nIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdENBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7Ozs7QUFFQTs7Ozs7OztBQU9BLGlCQUFNQSxTQUFOLENBQWdCQyxNQUFoQixHQUF5QixVQUFVQyxHQUFWLEVBQWVDLEVBQWYsRUFBbUI7QUFDMUMsMEJBQWFELEdBQWIsRUFBa0JDLEVBQWxCLEVBQXNCRixNQUF0QixDQUE2QixJQUE3QjtBQUNELEVBRkQ7O0FBSUEsNkJBQWlCLGdCQUFNRCxTQUF2Qjs7QUFF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QTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNB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T0FBTyxHQUF4QixDQUFQO0FBQ0Q7O21CQUVjK1YsVzs7Ozs7O0FDaEZmLGlEIiwiZmlsZSI6Im11c2plLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwic25hcHN2Z1wiKSwgcmVxdWlyZShcIk1JRElcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wic25hcHN2Z1wiLCBcIk1JRElcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wibXVzamVcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJzbmFwc3ZnXCIpLCByZXF1aXJlKFwiTUlESVwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wibXVzamVcIl0gPSBmYWN0b3J5KHJvb3RbXCJTbmFwXCJdLCByb290W1wiTUlESVwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzhfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV80Ml9fKSB7XG5yZXR1cm4gXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGJjYjFmYTc3MDExN2JmOTc0NWU0IiwiaW1wb3J0IHBhcnNlciBmcm9tICcuL3BhcnNlci9wYXJzZXIuamlzb24nXG5pbXBvcnQgU2NvcmUgZnJvbSAnLi9tb2RlbC9TY29yZSdcbmltcG9ydCBSZW5kZXJlciBmcm9tICcuL3JlbmRlcmVyL1JlbmRlcmVyL1JlbmRlcmVyJ1xuaW1wb3J0IHsgZGVmaW5lUHJvcGVydGllcyB9IGZyb20gJy4vdXRpbCdcbmltcG9ydCBQbGF5ZXJNaXhpbiBmcm9tICcuL3BsYXllci9QbGF5ZXJNaXhpbidcblxuLyoqXG4gKiBSZW5kZXIgdGhlIHNjb3JlIGluIGppYW5wdSAobnVtYmVyZWQgbXVzaWNhbCBub3RhdGlvbikuXG4gKiBAbWVtYmVyXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdmdcbiAqIEBwYXJhbSB7T2JqZWN0fSBsbyAtIExheW91dCBvcHRpb25zLlxuICovXG5TY29yZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHN2ZywgbG8pIHtcbiAgbmV3IFJlbmRlcmVyKHN2ZywgbG8pLnJlbmRlcih0aGlzKVxufVxuXG5kZWZpbmVQcm9wZXJ0aWVzKFNjb3JlLnByb3RvdHlwZSwgUGxheWVyTWl4aW4pXG5cbi8qKlxuICogUGFyc2Ugc291cmNlIG11c2plIHN0cmluZyB0byBiZSBhIFNjb3JlIGluc3RhbmNlLlxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IC0gSW5wdXQgb2YgdGhlIG11c2plIHNvdXJjZSBjb2RlLlxuICogQHJldHVybiB7U2NvcmV9IC0gQSBgU2NvcmVgIGluc3RhbmNlLlxuICovXG5leHBvcnQgY29uc3QgcGFyc2UgPSAoaW5wdXQpID0+IHtcbiAgcmV0dXJuIHBhcnNlci5wYXJzZShpbnB1dClcbiAgLy8gdmFyIHBsYWluU2NvcmUgPSBwYXJzZXIucGFyc2UoaW5wdXQpO1xuICAvLyByZXR1cm4gbmV3IFNjb3JlKHBsYWluU2NvcmUpO1xufVxuXG5leHBvcnQgeyBTY29yZSB9XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbWFpbi5qcyIsIi8qIHBhcnNlciBnZW5lcmF0ZWQgYnkgamlzb24gMC40LjE3ICovXG4vKlxuICBSZXR1cm5zIGEgUGFyc2VyIG9iamVjdCBvZiB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcblxuICBQYXJzZXI6IHtcbiAgICB5eToge31cbiAgfVxuXG4gIFBhcnNlci5wcm90b3R5cGU6IHtcbiAgICB5eToge30sXG4gICAgdHJhY2U6IGZ1bmN0aW9uKCksXG4gICAgc3ltYm9sc186IHthc3NvY2lhdGl2ZSBsaXN0OiBuYW1lID09PiBudW1iZXJ9LFxuICAgIHRlcm1pbmFsc186IHthc3NvY2lhdGl2ZSBsaXN0OiBudW1iZXIgPT0+IG5hbWV9LFxuICAgIHByb2R1Y3Rpb25zXzogWy4uLl0sXG4gICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gYW5vbnltb3VzKHl5dGV4dCwgeXlsZW5nLCB5eWxpbmVubywgeXksIHl5c3RhdGUsICQkLCBfJCksXG4gICAgdGFibGU6IFsuLi5dLFxuICAgIGRlZmF1bHRBY3Rpb25zOiB7Li4ufSxcbiAgICBwYXJzZUVycm9yOiBmdW5jdGlvbihzdHIsIGhhc2gpLFxuICAgIHBhcnNlOiBmdW5jdGlvbihpbnB1dCksXG5cbiAgICBsZXhlcjoge1xuICAgICAgICBFT0Y6IDEsXG4gICAgICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCksXG4gICAgICAgIHNldElucHV0OiBmdW5jdGlvbihpbnB1dCksXG4gICAgICAgIGlucHV0OiBmdW5jdGlvbigpLFxuICAgICAgICB1bnB1dDogZnVuY3Rpb24oc3RyKSxcbiAgICAgICAgbW9yZTogZnVuY3Rpb24oKSxcbiAgICAgICAgbGVzczogZnVuY3Rpb24obiksXG4gICAgICAgIHBhc3RJbnB1dDogZnVuY3Rpb24oKSxcbiAgICAgICAgdXBjb21pbmdJbnB1dDogZnVuY3Rpb24oKSxcbiAgICAgICAgc2hvd1Bvc2l0aW9uOiBmdW5jdGlvbigpLFxuICAgICAgICB0ZXN0X21hdGNoOiBmdW5jdGlvbihyZWdleF9tYXRjaF9hcnJheSwgcnVsZV9pbmRleCksXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uKCksXG4gICAgICAgIGxleDogZnVuY3Rpb24oKSxcbiAgICAgICAgYmVnaW46IGZ1bmN0aW9uKGNvbmRpdGlvbiksXG4gICAgICAgIHBvcFN0YXRlOiBmdW5jdGlvbigpLFxuICAgICAgICBfY3VycmVudFJ1bGVzOiBmdW5jdGlvbigpLFxuICAgICAgICB0b3BTdGF0ZTogZnVuY3Rpb24oKSxcbiAgICAgICAgcHVzaFN0YXRlOiBmdW5jdGlvbihjb25kaXRpb24pLFxuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHJhbmdlczogYm9vbGVhbiAgICAgICAgICAgKG9wdGlvbmFsOiB0cnVlID09PiB0b2tlbiBsb2NhdGlvbiBpbmZvIHdpbGwgaW5jbHVkZSBhIC5yYW5nZVtdIG1lbWJlcilcbiAgICAgICAgICAgIGZsZXg6IGJvb2xlYW4gICAgICAgICAgICAgKG9wdGlvbmFsOiB0cnVlID09PiBmbGV4LWxpa2UgbGV4aW5nIGJlaGF2aW91ciB3aGVyZSB0aGUgcnVsZXMgYXJlIHRlc3RlZCBleGhhdXN0aXZlbHkgdG8gZmluZCB0aGUgbG9uZ2VzdCBtYXRjaClcbiAgICAgICAgICAgIGJhY2t0cmFja19sZXhlcjogYm9vbGVhbiAgKG9wdGlvbmFsOiB0cnVlID09PiBsZXhlciByZWdleGVzIGFyZSB0ZXN0ZWQgaW4gb3JkZXIgYW5kIGZvciBlYWNoIG1hdGNoaW5nIHJlZ2V4IHRoZSBhY3Rpb24gY29kZSBpcyBpbnZva2VkOyB0aGUgbGV4ZXIgdGVybWluYXRlcyB0aGUgc2NhbiB3aGVuIGEgdG9rZW4gaXMgcmV0dXJuZWQgYnkgdGhlIGFjdGlvbiBjb2RlKVxuICAgICAgICB9LFxuXG4gICAgICAgIHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uKHl5LCB5eV8sICRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMsIFlZX1NUQVJUKSxcbiAgICAgICAgcnVsZXM6IFsuLi5dLFxuICAgICAgICBjb25kaXRpb25zOiB7YXNzb2NpYXRpdmUgbGlzdDogbmFtZSA9PT4gc2V0fSxcbiAgICB9XG4gIH1cblxuXG4gIHRva2VuIGxvY2F0aW9uIGluZm8gKEAkLCBfJCwgZXRjLik6IHtcbiAgICBmaXJzdF9saW5lOiBuLFxuICAgIGxhc3RfbGluZTogbixcbiAgICBmaXJzdF9jb2x1bW46IG4sXG4gICAgbGFzdF9jb2x1bW46IG4sXG4gICAgcmFuZ2U6IFtzdGFydF9udW1iZXIsIGVuZF9udW1iZXJdICAgICAgICh3aGVyZSB0aGUgbnVtYmVycyBhcmUgaW5kZXhlcyBpbnRvIHRoZSBpbnB1dCBzdHJpbmcsIHJlZ3VsYXIgemVyby1iYXNlZClcbiAgfVxuXG5cbiAgdGhlIHBhcnNlRXJyb3IgZnVuY3Rpb24gcmVjZWl2ZXMgYSAnaGFzaCcgb2JqZWN0IHdpdGggdGhlc2UgbWVtYmVycyBmb3IgbGV4ZXIgYW5kIHBhcnNlciBlcnJvcnM6IHtcbiAgICB0ZXh0OiAgICAgICAgKG1hdGNoZWQgdGV4dClcbiAgICB0b2tlbjogICAgICAgKHRoZSBwcm9kdWNlZCB0ZXJtaW5hbCB0b2tlbiwgaWYgYW55KVxuICAgIGxpbmU6ICAgICAgICAoeXlsaW5lbm8pXG4gIH1cbiAgd2hpbGUgcGFyc2VyIChncmFtbWFyKSBlcnJvcnMgd2lsbCBhbHNvIHByb3ZpZGUgdGhlc2UgbWVtYmVycywgaS5lLiBwYXJzZXIgZXJyb3JzIGRlbGl2ZXIgYSBzdXBlcnNldCBvZiBhdHRyaWJ1dGVzOiB7XG4gICAgbG9jOiAgICAgICAgICh5eWxsb2MpXG4gICAgZXhwZWN0ZWQ6ICAgIChzdHJpbmcgZGVzY3JpYmluZyB0aGUgc2V0IG9mIGV4cGVjdGVkIHRva2VucylcbiAgICByZWNvdmVyYWJsZTogKGJvb2xlYW46IFRSVUUgd2hlbiB0aGUgcGFyc2VyIGhhcyBhIGVycm9yIHJlY292ZXJ5IHJ1bGUgYXZhaWxhYmxlIGZvciB0aGlzIHBhcnRpY3VsYXIgZXJyb3IpXG4gIH1cbiovXG52YXIgcGFyc2VyID0gKGZ1bmN0aW9uKCl7XG52YXIgbz1mdW5jdGlvbihrLHYsbyxsKXtmb3Iobz1vfHx7fSxsPWsubGVuZ3RoO2wtLTtvW2tbbF1dPXYpO3JldHVybiBvfSwkVjA9WzEsMTFdLCRWMT1bMSwxNV0sJFYyPVsxLDE2XSwkVjM9WzEsMTddLCRWND1bMSwxOF0sJFY1PVsxLDE5XSwkVjY9WzEsMjBdLCRWNz1bMSwyM10sJFY4PVsxLDI3XSwkVjk9WzEsMzRdLCRWYT1bMSwzNV0sJFZiPVsxLDMzXSwkVmM9WzEsMjhdLCRWZD1bMSwyOV0sJFZlPVs1LDksMTAsMTQsMjEsMjIsMjMsMjQsMjUsMjYsMjksMzQsMzksNDEsNDgsNTEsNThdLCRWZj1bMiw4XSwkVmc9WzUsOSwxMCwyMSwyMiwyMywyNCwyNSwyNiwyOSwzNCwzOSw0MSw0OCw1MSw1OF0sJFZoPVs1LDIxLDIyLDIzLDI0LDI1LDI2XSwkVmk9WzIsNDddLCRWaj1bMSw0OF0sJFZrPVsxLDQ5XSwkVmw9WzEsNTBdLCRWbT1bMSw1MV0sJFZuPVsxLDUyXSwkVm89WzUsOSwxMCwyMSwyMiwyMywyNCwyNSwyNiwyOCwyOSwzNCwzNSwzOSw0MSw0OCw1MSw1Myw1OF0sJFZwPVs1LDksMTAsMjEsMjIsMjMsMjQsMjUsMjYsMjgsMjksMzQsMzUsMzksNDEsNDMsNDQsNDUsNDYsNDcsNDgsNTEsNTMsNThdLCRWcT1bNSw5LDEwLDIxLDIyLDIzLDI0LDI1LDI2LDI4LDI5LDM0LDM1LDM5LDQxLDQzLDQ0LDQ1LDQ2LDQ3LDQ4LDUwLDUxLDUzLDU4XSwkVnI9WzEsNjNdLCRWcz1bMSw2NF0sJFZ0PVs1LDIxLDIyLDIzLDI0LDI1LDI2LDI5LDM0LDM5LDQxLDQ4LDUxLDU4XSwkVnU9WzUsOSwxMCwyMSwyMiwyMywyNCwyNSwyNiwyOCwyOSwzNCwzNSwzOSw0MSw0Myw0OCw1MSw1Myw1OF0sJFZ2PVs1LDksMTAsMjEsMjIsMjMsMjQsMjUsMjYsMjgsMjksMzQsMzksNDEsNDgsNTEsNTMsNThdLCRWdz1bMzksNDEsNTBdO1xudmFyIHBhcnNlciA9IHt0cmFjZTogZnVuY3Rpb24gdHJhY2UoKSB7IH0sXG55eToge30sXG5zeW1ib2xzXzoge1wiMFwiOjI5LFwiZXJyb3JcIjoyLFwiZVwiOjMsXCJtYXliZV9tdXNqZVwiOjQsXCJFT0ZcIjo1LFwic3BhY2VcIjo2LFwibWF5YmVfc3BhY2VcIjo3LFwibXVzamVcIjo4LFwiU1wiOjksXCJOTFwiOjEwLFwic2NvcmVfaGVhZFwiOjExLFwicGFydF9saXN0XCI6MTIsXCJ0aXRsZVwiOjEzLFwiVElUTEVcIjoxNCxcIkNPTVBPU0VSXCI6MTUsXCJwYXJ0XCI6MTYsXCJtZWFzdXJlX2xpc3RcIjoxNyxcImJhclwiOjE4LFwibWVhc3VyZVwiOjE5LFwibXVzaWNfZGF0YVwiOjIwLFwifFwiOjIxLFwifHxcIjoyMixcInxdXCI6MjMsXCJ8OlwiOjI0LFwiOnxcIjoyNSxcIjp8OlwiOjI2LFwic2x1cmFibGVcIjoyNyxcIlRJRVwiOjI4LFwibWF5YmVfZHVyYXRpb25cIjozMCxcInZvaWNlXCI6MzEsXCJ0aW1lX3NpZ25hdHVyZVwiOjMyLFwicGl0Y2hmdWxcIjozMyxcIihcIjozNCxcIilcIjozNSxcIm5vdGVcIjozNixcImNob3JkXCI6MzcsXCJwaXRjaFwiOjM4LFwiU1RFUFwiOjM5LFwiT0NUQVZFXCI6NDAsXCJBQ0NJREVOVEFMXCI6NDEsXCJ0eXBlX21vZGlmaWVyXCI6NDIsXCJET1RcIjo0MyxcIl9cIjo0NCxcIj1cIjo0NSxcIkhBTEZcIjo0NixcIldIT0xFXCI6NDcsXCI8XCI6NDgsXCJwaXRjaF9saXN0XCI6NDksXCI+XCI6NTAsXCJ7XCI6NTEsXCJ2b2ljZV9saXN0XCI6NTIsXCJ9XCI6NTMsXCJ2b2ljZV9kYXRhX2xpc3RcIjo1NCxcIjpcIjo1NSxcInZvaWNlX2RhdGFcIjo1NixcInJlc3RzbHVyYWJsZV9saXN0XCI6NTcsXCJCRUFUU1wiOjU4LFwiQkVBVF9UWVBFXCI6NTksXCIkYWNjZXB0XCI6MCxcIiRlbmRcIjoxfSxcbnRlcm1pbmFsc186IHsyOlwiZXJyb3JcIiw1OlwiRU9GXCIsOTpcIlNcIiwxMDpcIk5MXCIsMTQ6XCJUSVRMRVwiLDE1OlwiQ09NUE9TRVJcIiwyMTpcInxcIiwyMjpcInx8XCIsMjM6XCJ8XVwiLDI0OlwifDpcIiwyNTpcIjp8XCIsMjY6XCI6fDpcIiwyODpcIlRJRVwiLDI5OlwiMFwiLDM0OlwiKFwiLDM1OlwiKVwiLDM5OlwiU1RFUFwiLDQwOlwiT0NUQVZFXCIsNDE6XCJBQ0NJREVOVEFMXCIsNDM6XCJET1RcIiw0NDpcIl9cIiw0NTpcIj1cIiw0NjpcIkhBTEZcIiw0NzpcIldIT0xFXCIsNDg6XCI8XCIsNTA6XCI+XCIsNTE6XCJ7XCIsNTM6XCJ9XCIsNTQ6XCJ2b2ljZV9kYXRhX2xpc3RcIiw1NTpcIjpcIiw1NzpcInJlc3RzbHVyYWJsZV9saXN0XCIsNTg6XCJCRUFUU1wiLDU5OlwiQkVBVF9UWVBFXCJ9LFxucHJvZHVjdGlvbnNfOiBbMCxbMywyXSxbNCwwXSxbNCwyXSxbNCwzXSxbNCwxXSxbNiwxXSxbNiwxXSxbNywwXSxbNywyXSxbNywyXSxbOCwxXSxbOCwxXSxbOCwyXSxbMTEsMl0sWzEzLDFdLFsxMywyXSxbMTIsMV0sWzE2LDFdLFsxNiwzXSxbMTcsMV0sWzE3LDRdLFsxNywzXSxbMTksMl0sWzE5LDNdLFsxOCwxXSxbMTgsMV0sWzE4LDFdLFsxOCwxXSxbMTgsMV0sWzE4LDFdLFsyMCwxXSxbMjAsMl0sWzIwLDJdLFsyMCwxXSxbMjAsMV0sWzI3LDJdLFsyNywzXSxbMjcsM10sWzI3LDRdLFszMywxXSxbMzMsMV0sWzM2LDFdLFszOCwxXSxbMzgsMl0sWzM4LDJdLFszOCwzXSxbMzAsMF0sWzMwLDFdLFszMCwxXSxbMzAsMl0sWzQyLDFdLFs0MiwxXSxbNDIsMl0sWzQyLDJdLFs0MiwzXSxbNDIsM10sWzQyLDFdLFs0MiwxXSxbMzcsM10sWzQ5LDFdLFs0OSwyXSxbMzEsM10sWzUyLDFdLFs1MiwzXSxbNTYsMV0sWzU2LDJdLFszMiwyXV0sXG5wZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB5eSwgeXlzdGF0ZSAvKiBhY3Rpb25bMV0gKi8sICQkIC8qIHZzdGFjayAqLywgXyQgLyogbHN0YWNrICovKSB7XG4vKiB0aGlzID09IHl5dmFsICovXG5cbnZhciAkMCA9ICQkLmxlbmd0aCAtIDE7XG5zd2l0Y2ggKHl5c3RhdGUpIHtcbmNhc2UgMTpcbiByZXR1cm4gJCRbJDAtMV07IFxuYnJlYWs7XG5jYXNlIDI6IGNhc2UgMzpcbiB0aGlzLiQgPSBudWxsOyBcbmJyZWFrO1xuY2FzZSA0OiBjYXNlIDU6XG4gdGhpcy4kID0gJCRbJDBdOyByZW1vdmVMYXN0RW1wdHlNZWFzdXJlKCQkWyQwXSk7IFxuYnJlYWs7XG5jYXNlIDEwOlxuIHRoaXMuJCA9ICQkWyQwLTFdID8gJCRbJDAtMV0gKyAxIDogMTsgXG5icmVhaztcbmNhc2UgMTE6XG50aGlzLiQgPSB7IGhlYWQ6ICQkWyQwXSB9O1xuYnJlYWs7XG5jYXNlIDEyOlxudGhpcy4kID0geyBwYXJ0czogJCRbJDBdIH07XG5icmVhaztcbmNhc2UgMTM6XG50aGlzLiQgPSB7IGhlYWQ6ICQkWyQwLTFdLCBwYXJ0czogJCRbJDBdIH07XG5icmVhaztcbmNhc2UgMTU6XG4gdGhpcy4kID0geyB0aXRsZTogJCRbJDBdIH0gXG5icmVhaztcbmNhc2UgMTY6XG4gdGhpcy4kID0gIHsgdGl0bGU6ICQkWyQwLTFdLCBjb21wb3NlcjogJCRbJDBdIH0gXG5icmVhaztcbmNhc2UgMTc6IGNhc2UgNjA6IGNhc2UgNjM6XG50aGlzLiQgPSBbJCRbJDBdXTtcbmJyZWFrO1xuY2FzZSAxODpcbnRoaXMuJCA9IHsgbWVhc3VyZXM6ICQkWyQwXSB9O1xuYnJlYWs7XG5jYXNlIDE5OlxuIHRoaXMuJCA9IHsgbWVhc3VyZXM6ICQkWyQwXX07ICQkWyQwXVswXS5kYXRhLnVuc2hpZnQoeyBiYXI6ICQkWyQwLTJdIH0pOyBcbmJyZWFrO1xuY2FzZSAyMDpcbiB0aGlzLiQgPSBbJCRbJDBdXTsgXG5icmVhaztcbmNhc2UgMjE6XG4gdGhpcy4kID0gJCRbJDAtM107IGxhc3RJdGVtKCQkWyQwLTNdKS5kYXRhLnB1c2goeyBiYXI6ICQkWyQwLTJdIH0pOyAkJFskMC0zXS5wdXNoKCQkWyQwXSkgXG5icmVhaztcbmNhc2UgMjI6XG4gdGhpcy4kID0gJCRbJDAtMl07IGxhc3RJdGVtKCQkWyQwLTJdKS5kYXRhLnB1c2goeyBiYXI6ICQkWyQwLTFdIH0pOyAkJFskMC0yXS5wdXNoKHsgZGF0YTogW10gfSkgXG5icmVhaztcbmNhc2UgMjM6XG50aGlzLiQgPSB7IGRhdGE6IFskJFskMC0xXV0gfTtcbmJyZWFrO1xuY2FzZSAyNDpcbiB0aGlzLiQgPSAkJFskMC0yXTsgJCRbJDAtMl0uZGF0YS5wdXNoKCQkWyQwLTFdKSBcbmJyZWFrO1xuY2FzZSAyNTpcbnRoaXMuJCA9ICdzaW5nbGUnO1xuYnJlYWs7XG5jYXNlIDI2OlxudGhpcy4kID0gJ2RvdWJsZSc7XG5icmVhaztcbmNhc2UgMjc6XG50aGlzLiQgPSAnZW5kJztcbmJyZWFrO1xuY2FzZSAyODpcbnRoaXMuJCA9ICdyZXBlYXQtYmVnaW4nO1xuYnJlYWs7XG5jYXNlIDI5OlxudGhpcy4kID0gJ3JlcGVhdC1lbmQnO1xuYnJlYWs7XG5jYXNlIDMwOlxudGhpcy4kID0gJ3JlcGVhdC1ib3RoJztcbmJyZWFrO1xuY2FzZSAzMjpcbiB0aGlzLiQgPSAkJFskMC0xXTsgb25seVByb3BlcnR5KCQkWyQwLTFdKS50aWUgPSAnficgXG5icmVhaztcbmNhc2UgMzM6XG50aGlzLiQgPSB7IHJlc3Q6IHsgZHVyYXRpb246ICQkWyQwXSB9IH07XG5icmVhaztcbmNhc2UgMzQ6XG50aGlzLiQgPSB7IHZvaWNlOiAkJFskMF0gfTtcbmJyZWFrO1xuY2FzZSAzNjpcbiB0aGlzLiQgPSAkJFskMC0xXTsgb25seVByb3BlcnR5KCQkWyQwLTFdKS5kdXJhdGlvbiA9ICQkWyQwXSBcbmJyZWFrO1xuY2FzZSAzNzpcblxuICAgICAgdGhpcy4kID0gJCRbJDAtMV07XG4gICAgICBleHRlbmQob25seVByb3BlcnR5KCQkWyQwLTFdKSwge1xuICAgICAgICBkdXJhdGlvbjogJCRbJDBdLFxuICAgICAgICBzbHVyOiB7IGJlZ2luOiAnc29saWQnIH1cbiAgICAgIH0pXG4gICAgXG5icmVhaztcbmNhc2UgMzg6XG5cbiAgICAgIHRoaXMuJCA9ICQkWyQwLTJdXG4gICAgICBleHRlbmQob25seVByb3BlcnR5KCQkWyQwLTJdKSwge1xuICAgICAgICBkdXJhdGlvbjogJCRbJDAtMV0sXG4gICAgICAgIHNsdXI6IHsgZW5kOiAnc29saWQnIH1cbiAgICAgIH0pXG4gICAgXG5icmVhaztcbmNhc2UgMzk6XG5cbiAgICAgIHRoaXMuJCA9ICQkWyQwLTJdXG4gICAgICBleHRlbmQob25seVByb3BlcnR5KCQkWyQwLTJdKSwge1xuICAgICAgICBkdXJhdGlvbjogJCRbJDAtMV0sXG4gICAgICAgIHNsdXI6IHsgYmVnaW46ICdzb2xpZCcsIGVuZDogJ3NvbGlkJyB9XG4gICAgICB9KVxuICAgIFxuYnJlYWs7XG5jYXNlIDQwOlxudGhpcy4kID0geyBub3RlOiAkJFskMF0gfTtcbmJyZWFrO1xuY2FzZSA0MTpcbnRoaXMuJCA9IHsgY2hvcmQ6ICQkWyQwXSB9O1xuYnJlYWs7XG5jYXNlIDQyOlxudGhpcy4kID0geyBwaXRjaDogJCRbJDBdIH07XG5icmVhaztcbmNhc2UgNDM6XG50aGlzLiQgPSB7IHN0ZXA6ICskJFskMF0gfTtcbmJyZWFrO1xuY2FzZSA0NDpcbnRoaXMuJCA9IHsgc3RlcDogKyQkWyQwLTFdLCBvY3RhdmU6IG9jdGF2ZSgkJFskMF0pIH07XG5icmVhaztcbmNhc2UgNDU6XG50aGlzLiQgPSB7IGFjY2lkZW50YWw6ICQkWyQwLTFdLCBzdGVwOiArJCRbJDBdIH07XG5icmVhaztcbmNhc2UgNDY6XG50aGlzLiQgPSB7IGFjY2lkZW50YWw6ICQkWyQwLTJdLCBzdGVwOiArJCRbJDAtMV0sIG9jdGF2ZTogb2N0YXZlKCQkWyQwXSkgfTtcbmJyZWFrO1xuY2FzZSA0ODpcbnRoaXMuJCA9IHsgdHlwZTogJCRbJDBdIH07XG5icmVhaztcbmNhc2UgNDk6XG50aGlzLiQgPSB7IHR5cGU6IDQsIGRvdDogJCRbJDBdLmxlbmd0aCB9O1xuYnJlYWs7XG5jYXNlIDUwOlxudGhpcy4kID0geyB0eXBlOiAkJFskMC0xXSwgZG90OiAkJFskMF0ubGVuZ3RoIH07XG5icmVhaztcbmNhc2UgNTE6XG50aGlzLiQgPSA4O1xuYnJlYWs7XG5jYXNlIDUyOlxudGhpcy4kID0gMTY7XG5icmVhaztcbmNhc2UgNTM6XG50aGlzLiQgPSAzMjtcbmJyZWFrO1xuY2FzZSA1NDpcbnRoaXMuJCA9IDY0O1xuYnJlYWs7XG5jYXNlIDU1OlxudGhpcy4kID0gMTI4O1xuYnJlYWs7XG5jYXNlIDU2OlxudGhpcy4kID0gMjU2O1xuYnJlYWs7XG5jYXNlIDU3OlxudGhpcy4kID0gMjtcbmJyZWFrO1xuY2FzZSA1ODpcbnRoaXMuJCA9IDE7XG5icmVhaztcbmNhc2UgNTk6XG50aGlzLiQgPSB7IHBpdGNoZXM6ICQkWyQwLTFdIH07XG5icmVhaztcbmNhc2UgNjE6IGNhc2UgNjY6XG4gdGhpcy4kID0gJCRbJDAtMV07ICQkWyQwLTFdLnB1c2goJCRbJDBdKSBcbmJyZWFrO1xuY2FzZSA2MjpcbnRoaXMuJCA9ICQkWyQwLTFdO1xuYnJlYWs7XG5jYXNlIDY0OlxuIHRoaXMuJCA9ICQkWyQwLTJdOyAkJFskMC0yXS5wdXNoKCQkWyQwLTFdKSBcbmJyZWFrO1xuY2FzZSA2NzpcbnRoaXMuJCA9IHsgdGltZTogeyBiZWF0czogKyQkWyQwLTFdLCBiZWF0VHlwZTogKyQkWyQwXSB9IH07XG5icmVhaztcbn1cbn0sXG50YWJsZTogW3szOjEsNDoyLDU6WzIsMl0sNjozLDg6NCw5OlsxLDVdLDEwOlsxLDZdLDExOjcsMTI6OCwxMzo5LDE0OiRWMCwxNjoxMCwxNzoxMiwxODoxMywxOToxNCwyMDoyMSwyMTokVjEsMjI6JFYyLDIzOiRWMywyNDokVjQsMjU6JFY1LDI2OiRWNiwyNzoyMiwyOTokVjcsMzE6MjQsMzI6MjUsMzM6MjYsMzQ6JFY4LDM2OjMwLDM3OjMxLDM4OjMyLDM5OiRWOSw0MTokVmEsNDg6JFZiLDUxOiRWYyw1ODokVmR9LHsxOlszXX0sezU6WzEsMzZdfSxvKCRWZSwkVmYsezc6Mzd9KSx7NTpbMiw1XX0sbygkVmUsWzIsNl0pLG8oJFZlLFsyLDddKSx7NTpbMiwxMV0sMTI6MzgsMTY6MTAsMTc6MTIsMTg6MTMsMTk6MTQsMjA6MjEsMjE6JFYxLDIyOiRWMiwyMzokVjMsMjQ6JFY0LDI1OiRWNSwyNjokVjYsMjc6MjIsMjk6JFY3LDMxOjI0LDMyOjI1LDMzOjI2LDM0OiRWOCwzNjozMCwzNzozMSwzODozMiwzOTokVjksNDE6JFZhLDQ4OiRWYiw1MTokVmMsNTg6JFZkfSx7NTpbMiwxMl19LG8oJFZnLCRWZix7NzozOX0pLHs1OlsyLDE3XX0sbygkVmcsWzIsMTVdLHsxNTpbMSw0MF19KSx7NTpbMiwxOF0sMTg6NDEsMjE6JFYxLDIyOiRWMiwyMzokVjMsMjQ6JFY0LDI1OiRWNSwyNjokVjZ9LG8oWzksMTAsMjksMzQsMzksNDEsNDgsNTEsNThdLCRWZix7Nzo0Mn0pLG8oJFZoLFsyLDIwXSx7Mjc6MjIsMzE6MjQsMzI6MjUsMzM6MjYsMzY6MzAsMzc6MzEsMzg6MzIsMjA6NDMsMjk6JFY3LDM0OiRWOCwzOTokVjksNDE6JFZhLDQ4OiRWYiw1MTokVmMsNTg6JFZkfSksbygkVmcsWzIsMjVdKSxvKCRWZyxbMiwyNl0pLG8oJFZnLFsyLDI3XSksbygkVmcsWzIsMjhdKSxvKCRWZyxbMiwyOV0pLG8oJFZnLFsyLDMwXSksbygkVmcsJFZmLHs3OjQ0fSksbygkVmcsWzIsMzFdLHsyODpbMSw0NV19KSxvKCRWZywkVmksezMwOjQ2LDQyOjQ3LDQzOiRWaiw0NDokVmssNDU6JFZsLDQ2OiRWbSw0NzokVm59KSxvKCRWZyxbMiwzNF0pLG8oJFZnLFsyLDM1XSksbygkVm8sJFZpLHs0Mjo0NywzMDo1Myw0MzokVmosNDQ6JFZrLDQ1OiRWbCw0NjokVm0sNDc6JFZufSksezMzOjU0LDM2OjMwLDM3OjMxLDM4OjMyLDM5OiRWOSw0MTokVmEsNDg6JFZifSx7NTI6NTUsNTQ6WzEsNTZdfSx7NTk6WzEsNTddfSxvKCRWcCxbMiw0MF0pLG8oJFZwLFsyLDQxXSksbygkVnAsWzIsNDJdKSx7Mzg6NTksMzk6JFY5LDQxOiRWYSw0OTo1OH0sbygkVnEsWzIsNDNdLHs0MDpbMSw2MF19KSx7Mzk6WzEsNjFdfSx7MTpbMiwxXX0sezU6WzIsM10sODo2Miw5OiRWciwxMDokVnMsMTE6NywxMjo4LDEzOjksMTQ6JFYwLDE2OjEwLDE3OjEyLDE4OjEzLDE5OjE0LDIwOjIxLDIxOiRWMSwyMjokVjIsMjM6JFYzLDI0OiRWNCwyNTokVjUsMjY6JFY2LDI3OjIyLDI5OiRWNywzMToyNCwzMjoyNSwzMzoyNiwzNDokVjgsMzY6MzAsMzc6MzEsMzg6MzIsMzk6JFY5LDQxOiRWYSw0ODokVmIsNTE6JFZjLDU4OiRWZH0sezU6WzIsMTNdfSxvKCRWdCxbMiwxNF0sezk6JFZyLDEwOiRWc30pLG8oJFZnLFsyLDE2XSksbygkVmcsJFZmLHs3OjY1fSksezk6JFZyLDEwOiRWcywxNzo2NiwxOToxNCwyMDoyMSwyNzoyMiwyOTokVjcsMzE6MjQsMzI6MjUsMzM6MjYsMzQ6JFY4LDM2OjMwLDM3OjMxLDM4OjMyLDM5OiRWOSw0MTokVmEsNDg6JFZiLDUxOiRWYyw1ODokVmR9LG8oJFZnLCRWZix7Nzo2N30pLG8oJFZ0LFsyLDIzXSx7OTokVnIsMTA6JFZzfSksbygkVmcsWzIsMzJdKSxvKCRWZyxbMiwzM10pLG8oJFZvLFsyLDQ4XSx7NDM6WzEsNjhdfSksbygkVm8sWzIsNDldKSxvKCRWdSxbMiw1MV0pLG8oJFZ1LFsyLDUyXSx7NDQ6WzEsNjldLDQ1OlsxLDcwXX0pLG8oJFZ1LFsyLDU3XSksbygkVnUsWzIsNThdKSxvKCRWdixbMiwzNl0sezM1OlsxLDcxXX0pLG8oJFZvLCRWaSx7NDI6NDcsMzA6NzIsNDM6JFZqLDQ0OiRWayw0NTokVmwsNDY6JFZtLDQ3OiRWbn0pLHs1MzpbMSw3M119LHs1MzpbMiw2M10sNTU6WzEsNzRdfSxvKCRWZyxbMiw2N10pLHszODo3NiwzOTokVjksNDE6JFZhLDUwOlsxLDc1XX0sbygkVncsWzIsNjBdKSxvKCRWcSxbMiw0NF0pLG8oJFZxLFsyLDQ1XSx7NDA6WzEsNzddfSksezU6WzIsNF19LG8oJFZlLFsyLDldKSxvKCRWZSxbMiwxMF0pLG8oJFZoLFsyLDIyXSx7MjA6MjEsMjc6MjIsMzE6MjQsMzI6MjUsMzM6MjYsMzY6MzAsMzc6MzEsMzg6MzIsMTk6NzgsOTokVnIsMTA6JFZzLDI5OiRWNywzNDokVjgsMzk6JFY5LDQxOiRWYSw0ODokVmIsNTE6JFZjLDU4OiRWZH0pLHs1OlsyLDE5XSwxODo0MSwyMTokVjEsMjI6JFYyLDIzOiRWMywyNDokVjQsMjU6JFY1LDI2OiRWNn0sbygkVnQsWzIsMjRdLHs5OiRWciwxMDokVnN9KSxvKCRWbyxbMiw1MF0pLG8oJFZ1LFsyLDUzXSksbygkVnUsWzIsNTRdLHs0NDpbMSw3OV0sNDU6WzEsODBdfSksbygkVnYsWzIsMzhdKSxvKCRWdixbMiwzN10sezM1OlsxLDgxXX0pLG8oJFZnLFsyLDYyXSksezI3OjgzLDMzOjI2LDM0OiRWOCwzNjozMCwzNzozMSwzODozMiwzOTokVjksNDE6JFZhLDQ4OiRWYiw1Njo4Miw1NzpbMSw4NF19LG8oJFZwLFsyLDU5XSksbygkVncsWzIsNjFdKSxvKCRWcSxbMiw0Nl0pLG8oJFZoLFsyLDIxXSx7Mjc6MjIsMzE6MjQsMzI6MjUsMzM6MjYsMzY6MzAsMzc6MzEsMzg6MzIsMjA6NDMsMjk6JFY3LDM0OiRWOCwzOTokVjksNDE6JFZhLDQ4OiRWYiw1MTokVmMsNTg6JFZkfSksbygkVnUsWzIsNTVdKSxvKCRWdSxbMiw1Nl0pLG8oJFZ2LFsyLDM5XSksezUzOlsyLDY0XX0sezUzOlsyLDY1XX0sezI3Ojg1LDMzOjI2LDM0OiRWOCwzNjozMCwzNzozMSwzODozMiwzOTokVjksNDE6JFZhLDQ4OiRWYn0sezUzOlsyLDY2XX1dLFxuZGVmYXVsdEFjdGlvbnM6IHs0OlsyLDVdLDg6WzIsMTJdLDEwOlsyLDE3XSwzNjpbMiwxXSwzODpbMiwxM10sNjI6WzIsNF0sODI6WzIsNjRdLDgzOlsyLDY1XSw4NTpbMiw2Nl19LFxucGFyc2VFcnJvcjogZnVuY3Rpb24gcGFyc2VFcnJvcihzdHIsIGhhc2gpIHtcbiAgICBpZiAoaGFzaC5yZWNvdmVyYWJsZSkge1xuICAgICAgICB0aGlzLnRyYWNlKHN0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZnVuY3Rpb24gX3BhcnNlRXJyb3IgKG1zZywgaGFzaCkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbXNnO1xuICAgICAgICAgICAgdGhpcy5oYXNoID0gaGFzaDtcbiAgICAgICAgfVxuICAgICAgICBfcGFyc2VFcnJvci5wcm90b3R5cGUgPSBFcnJvcjtcblxuICAgICAgICB0aHJvdyBuZXcgX3BhcnNlRXJyb3Ioc3RyLCBoYXNoKTtcbiAgICB9XG59LFxucGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGlucHV0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLCBzdGFjayA9IFswXSwgdHN0YWNrID0gW10sIHZzdGFjayA9IFtudWxsXSwgbHN0YWNrID0gW10sIHRhYmxlID0gdGhpcy50YWJsZSwgeXl0ZXh0ID0gJycsIHl5bGluZW5vID0gMCwgeXlsZW5nID0gMCwgcmVjb3ZlcmluZyA9IDAsIFRFUlJPUiA9IDIsIEVPRiA9IDE7XG4gICAgdmFyIGFyZ3MgPSBsc3RhY2suc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHZhciBsZXhlciA9IE9iamVjdC5jcmVhdGUodGhpcy5sZXhlcik7XG4gICAgdmFyIHNoYXJlZFN0YXRlID0geyB5eToge30gfTtcbiAgICBmb3IgKHZhciBrIGluIHRoaXMueXkpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnl5LCBrKSkge1xuICAgICAgICAgICAgc2hhcmVkU3RhdGUueXlba10gPSB0aGlzLnl5W2tdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxleGVyLnNldElucHV0KGlucHV0LCBzaGFyZWRTdGF0ZS55eSk7XG4gICAgc2hhcmVkU3RhdGUueXkubGV4ZXIgPSBsZXhlcjtcbiAgICBzaGFyZWRTdGF0ZS55eS5wYXJzZXIgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgbGV4ZXIueXlsbG9jID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGxleGVyLnl5bGxvYyA9IHt9O1xuICAgIH1cbiAgICB2YXIgeXlsb2MgPSBsZXhlci55eWxsb2M7XG4gICAgbHN0YWNrLnB1c2goeXlsb2MpO1xuICAgIHZhciByYW5nZXMgPSBsZXhlci5vcHRpb25zICYmIGxleGVyLm9wdGlvbnMucmFuZ2VzO1xuICAgIGlmICh0eXBlb2Ygc2hhcmVkU3RhdGUueXkucGFyc2VFcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnBhcnNlRXJyb3IgPSBzaGFyZWRTdGF0ZS55eS5wYXJzZUVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyc2VFcnJvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5wYXJzZUVycm9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BTdGFjayhuKSB7XG4gICAgICAgIHN0YWNrLmxlbmd0aCA9IHN0YWNrLmxlbmd0aCAtIDIgKiBuO1xuICAgICAgICB2c3RhY2subGVuZ3RoID0gdnN0YWNrLmxlbmd0aCAtIG47XG4gICAgICAgIGxzdGFjay5sZW5ndGggPSBsc3RhY2subGVuZ3RoIC0gbjtcbiAgICB9XG4gICAgX3Rva2VuX3N0YWNrOlxuICAgICAgICB2YXIgbGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5sZXgoKSB8fCBFT0Y7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRva2VuID0gc2VsZi5zeW1ib2xzX1t0b2tlbl0gfHwgdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH07XG4gICAgdmFyIHN5bWJvbCwgcHJlRXJyb3JTeW1ib2wsIHN0YXRlLCBhY3Rpb24sIGEsIHIsIHl5dmFsID0ge30sIHAsIGxlbiwgbmV3U3RhdGUsIGV4cGVjdGVkO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXSkge1xuICAgICAgICAgICAgYWN0aW9uID0gdGhpcy5kZWZhdWx0QWN0aW9uc1tzdGF0ZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3ltYm9sID09PSBudWxsIHx8IHR5cGVvZiBzeW1ib2wgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBsZXgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjdGlvbiA9IHRhYmxlW3N0YXRlXSAmJiB0YWJsZVtzdGF0ZV1bc3ltYm9sXTtcbiAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ3VuZGVmaW5lZCcgfHwgIWFjdGlvbi5sZW5ndGggfHwgIWFjdGlvblswXSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJTdHIgPSAnJztcbiAgICAgICAgICAgICAgICBleHBlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAocCBpbiB0YWJsZVtzdGF0ZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudGVybWluYWxzX1twXSAmJiBwID4gVEVSUk9SKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZC5wdXNoKCdcXCcnICsgdGhpcy50ZXJtaW5hbHNfW3BdICsgJ1xcJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsZXhlci5zaG93UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gJ1BhcnNlIGVycm9yIG9uIGxpbmUgJyArICh5eWxpbmVubyArIDEpICsgJzpcXG4nICsgbGV4ZXIuc2hvd1Bvc2l0aW9uKCkgKyAnXFxuRXhwZWN0aW5nICcgKyBleHBlY3RlZC5qb2luKCcsICcpICsgJywgZ290IFxcJycgKyAodGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sKSArICdcXCcnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVyclN0ciA9ICdQYXJzZSBlcnJvciBvbiBsaW5lICcgKyAoeXlsaW5lbm8gKyAxKSArICc6IFVuZXhwZWN0ZWQgJyArIChzeW1ib2wgPT0gRU9GID8gJ2VuZCBvZiBpbnB1dCcgOiAnXFwnJyArICh0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wpICsgJ1xcJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlRXJyb3IoZXJyU3RyLCB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGxleGVyLm1hdGNoLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbjogdGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sLFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiBsZXhlci55eWxpbmVubyxcbiAgICAgICAgICAgICAgICAgICAgbG9jOiB5eWxvYyxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmIChhY3Rpb25bMF0gaW5zdGFuY2VvZiBBcnJheSAmJiBhY3Rpb24ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJzZSBFcnJvcjogbXVsdGlwbGUgYWN0aW9ucyBwb3NzaWJsZSBhdCBzdGF0ZTogJyArIHN0YXRlICsgJywgdG9rZW46ICcgKyBzeW1ib2wpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYWN0aW9uWzBdKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHN0YWNrLnB1c2goc3ltYm9sKTtcbiAgICAgICAgICAgIHZzdGFjay5wdXNoKGxleGVyLnl5dGV4dCk7XG4gICAgICAgICAgICBsc3RhY2sucHVzaChsZXhlci55eWxsb2MpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChhY3Rpb25bMV0pO1xuICAgICAgICAgICAgc3ltYm9sID0gbnVsbDtcbiAgICAgICAgICAgIGlmICghcHJlRXJyb3JTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICB5eWxlbmcgPSBsZXhlci55eWxlbmc7XG4gICAgICAgICAgICAgICAgeXl0ZXh0ID0gbGV4ZXIueXl0ZXh0O1xuICAgICAgICAgICAgICAgIHl5bGluZW5vID0gbGV4ZXIueXlsaW5lbm87XG4gICAgICAgICAgICAgICAgeXlsb2MgPSBsZXhlci55eWxsb2M7XG4gICAgICAgICAgICAgICAgaWYgKHJlY292ZXJpbmcgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY292ZXJpbmctLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IHByZUVycm9yU3ltYm9sO1xuICAgICAgICAgICAgICAgIHByZUVycm9yU3ltYm9sID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBsZW4gPSB0aGlzLnByb2R1Y3Rpb25zX1thY3Rpb25bMV1dWzFdO1xuICAgICAgICAgICAgeXl2YWwuJCA9IHZzdGFja1t2c3RhY2subGVuZ3RoIC0gbGVuXTtcbiAgICAgICAgICAgIHl5dmFsLl8kID0ge1xuICAgICAgICAgICAgICAgIGZpcnN0X2xpbmU6IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gKGxlbiB8fCAxKV0uZmlyc3RfbGluZSxcbiAgICAgICAgICAgICAgICBsYXN0X2xpbmU6IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gMV0ubGFzdF9saW5lLFxuICAgICAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAobGVuIHx8IDEpXS5maXJzdF9jb2x1bW4sXG4gICAgICAgICAgICAgICAgbGFzdF9jb2x1bW46IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gMV0ubGFzdF9jb2x1bW5cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgeXl2YWwuXyQucmFuZ2UgPSBbXG4gICAgICAgICAgICAgICAgICAgIGxzdGFja1tsc3RhY2subGVuZ3RoIC0gKGxlbiB8fCAxKV0ucmFuZ2VbMF0sXG4gICAgICAgICAgICAgICAgICAgIGxzdGFja1tsc3RhY2subGVuZ3RoIC0gMV0ucmFuZ2VbMV1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgciA9IHRoaXMucGVyZm9ybUFjdGlvbi5hcHBseSh5eXZhbCwgW1xuICAgICAgICAgICAgICAgIHl5dGV4dCxcbiAgICAgICAgICAgICAgICB5eWxlbmcsXG4gICAgICAgICAgICAgICAgeXlsaW5lbm8sXG4gICAgICAgICAgICAgICAgc2hhcmVkU3RhdGUueXksXG4gICAgICAgICAgICAgICAgYWN0aW9uWzFdLFxuICAgICAgICAgICAgICAgIHZzdGFjayxcbiAgICAgICAgICAgICAgICBsc3RhY2tcbiAgICAgICAgICAgIF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBzdGFjayA9IHN0YWNrLnNsaWNlKDAsIC0xICogbGVuICogMik7XG4gICAgICAgICAgICAgICAgdnN0YWNrID0gdnN0YWNrLnNsaWNlKDAsIC0xICogbGVuKTtcbiAgICAgICAgICAgICAgICBsc3RhY2sgPSBsc3RhY2suc2xpY2UoMCwgLTEgKiBsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhY2sucHVzaCh0aGlzLnByb2R1Y3Rpb25zX1thY3Rpb25bMV1dWzBdKTtcbiAgICAgICAgICAgIHZzdGFjay5wdXNoKHl5dmFsLiQpO1xuICAgICAgICAgICAgbHN0YWNrLnB1c2goeXl2YWwuXyQpO1xuICAgICAgICAgICAgbmV3U3RhdGUgPSB0YWJsZVtzdGFja1tzdGFjay5sZW5ndGggLSAyXV1bc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1dO1xuICAgICAgICAgICAgc3RhY2sucHVzaChuZXdTdGF0ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59fTtcblxuXG5jb25zdCBleHRlbmQgPSByZXF1aXJlKCcuLi91dGlsJykuZXh0ZW5kXG5cbmNvbnN0IGxhc3RJdGVtID0gYXJyID0+IGFyclthcnIubGVuZ3RoIC0gMV1cblxuY29uc3Qgb25seVByb3BlcnR5ID0gb2JqID0+IG9ialtPYmplY3Qua2V5cyhvYmopWzBdXVxuXG5jb25zdCBvY3RhdmUgPSBzdHIgPT4ge1xuICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoXG4gIHJldHVybiBzdHIuY2hhckF0KDApID09PSAnLCcgPyAtbGVuIDogbGVuXG59XG5cbmNvbnN0IHJlbW92ZUxhc3RFbXB0eU1lYXN1cmUgPSBzY29yZSA9PiB7XG4gIGNvbnN0IHBhcnRzID0gc2NvcmUucGFydHNcbiAgaWYgKCFwYXJ0cykgcmV0dXJuXG5cbiAgcGFydHMuZm9yRWFjaChwYXJ0ID0+IHtcbiAgICBjb25zdCBsYXN0TWVhc3VyZSA9IGxhc3RJdGVtKHBhcnQubWVhc3VyZXMpXG4gICAgaWYgKGxhc3RNZWFzdXJlLmRhdGEubGVuZ3RoID09PSAwKSBwYXJ0Lm1lYXN1cmVzLnBvcCgpXG4gIH0pXG59XG5cbi8qIGdlbmVyYXRlZCBieSBqaXNvbi1sZXggMC4zLjQgKi9cbnZhciBsZXhlciA9IChmdW5jdGlvbigpe1xudmFyIGxleGVyID0gKHtcblxuRU9GOjEsXG5cbnBhcnNlRXJyb3I6ZnVuY3Rpb24gcGFyc2VFcnJvcihzdHIsIGhhc2gpIHtcbiAgICAgICAgaWYgKHRoaXMueXkucGFyc2VyKSB7XG4gICAgICAgICAgICB0aGlzLnl5LnBhcnNlci5wYXJzZUVycm9yKHN0ciwgaGFzaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIHJlc2V0cyB0aGUgbGV4ZXIsIHNldHMgbmV3IGlucHV0XG5zZXRJbnB1dDpmdW5jdGlvbiAoaW5wdXQsIHl5KSB7XG4gICAgICAgIHRoaXMueXkgPSB5eSB8fCB0aGlzLnl5IHx8IHt9O1xuICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLl9tb3JlID0gdGhpcy5fYmFja3RyYWNrID0gdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMueXlsaW5lbm8gPSB0aGlzLnl5bGVuZyA9IDA7XG4gICAgICAgIHRoaXMueXl0ZXh0ID0gdGhpcy5tYXRjaGVkID0gdGhpcy5tYXRjaCA9ICcnO1xuICAgICAgICB0aGlzLmNvbmRpdGlvblN0YWNrID0gWydJTklUSUFMJ107XG4gICAgICAgIHRoaXMueXlsbG9jID0ge1xuICAgICAgICAgICAgZmlyc3RfbGluZTogMSxcbiAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogMCxcbiAgICAgICAgICAgIGxhc3RfbGluZTogMSxcbiAgICAgICAgICAgIGxhc3RfY29sdW1uOiAwXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFswLDBdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuLy8gY29uc3VtZXMgYW5kIHJldHVybnMgb25lIGNoYXIgZnJvbSB0aGUgaW5wdXRcbmlucHV0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoID0gdGhpcy5faW5wdXRbMF07XG4gICAgICAgIHRoaXMueXl0ZXh0ICs9IGNoO1xuICAgICAgICB0aGlzLnl5bGVuZysrO1xuICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICB0aGlzLm1hdGNoICs9IGNoO1xuICAgICAgICB0aGlzLm1hdGNoZWQgKz0gY2g7XG4gICAgICAgIHZhciBsaW5lcyA9IGNoLm1hdGNoKC8oPzpcXHJcXG4/fFxcbikuKi9nKTtcbiAgICAgICAgaWYgKGxpbmVzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGluZW5vKys7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2xpbmUrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlWzFdKys7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKDEpO1xuICAgICAgICByZXR1cm4gY2g7XG4gICAgfSxcblxuLy8gdW5zaGlmdHMgb25lIGNoYXIgKG9yIGEgc3RyaW5nKSBpbnRvIHRoZSBpbnB1dFxudW5wdXQ6ZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgIHZhciBsZW4gPSBjaC5sZW5ndGg7XG4gICAgICAgIHZhciBsaW5lcyA9IGNoLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG5cbiAgICAgICAgdGhpcy5faW5wdXQgPSBjaCArIHRoaXMuX2lucHV0O1xuICAgICAgICB0aGlzLnl5dGV4dCA9IHRoaXMueXl0ZXh0LnN1YnN0cigwLCB0aGlzLnl5dGV4dC5sZW5ndGggLSBsZW4pO1xuICAgICAgICAvL3RoaXMueXlsZW5nIC09IGxlbjtcbiAgICAgICAgdGhpcy5vZmZzZXQgLT0gbGVuO1xuICAgICAgICB2YXIgb2xkTGluZXMgPSB0aGlzLm1hdGNoLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG4gICAgICAgIHRoaXMubWF0Y2ggPSB0aGlzLm1hdGNoLnN1YnN0cigwLCB0aGlzLm1hdGNoLmxlbmd0aCAtIDEpO1xuICAgICAgICB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSAxKTtcblxuICAgICAgICBpZiAobGluZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdGhpcy55eWxpbmVubyAtPSBsaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciByID0gdGhpcy55eWxsb2MucmFuZ2U7XG5cbiAgICAgICAgdGhpcy55eWxsb2MgPSB7XG4gICAgICAgICAgICBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5maXJzdF9saW5lLFxuICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vICsgMSxcbiAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uLFxuICAgICAgICAgICAgbGFzdF9jb2x1bW46IGxpbmVzID9cbiAgICAgICAgICAgICAgICAobGluZXMubGVuZ3RoID09PSBvbGRMaW5lcy5sZW5ndGggPyB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4gOiAwKVxuICAgICAgICAgICAgICAgICArIG9sZExpbmVzW29sZExpbmVzLmxlbmd0aCAtIGxpbmVzLmxlbmd0aF0ubGVuZ3RoIC0gbGluZXNbMF0ubGVuZ3RoIDpcbiAgICAgICAgICAgICAgdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uIC0gbGVuXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gW3JbMF0sIHJbMF0gKyB0aGlzLnl5bGVuZyAtIGxlbl07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy55eWxlbmcgPSB0aGlzLnl5dGV4dC5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbi8vIFdoZW4gY2FsbGVkIGZyb20gYWN0aW9uLCBjYWNoZXMgbWF0Y2hlZCB0ZXh0IGFuZCBhcHBlbmRzIGl0IG9uIG5leHQgYWN0aW9uXG5tb3JlOmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbW9yZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbi8vIFdoZW4gY2FsbGVkIGZyb20gYWN0aW9uLCBzaWduYWxzIHRoZSBsZXhlciB0aGF0IHRoaXMgcnVsZSBmYWlscyB0byBtYXRjaCB0aGUgaW5wdXQsIHNvIHRoZSBuZXh0IG1hdGNoaW5nIHJ1bGUgKHJlZ2V4KSBzaG91bGQgYmUgdGVzdGVkIGluc3RlYWQuXG5yZWplY3Q6ZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAgICAgdGhpcy5fYmFja3RyYWNrID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IoJ0xleGljYWwgZXJyb3Igb24gbGluZSAnICsgKHRoaXMueXlsaW5lbm8gKyAxKSArICcuIFlvdSBjYW4gb25seSBpbnZva2UgcmVqZWN0KCkgaW4gdGhlIGxleGVyIHdoZW4gdGhlIGxleGVyIGlzIG9mIHRoZSBiYWNrdHJhY2tpbmcgcGVyc3Vhc2lvbiAob3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIgPSB0cnVlKS5cXG4nICsgdGhpcy5zaG93UG9zaXRpb24oKSwge1xuICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgdG9rZW46IG51bGwsXG4gICAgICAgICAgICAgICAgbGluZTogdGhpcy55eWxpbmVub1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4vLyByZXRhaW4gZmlyc3QgbiBjaGFyYWN0ZXJzIG9mIHRoZSBtYXRjaFxubGVzczpmdW5jdGlvbiAobikge1xuICAgICAgICB0aGlzLnVucHV0KHRoaXMubWF0Y2guc2xpY2UobikpO1xuICAgIH0sXG5cbi8vIGRpc3BsYXlzIGFscmVhZHkgbWF0Y2hlZCBpbnB1dCwgaS5lLiBmb3IgZXJyb3IgbWVzc2FnZXNcbnBhc3RJbnB1dDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXN0ID0gdGhpcy5tYXRjaGVkLnN1YnN0cigwLCB0aGlzLm1hdGNoZWQubGVuZ3RoIC0gdGhpcy5tYXRjaC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gKHBhc3QubGVuZ3RoID4gMjAgPyAnLi4uJzonJykgKyBwYXN0LnN1YnN0cigtMjApLnJlcGxhY2UoL1xcbi9nLCBcIlwiKTtcbiAgICB9LFxuXG4vLyBkaXNwbGF5cyB1cGNvbWluZyBpbnB1dCwgaS5lLiBmb3IgZXJyb3IgbWVzc2FnZXNcbnVwY29taW5nSW5wdXQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dCA9IHRoaXMubWF0Y2g7XG4gICAgICAgIGlmIChuZXh0Lmxlbmd0aCA8IDIwKSB7XG4gICAgICAgICAgICBuZXh0ICs9IHRoaXMuX2lucHV0LnN1YnN0cigwLCAyMC1uZXh0Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChuZXh0LnN1YnN0cigwLDIwKSArIChuZXh0Lmxlbmd0aCA+IDIwID8gJy4uLicgOiAnJykpLnJlcGxhY2UoL1xcbi9nLCBcIlwiKTtcbiAgICB9LFxuXG4vLyBkaXNwbGF5cyB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uIHdoZXJlIHRoZSBsZXhpbmcgZXJyb3Igb2NjdXJyZWQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzXG5zaG93UG9zaXRpb246ZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJlID0gdGhpcy5wYXN0SW5wdXQoKTtcbiAgICAgICAgdmFyIGMgPSBuZXcgQXJyYXkocHJlLmxlbmd0aCArIDEpLmpvaW4oXCItXCIpO1xuICAgICAgICByZXR1cm4gcHJlICsgdGhpcy51cGNvbWluZ0lucHV0KCkgKyBcIlxcblwiICsgYyArIFwiXlwiO1xuICAgIH0sXG5cbi8vIHRlc3QgdGhlIGxleGVkIHRva2VuOiByZXR1cm4gRkFMU0Ugd2hlbiBub3QgYSBtYXRjaCwgb3RoZXJ3aXNlIHJldHVybiB0b2tlblxudGVzdF9tYXRjaDpmdW5jdGlvbiAobWF0Y2gsIGluZGV4ZWRfcnVsZSkge1xuICAgICAgICB2YXIgdG9rZW4sXG4gICAgICAgICAgICBsaW5lcyxcbiAgICAgICAgICAgIGJhY2t1cDtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAgICAgLy8gc2F2ZSBjb250ZXh0XG4gICAgICAgICAgICBiYWNrdXAgPSB7XG4gICAgICAgICAgICAgICAgeXlsaW5lbm86IHRoaXMueXlsaW5lbm8sXG4gICAgICAgICAgICAgICAgeXlsbG9jOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy5sYXN0X2xpbmUsXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBsYXN0X2NvbHVtbjogdGhpcy55eWxsb2MubGFzdF9jb2x1bW5cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHl5dGV4dDogdGhpcy55eXRleHQsXG4gICAgICAgICAgICAgICAgbWF0Y2g6IHRoaXMubWF0Y2gsXG4gICAgICAgICAgICAgICAgbWF0Y2hlczogdGhpcy5tYXRjaGVzLFxuICAgICAgICAgICAgICAgIG1hdGNoZWQ6IHRoaXMubWF0Y2hlZCxcbiAgICAgICAgICAgICAgICB5eWxlbmc6IHRoaXMueXlsZW5nLFxuICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgX21vcmU6IHRoaXMuX21vcmUsXG4gICAgICAgICAgICAgICAgX2lucHV0OiB0aGlzLl9pbnB1dCxcbiAgICAgICAgICAgICAgICB5eTogdGhpcy55eSxcbiAgICAgICAgICAgICAgICBjb25kaXRpb25TdGFjazogdGhpcy5jb25kaXRpb25TdGFjay5zbGljZSgwKSxcbiAgICAgICAgICAgICAgICBkb25lOiB0aGlzLmRvbmVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgICAgIGJhY2t1cC55eWxsb2MucmFuZ2UgPSB0aGlzLnl5bGxvYy5yYW5nZS5zbGljZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmVzID0gbWF0Y2hbMF0ubWF0Y2goLyg/Olxcclxcbj98XFxuKS4qL2cpO1xuICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsaW5lbm8gKz0gbGluZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueXlsbG9jID0ge1xuICAgICAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxsb2MubGFzdF9saW5lLFxuICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vICsgMSxcbiAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MubGFzdF9jb2x1bW4sXG4gICAgICAgICAgICBsYXN0X2NvbHVtbjogbGluZXMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aCAtIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLm1hdGNoKC9cXHI/XFxuPy8pWzBdLmxlbmd0aCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gKyBtYXRjaFswXS5sZW5ndGhcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy55eXRleHQgKz0gbWF0Y2hbMF07XG4gICAgICAgIHRoaXMubWF0Y2ggKz0gbWF0Y2hbMF07XG4gICAgICAgIHRoaXMubWF0Y2hlcyA9IG1hdGNoO1xuICAgICAgICB0aGlzLnl5bGVuZyA9IHRoaXMueXl0ZXh0Lmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gW3RoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArPSB0aGlzLnl5bGVuZ107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbW9yZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9iYWNrdHJhY2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZShtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICB0aGlzLm1hdGNoZWQgKz0gbWF0Y2hbMF07XG4gICAgICAgIHRva2VuID0gdGhpcy5wZXJmb3JtQWN0aW9uLmNhbGwodGhpcywgdGhpcy55eSwgdGhpcywgaW5kZXhlZF9ydWxlLCB0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV0pO1xuICAgICAgICBpZiAodGhpcy5kb25lICYmIHRoaXMuX2lucHV0KSB7XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9iYWNrdHJhY2spIHtcbiAgICAgICAgICAgIC8vIHJlY292ZXIgY29udGV4dFxuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBiYWNrdXApIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tdID0gYmFja3VwW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBydWxlIGFjdGlvbiBjYWxsZWQgcmVqZWN0KCkgaW1wbHlpbmcgdGhlIG5leHQgcnVsZSBzaG91bGQgYmUgdGVzdGVkIGluc3RlYWQuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbi8vIHJldHVybiBuZXh0IG1hdGNoIGluIGlucHV0XG5uZXh0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRU9GO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG9rZW4sXG4gICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgIHRlbXBNYXRjaCxcbiAgICAgICAgICAgIGluZGV4O1xuICAgICAgICBpZiAoIXRoaXMuX21vcmUpIHtcbiAgICAgICAgICAgIHRoaXMueXl0ZXh0ID0gJyc7XG4gICAgICAgICAgICB0aGlzLm1hdGNoID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5fY3VycmVudFJ1bGVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRlbXBNYXRjaCA9IHRoaXMuX2lucHV0Lm1hdGNoKHRoaXMucnVsZXNbcnVsZXNbaV1dKTtcbiAgICAgICAgICAgIGlmICh0ZW1wTWF0Y2ggJiYgKCFtYXRjaCB8fCB0ZW1wTWF0Y2hbMF0ubGVuZ3RoID4gbWF0Y2hbMF0ubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gdGVtcE1hdGNoO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudGVzdF9tYXRjaCh0ZW1wTWF0Y2gsIHJ1bGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JhY2t0cmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBydWxlIGFjdGlvbiBjYWxsZWQgcmVqZWN0KCkgaW1wbHlpbmcgYSBydWxlIE1JU21hdGNoLlxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZTogdGhpcyBpcyBhIGxleGVyIHJ1bGUgd2hpY2ggY29uc3VtZXMgaW5wdXQgd2l0aG91dCBwcm9kdWNpbmcgYSB0b2tlbiAoZS5nLiB3aGl0ZXNwYWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLmZsZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRlc3RfbWF0Y2gobWF0Y2gsIHJ1bGVzW2luZGV4XSk7XG4gICAgICAgICAgICBpZiAodG9rZW4gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxzZTogdGhpcyBpcyBhIGxleGVyIHJ1bGUgd2hpY2ggY29uc3VtZXMgaW5wdXQgd2l0aG91dCBwcm9kdWNpbmcgYSB0b2tlbiAoZS5nLiB3aGl0ZXNwYWNlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dCA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRU9GO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcignTGV4aWNhbCBlcnJvciBvbiBsaW5lICcgKyAodGhpcy55eWxpbmVubyArIDEpICsgJy4gVW5yZWNvZ25pemVkIHRleHQuXFxuJyArIHRoaXMuc2hvd1Bvc2l0aW9uKCksIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgIHRva2VuOiBudWxsLFxuICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMueXlsaW5lbm9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gcmV0dXJuIG5leHQgbWF0Y2ggdGhhdCBoYXMgYSB0b2tlblxubGV4OmZ1bmN0aW9uIGxleCgpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGV4KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyBhY3RpdmF0ZXMgYSBuZXcgbGV4ZXIgY29uZGl0aW9uIHN0YXRlIChwdXNoZXMgdGhlIG5ldyBsZXhlciBjb25kaXRpb24gc3RhdGUgb250byB0aGUgY29uZGl0aW9uIHN0YWNrKVxuYmVnaW46ZnVuY3Rpb24gYmVnaW4oY29uZGl0aW9uKSB7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sucHVzaChjb25kaXRpb24pO1xuICAgIH0sXG5cbi8vIHBvcCB0aGUgcHJldmlvdXNseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlIG9mZiB0aGUgY29uZGl0aW9uIHN0YWNrXG5wb3BTdGF0ZTpmdW5jdGlvbiBwb3BTdGF0ZSgpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2sucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFja1swXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIHByb2R1Y2UgdGhlIGxleGVyIHJ1bGUgc2V0IHdoaWNoIGlzIGFjdGl2ZSBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlXG5fY3VycmVudFJ1bGVzOmZ1bmN0aW9uIF9jdXJyZW50UnVsZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAmJiB0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbnNbdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdXS5ydWxlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbnNbXCJJTklUSUFMXCJdLnJ1bGVzO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gcmV0dXJuIHRoZSBjdXJyZW50bHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZTsgd2hlbiBhbiBpbmRleCBhcmd1bWVudCBpcyBwcm92aWRlZCBpdCBwcm9kdWNlcyB0aGUgTi10aCBwcmV2aW91cyBjb25kaXRpb24gc3RhdGUsIGlmIGF2YWlsYWJsZVxudG9wU3RhdGU6ZnVuY3Rpb24gdG9wU3RhdGUobikge1xuICAgICAgICBuID0gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxIC0gTWF0aC5hYnMobiB8fCAwKTtcbiAgICAgICAgaWYgKG4gPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2tbbl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJJTklUSUFMXCI7XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyBhbGlhcyBmb3IgYmVnaW4oY29uZGl0aW9uKVxucHVzaFN0YXRlOmZ1bmN0aW9uIHB1c2hTdGF0ZShjb25kaXRpb24pIHtcbiAgICAgICAgdGhpcy5iZWdpbihjb25kaXRpb24pO1xuICAgIH0sXG5cbi8vIHJldHVybiB0aGUgbnVtYmVyIG9mIHN0YXRlcyBjdXJyZW50bHkgb24gdGhlIHN0YWNrXG5zdGF0ZVN0YWNrU2l6ZTpmdW5jdGlvbiBzdGF0ZVN0YWNrU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoO1xuICAgIH0sXG5vcHRpb25zOiB7fSxcbnBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIGFub255bW91cyh5eSx5eV8sJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucyxZWV9TVEFSVCkge1xudmFyIFlZU1RBVEU9WVlfU1RBUlQ7XG5zd2l0Y2goJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucykge1xuY2FzZSAwOnJldHVybiA5XG5icmVhaztcbmNhc2UgMTpyZXR1cm4gOVxuYnJlYWs7XG5jYXNlIDI6cmV0dXJuIDlcbmJyZWFrO1xuY2FzZSAzOiB0aGlzLmJlZ2luKCd0aXRsZScpIFxuYnJlYWs7XG5jYXNlIDQ6IHl5Xy55eXRleHQgPSB5eV8ueXl0ZXh0LnN1YnN0cigwLCB5eV8ueXlsZW5nIC0gMikudHJpbSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxNCBcbmJyZWFrO1xuY2FzZSA1OiB0aGlzLmJlZ2luKCdJTklUSUFMJykgXG5icmVhaztcbmNhc2UgNjogdGhpcy5iZWdpbignSU5JVElBTCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHl5Xy55eXRleHQgPSB5eV8ueXl0ZXh0LnRyaW0oKVxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTUgXG5icmVhaztcbmNhc2UgNzogdGhpcy5iZWdpbigndGltZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHl5Xy55eXRleHQgPSB5eV8ueXl0ZXh0LnN1YnN0cigwLCB5eV8ueXlsZW5nIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDU4IFxuYnJlYWs7XG5jYXNlIDg6IHRoaXMuYmVnaW4oJ0lOSVRJQUwnKTsgcmV0dXJuIDU5IFxuYnJlYWs7XG5jYXNlIDk6cmV0dXJuIDQxXG5icmVhaztcbmNhc2UgMTA6cmV0dXJuIDM5XG5icmVhaztcbmNhc2UgMTE6cmV0dXJuIDQwXG5icmVhaztcbmNhc2UgMTI6cmV0dXJuIDQzXG5icmVhaztcbmNhc2UgMTM6cmV0dXJuIDQ3XG5icmVhaztcbmNhc2UgMTQ6cmV0dXJuIDQ2XG5icmVhaztcbmNhc2UgMTU6cmV0dXJuIDI4XG5icmVhaztcbmNhc2UgMTY6cmV0dXJuIDQ0XG5icmVhaztcbmNhc2UgMTc6cmV0dXJuIDQ1XG5icmVhaztcbmNhc2UgMTg6cmV0dXJuICcuJ1xuYnJlYWs7XG5jYXNlIDE5OnJldHVybiAyOVxuYnJlYWs7XG5jYXNlIDIwOnJldHVybiA0OFxuYnJlYWs7XG5jYXNlIDIxOnJldHVybiA1MFxuYnJlYWs7XG5jYXNlIDIyOnJldHVybiAzNFxuYnJlYWs7XG5jYXNlIDIzOnJldHVybiAzNVxuYnJlYWs7XG5jYXNlIDI0OnJldHVybiAnLydcbmJyZWFrO1xuY2FzZSAyNTpyZXR1cm4gJ1xcXFwnXG5icmVhaztcbmNhc2UgMjY6cmV0dXJuIDIzXG5icmVhaztcbmNhc2UgMjc6cmV0dXJuIDIyXG5icmVhaztcbmNhc2UgMjg6cmV0dXJuICdbfCdcbmJyZWFrO1xuY2FzZSAyOTpyZXR1cm4gMjRcbmJyZWFrO1xuY2FzZSAzMDpyZXR1cm4gMjZcbmJyZWFrO1xuY2FzZSAzMTpyZXR1cm4gMjVcbmJyZWFrO1xuY2FzZSAzMjpyZXR1cm4gMjFcbmJyZWFrO1xuY2FzZSAzMzpyZXR1cm4gNTFcbmJyZWFrO1xuY2FzZSAzNDpyZXR1cm4gNTNcbmJyZWFrO1xuY2FzZSAzNTpyZXR1cm4gNTVcbmJyZWFrO1xuY2FzZSAzNjpyZXR1cm4gMTBcbmJyZWFrO1xuY2FzZSAzNzpyZXR1cm4gOVxuYnJlYWs7XG5jYXNlIDM4OnJldHVybiA1XG5icmVhaztcbmNhc2UgMzk6cmV0dXJuICdJTlZBTElEJ1xuYnJlYWs7XG59XG59LFxucnVsZXM6IFsvXig/OlxcL1xcL1teXFxuXSopLywvXig/OlxcL1xcKihbXFxzXFxTXSo/KVxcKlxcLykvLC9eKD86XFwvXFwqW1xcc1xcU10qKS8sL14oPzo8PCkvLC9eKD86Lio+PikvLC9eKD86KFsgXFx0XSkqKFtcXG5cXHJdKSkvLC9eKD86LiopLywvXig/OigoWzEtOV1cXGR7MCwyfSlcXC8pKS8sL14oPzooWzEtOV1cXGR7MCwyfSlbXlxcZF0pLywvXig/OigjezEsMn18bnxiezEsMn0pKS8sL14oPzpbMS03XSkvLC9eKD86LCt8JyspLywvXig/OlxcLispLywvXig/OiggKi0gKil7M30pLywvXig/OiggKi0gKikpLywvXig/OiAqfikvLC9eKD86W19dKS8sL14oPzo9KS8sL14oPzpcXC4pLywvXig/OlswXSkvLC9eKD86PCkvLC9eKD86PikvLC9eKD86XFwoKS8sL14oPzpcXCkpLywvXig/OlxcLykvLC9eKD86XFxcXCkvLC9eKD86XFx8XFxdKS8sL14oPzpcXHxcXHwpLywvXig/OlxcW1xcfCkvLC9eKD86XFx8OikvLC9eKD86OlxcfDopLywvXig/OjpcXHwpLywvXig/OlxcfCkvLC9eKD86XFx7KS8sL14oPzpcXH0pLywvXig/OjopLywvXig/OihbXFxuXFxyXSkpLywvXig/OihbIFxcdF0pKS8sL14oPzokKS8sL14oPzouKS9dLFxuY29uZGl0aW9uczoge1widGltZVwiOntcInJ1bGVzXCI6WzhdLFwiaW5jbHVzaXZlXCI6ZmFsc2V9LFwidGl0bGVcIjp7XCJydWxlc1wiOls0LDUsNl0sXCJpbmNsdXNpdmVcIjpmYWxzZX0sXCJJTklUSUFMXCI6e1wicnVsZXNcIjpbMCwxLDIsMyw3LDksMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsMjksMzAsMzEsMzIsMzMsMzQsMzUsMzYsMzcsMzgsMzldLFwiaW5jbHVzaXZlXCI6dHJ1ZX19XG59KTtcbnJldHVybiBsZXhlcjtcbn0pKCk7XG5wYXJzZXIubGV4ZXIgPSBsZXhlcjtcbmZ1bmN0aW9uIFBhcnNlciAoKSB7XG4gIHRoaXMueXkgPSB7fTtcbn1cblBhcnNlci5wcm90b3R5cGUgPSBwYXJzZXI7cGFyc2VyLlBhcnNlciA9IFBhcnNlcjtcbnJldHVybiBuZXcgUGFyc2VyO1xufSkoKTtcbm1vZHVsZS5leHBvcnRzID0gcGFyc2VyXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvcGFyc2VyL3BhcnNlci5qaXNvblxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJjb25zdCBJU19PQkpFQ1QgPSB7ICdmdW50aW9uJzogdHJ1ZSwgJ29iamVjdCc6IHRydWUgfVxuY29uc3QgaXNPYmplY3QgPSBvYmogPT4gSVNfT0JKRUNUW3R5cGVvZiBvYmpdICYmICEhb2JqXG5cbmV4cG9ydCBjb25zdCBvYmpFYWNoID0gKG9iaiwgY2FsbGJhY2spID0+IHtcbiAgaWYgKGlzT2JqZWN0KG9iaikpIHtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goa2V5ID0+IHsgY2FsbGJhY2sob2JqW2tleV0sIGtleSkgfSlcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZXh0ZW5kID0gKG9iaiwgZXh0KSA9PiB7XG4gIG9iakVhY2goZXh0LCAodmFsLCBrZXkpID0+IHsgb2JqW2tleV0gPSB2YWwgfSlcbiAgcmV0dXJuIG9ialxufVxuXG5leHBvcnQgY29uc3QgbmVhciA9IChhLCBiKSA9PiBNYXRoLmFicyhhIC0gYikgPCAwLjAwMDAxXG5cbmNvbnN0IGlzQWNjZXNzb3JQcm9wZXJ0eSA9IHZhbHVlID0+IGlzT2JqZWN0KHZhbHVlKSAmJlxuICAgICAgICAodHlwZW9mIHZhbHVlLmdldCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgdmFsdWUuc2V0ID09PSAnZnVuY3Rpb24nKVxuXG4vKipcbiAqIERlZmluZSBFUzUgZ2V0dGVyL3NldHRlciBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gVGhlIG9iamVjdCB0byBiZSBkZWZpbmVkLlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gRVM1IGdldHRlci9zZXR0ZXIgcHJvcGVydGllcy5cbiAqIEZvciBleGFtcGxlOlxuICogYGBgXG4gKiB7XG4gKiAgIG5hbWU6IHtcbiAqICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsuLi59LFxuICogICAgIHNldDogZnVuY3Rpb24gKCkgey4uLn1cbiAqICAgfSxcbiAqICAgYWdlOiB7XG4gKiAgICAgIGdldDouLi5cbiAqICAgfVxuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBkZWZpbmVQcm9wZXJ0aWVzID0gKG9iaiwgcHJvcHMpID0+IHtcbiAgb2JqRWFjaChwcm9wcywgKHZhbHVlLCBwcm9wKSA9PiB7XG4gICAgdmFyIGRlc2NyaXB0b3JcbiAgICBpZiAoaXNBY2Nlc3NvclByb3BlcnR5KHZhbHVlKSkge1xuICAgICAgZGVzY3JpcHRvciA9IHZhbHVlXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSB7IHZhbHVlOiB2YWx1ZSB9XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkgJiYgdmFsdWUuY29uc3RhbnQpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSB7IHZhbHVlOiB2YWx1ZS5jb25zdGFudCB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwgZGVzY3JpcHRvcilcbiAgfSlcbn1cblxubGV0IHRvSlNPTldpdGhEZWZhdWx0ID0gdHJ1ZVxuXG5leHBvcnQgY29uc3QgbWFrZVRvSlNPTiA9ICh2YWx1ZXMsIGVsTmFtZSkgPT4gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5pc0VtcHR5KSByZXR1cm5cblxuICBjb25zdCByZXN1bHQgPSB7fVxuXG4gIG9iakVhY2godmFsdWVzLCAoZGVmYXVsdFZhbHVlLCBwcm9wKSA9PiB7XG4gICAgaWYgKHRvSlNPTldpdGhEZWZhdWx0IHx8IHRoaXNbcHJvcF0gIT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcmVzdWx0W3Byb3BdID0gdGhpc1twcm9wXVxuICAgIH1cbiAgfSlcbiAgaWYgKCFlbE5hbWUpIHJldHVybiByZXN1bHRcblxuICBjb25zdCByZXMgPSB7fVxuICByZXNbZWxOYW1lXSA9IHJlc3VsdFxuICByZXR1cm4gcmVzXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbC5qcyIsImltcG9ydCB7IG1ha2VUb0pTT04sIGV4dGVuZCB9IGZyb20gJy4uL3V0aWwnXG5pbXBvcnQgU2NvcmVIZWFkIGZyb20gJy4vU2NvcmVIZWFkJ1xuaW1wb3J0IFBhcnR3aXNlUGFydHMgZnJvbSAnLi9QYXJ0d2lzZVBhcnRzJ1xuaW1wb3J0IFRpbWV3aXNlTWVhc3VyZXMgZnJvbSAnLi9UaW1ld2lzZU1lYXN1cmVzJ1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29yZSAtIHBsYWluIHNjb3JlIG9iamVjdC5cbiAqIEBtaXhlcyBQbGF5ZXJNaXhpblxuICovXG5jbGFzcyBTY29yZSB7XG4gIGNvbnN0cnVjdG9yKHNjb3JlKSB7XG4gICAgZXh0ZW5kKHRoaXMsIHNjb3JlKVxuICB9XG5cbiAgLyoqXG4gICAqIEhlYWQgb2YgdGhlIHNjb3JlLlxuICAgKiBAdHlwZSB7U2NvcmVIZWFkfVxuICAgKi9cbiAgZ2V0IGhlYWQoKSB7IHJldHVybiB0aGlzLl9oZWFkIHx8ICh0aGlzLl9oZWFkID0gbmV3IFNjb3JlSGVhZCgpKSB9XG4gIHNldCBoZWFkKGhlYWQpIHsgdGhpcy5faGVhZCA9IG5ldyBTY29yZUhlYWQoaGVhZCkgfVxuXG4gIC8qKlxuICAgKiBQYXJ0d2lzZSBwYXJ0cy5cbiAgICogLSAoR2V0dGVyKVxuICAgKiAtIChTZXR0ZXIpXG4gICAqIEB0eXBlIHtQYXJ0d2lzZVBhcnRzfVxuICAgKi9cbiAgZ2V0IHBhcnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJ0cyB8fCAodGhpcy5fcGFydHMgPSBuZXcgUGFydHdpc2VQYXJ0cyh0aGlzKSlcbiAgfVxuICBzZXQgcGFydHMocGFydHMpIHtcbiAgICB0aGlzLnBhcnRzLnJlbW92ZUFsbCgpXG4gICAgdGhpcy5wYXJ0cy5hZGRQYXJ0cyhwYXJ0cylcbiAgICB0aGlzLm1lYXN1cmVzLmZyb21QYXJ0d2lzZSgpXG4gIH1cblxuICAvKipcbiAgICogVGltZXdpc2UgbWVhc3VyZXMsIGdlbmVyYXRlZCBieSB0aGUgaW5pdGlhbGl6ZSBmdW5jdGlvbi5cbiAgICogQHR5cGUge1RpbWV3aXNlTWVhc3VyZXN9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG1lYXN1cmVzKCkge1xuICAgIHJldHVybiB0aGlzLl9tZWFzdXJlcyB8fCAodGhpcy5fbWVhc3VyZXMgPSBuZXcgVGltZXdpc2VNZWFzdXJlcyh0aGlzKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGNlbGwgaXMgaWRlbnRpY2FsbHkgYSBtZWFzdXJlIGluIGEgcGFydCBvciBhIHBhcnQgaW4gYSBtZWFzdXJlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICAgKi9cbiAgd2Fsa0NlbGxzKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5wYXJ0cy5mb3JFYWNoKChwYXJ0LCBwKSA9PiB7XG4gICAgICBwYXJ0Lm1lYXN1cmVzLmZvckVhY2goKGNlbGwsIG0pID0+IHsgY2FsbGJhY2soY2VsbCwgbSwgcCkgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFdhbGsgZWFjaCBtdXNpYyBkYXRhLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgd2Fsa011c2ljRGF0YShjYWxsYmFjaykge1xuICAgIHRoaXMud2Fsa0NlbGxzKChjZWxsLCBtLCBwKSA9PiB7XG4gICAgICBjZWxsLmRhdGEuZm9yRWFjaCgoZGF0YSwgZCkgPT4geyBjYWxsYmFjayhkYXRhLCBkLCBtLCBwKSB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBzY29yZSB0byBzdHJpbmcuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTXVzamUgc291cmNlIGNvZGUuXG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5oZWFkICsgdGhpcy5wYXJ0cy5tYXAoKHBhcnQpID0+IHBhcnQudG9TdHJpbmcoKSkuam9pbignXFxuXFxuJylcbiAgfVxuXG4gIC8qKlxuICAgKiBDdXN0b20gdG9KU09OIG1ldGhvZC5cbiAgICogQG1ldGhvZFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICB0b0pTT04gPSBtYWtlVG9KU09OKHtcbiAgICBoZWFkOiB1bmRlZmluZWQsXG4gICAgcGFydHM6IHVuZGVmaW5lZFxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBTY29yZVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21vZGVsL1Njb3JlLmpzIiwiaW1wb3J0IHsgbWFrZVRvSlNPTiwgZXh0ZW5kIH0gZnJvbSAnLi4vdXRpbCdcblxuLyoqXG4gKiBDb25zdHJ1Y3QgaGVhZCBvZiB0aGUgc2NvcmUuXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkXG4gKi9cbmNsYXNzIFNjb3JlSGVhZCB7XG4gIGNvbnN0cnVjdG9yKGhlYWQpIHtcbiAgICBleHRlbmQodGhpcywgaGVhZClcbiAgfVxuXG4gIC8qKlxuICAgKiBUaXRsZSBvZiB0aGUgc2NvcmUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICcnXG4gICAqL1xuICB0aXRsZSA9ICcnXG5cbiAgLyoqXG4gICAqIFN1YnRpdGxlIG9mIHRoZSBzY29yZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJydcbiAgICovXG4gIHN1YnRpdGxlID0gJydcblxuICAvKipcbiAgICogU3Vic3VidGl0bGUgb2YgdGhlIHNjb3JlLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnJ1xuICAgKi9cbiAgc3Vic3VidGl0bGUgPSAnJ1xuXG4gIC8qKlxuICAgKiBDb21wb3NlciBvZiB0aGUgc2NvcmUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBjb21wb3NlciA9IHVuZGVmaW5lZFxuXG4gIC8qKlxuICAgKiBBcnJhbmdlciBvZiB0aGUgc2NvcmUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBhcnJhbmdlciA9IHVuZGVmaW5lZFxuXG4gIC8qKlxuICAgKiBMeXJpY2lzdCBvZiB0aGUgc2NvcmUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBseXJpY2lzdCA9IHVuZGVmaW5lZFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgc2NvcmUgaGVhZCBpcyBlbXB0eS5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuICF0aGlzLnRpdGxlICYmICF0aGlzLnN1YnRpdGxlICYmICF0aGlzLnN1YnN1YnRpdGxlICYmXG4gICAgICAgICAgICF0aGlzLmNvbXBvc2VyICYmICF0aGlzLmFycmFuZ2VyICYmICF0aGlzLmx5cmljaXN0XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBzY29yZSBoZWFkIHRvIHN0cmluZy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgY29udmVydGVkIG11c2plIGhlYWQgc291cmNlIGNvZGUuXG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCB0aXRsZSA9IHRoaXMudGl0bGUgPyBgPDwke3RoaXMudGl0bGV9Pj5gIDogJydcbiAgICByZXR1cm4gYCR7dGl0bGV9ICR7dGhpcy5jb21wb3NlciB8fCAnJ31cXG5gXG4gIH1cblxuICB0b0pTT04gPSBtYWtlVG9KU09OKHtcbiAgICB0aXRsZTogdW5kZWZpbmVkLFxuICAgIHN1YnRpdGxlOiB1bmRlZmluZWQsXG4gICAgc3Vic3VidGl0bGU6IHVuZGVmaW5lZCxcbiAgICBjb21wb3NlcjogdW5kZWZpbmVkLFxuICAgIGx5cmljaXN0OiB1bmRlZmluZWRcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgU2NvcmVIZWFkXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbW9kZWwvU2NvcmVIZWFkLmpzIiwiaW1wb3J0IFBhcnR3aXNlUGFydCBmcm9tICcuL1BhcnR3aXNlUGFydCdcblxuY2xhc3MgUGFydHdpc2VQYXJ0cyBleHRlbmRzIEFycmF5IHtcbiAgY29uc3RydWN0b3Ioc2NvcmUpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fc2NvcmUgPSBzY29yZVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byB0aGUgcGFyZW50IHNjb3JlLlxuICAgKiBAdHlwZSB7U2NvcmV9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHNjb3JlKCkgeyByZXR1cm4gdGhpcy5fc2NvcmUgfVxuXG4gIC8qKlxuICAgKiBBZGQgcGFydHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fVxuICAgKi9cbiAgYWRkUGFydHMocGFydHMpIHsgcGFydHMuZm9yRWFjaChwYXJ0ID0+IHsgdGhpcy5hcHBlbmQocGFydCkgfSkgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmQgYSBwYXJ0d2lzZSBwYXJ0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFydCAtIFBsYWluIHBhcnR3aXNlIHBhcnQgb2JqZWN0LlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGFwcGVuZChwYXJ0KSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmxlbmd0aFxuICAgIGNvbnN0IG11c2plUGFydCA9IG5ldyBQYXJ0d2lzZVBhcnQoaW5kZXgsIHRoaXMpXG4gICAgdGhpcy5wdXNoKG11c2plUGFydClcbiAgICBtdXNqZVBhcnQubWVhc3VyZXMgPSBwYXJ0Lm1lYXN1cmVzXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBwYXJ0cy5cbiAgICovXG4gIHJlbW92ZUFsbCgpIHsgdGhpcy5sZW5ndGggPSAwIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFydHdpc2VQYXJ0c1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21vZGVsL1BhcnR3aXNlUGFydHMuanMiLCJpbXBvcnQgeyBtYWtlVG9KU09OIH0gZnJvbSAnLi4vdXRpbCdcbmltcG9ydCBDZWxsIGZyb20gJy4vQ2VsbCdcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSBwYXJ0IHtPYmplY3R9XG4gKiBAcGFyYW0gaW5kZXgge251bWJlcn0gLSBJbmRleCBvZiB0aGlzIHBhcnQgaW4gdGhlIHBhcnRzLlxuICogQHBhcmFtIHBhcnRzIHtQYXJ0d2lzZVBhcnRzfVxuICovXG5jbGFzcyBQYXJ0d2lzZVBhcnQge1xuICBjb25zdHJ1Y3RvcihpbmRleCwgcGFydHMpIHtcbiAgICB0aGlzLl9pbmRleCA9IGluZGV4XG4gICAgdGhpcy5fcGFydHMgPSBwYXJ0c1xuICB9XG5cbiAgLy8gaGVhZDogeyAkcmVmOiAnIy9vYmplY3RzL1BhcnRIZWFkJyB9LFxuXG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBwYXJ0cyBpbnN0YW5jZS5cbiAgICogQHR5cGUge1BhcnR3aXNlUGFydHN9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHBhcnRzKCkgeyByZXR1cm4gdGhpcy5fcGFydHMgfVxuXG4gIC8qKlxuICAgKiBNZWFzdXJlIGluIGEgcGFydHdpc2UgcGFydCBpcyBjZWxscy5cbiAgICogQHR5cGUge0FycmF5LjxDZWxsPn1cbiAgICovXG4gIGdldCBtZWFzdXJlcygpIHsgcmV0dXJuIHRoaXMuX21lYXN1cmVzIHx8ICh0aGlzLl9tZWFzdXJlcyA9IFtdKSB9XG4gIHNldCBtZWFzdXJlcyhtZWFzdXJlcykge1xuICAgIGNvbnN0IHAgPSB0aGlzLl9pbmRleFxuICAgIGNvbnN0IHsgc2NvcmUgfSA9IHRoaXMucGFydHNcbiAgICBjb25zdCBtZWEgPSB0aGlzLl9tZWFzdXJlcyA9IFtdXG4gICAgbWVhc3VyZXMuZm9yRWFjaCgoY2VsbCwgbSkgPT4geyBtZWEucHVzaChuZXcgQ2VsbChjZWxsLCBtLCBwLCBzY29yZSkpIH0pXG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIHBhcnR3aXNlIHBhcnQgdG8gc3RpbmcuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTXVzamUgcGFydHdpc2UgcGFydCBzb3VyY2UgY29kZS5cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1lYXN1cmVzLm1hcChjZWxsID0+IGNlbGwpLmpvaW4oJyAnKVxuICB9XG5cbiAgLyoqXG4gICAqIEN1c3RvbSB0b0pTT04gbWV0aG9kLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICB0b0pTT04gPSBtYWtlVG9KU09OKHtcbiAgICBtZWFzdXJlczogdW5kZWZpbmVkXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhcnR3aXNlUGFydFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21vZGVsL1BhcnR3aXNlUGFydC5qcyIsImltcG9ydCB7IG1hdHJpeCB9IGZyb20gJ3NuYXBzdmcnXG5cbmltcG9ydCB0aW1lIGZyb20gJy4vVGltZSdcbmltcG9ydCBiYXIgIGZyb20gJy4vQmFyJ1xuaW1wb3J0IG5vdGUgZnJvbSAnLi9Ob3RlJ1xuaW1wb3J0IHJlc3QgZnJvbSAnLi9SZXN0J1xuaW1wb3J0IGNob3JkIGZyb20gJy4vQ2hvcmQnXG5pbXBvcnQgdm9pY2UgZnJvbSAnLi9Wb2ljZSdcbmltcG9ydCBCZWFtIGZyb20gJy4vQmVhbSdcblxuaW1wb3J0IHsgZXh0ZW5kLCBuZWFyLCBtYWtlVG9KU09OIH0gZnJvbSAnLi4vdXRpbCdcbmNvbnN0IENsYXNzZXMgPSB7IHRpbWUsIGJhciwgbm90ZSwgcmVzdCwgY2hvcmQsIHZvaWNlIH1cbmNvbnN0IEJhciA9IGJhclxuXG4vKipcbiAqIENlbGwgaXMgZWl0aGVyIGEgbWVhc3VyZSBpbiBhIHBhcnR3aXNlIHBhcnQsIG9yXG4gKiBhIHBhcnQgaW4gYSB0aW1ld2lzZSBtZWFzdXJlLlxuICogQHBhcmFtIGNlbGwge09iamVjdH1cbiAqIEBwYXJhbSBtSW5kZXgge251bWJlcn0gLSBNZWFzdXJlIGluZGV4IG9mIHRoaXMgY2VsbC5cbiAqIEBwYXJhbSBwSW5kZXgge251bWJlcn0gLSBQYXJ0IGluZGV4IG9mIHRoaXMgY2VsbC5cbiAqL1xuY2xhc3MgQ2VsbCB7XG4gIGNvbnN0cnVjdG9yKGNlbGwsIG1JbmRleCwgcEluZGV4LCBzY29yZSkge1xuICAgIHRoaXMuX21JbmRleCA9IG1JbmRleFxuICAgIHRoaXMuX3BJbmRleCA9IHBJbmRleFxuICAgIHRoaXMuX3Njb3JlID0gc2NvcmVcbiAgICBleHRlbmQodGhpcywgY2VsbClcbiAgICBtYWtlQmVhbXModGhpcywgMSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIHJvb3Qgc2NvcmUgaW5zdGFuY2UuXG4gICAqIEB0eXBlIHtTY29yZX1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgc2NvcmUoKSB7IHJldHVybiB0aGlzLl9zY29yZSB9XG5cbiAgLyoqXG4gICAqIE11c2ljIGRhdGFcbiAgICogQHR5cGUge0FycmF5LjxNdXNpY0RhdGFNaXhpbj59XG4gICAqL1xuICBnZXQgZGF0YSgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfHwgKHRoaXMuX2RhdGEgPSBbXSkgfVxuICBzZXQgZGF0YShkYXRhKSB7XG4gICAgdGhpcy5sZW5ndGggPSAwXG4gICAgZGF0YS5mb3JFYWNoKChkYXR1bSkgPT4geyB0aGlzLmFwcGVuZChkYXR1bSkgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBtZWFzdXJlcy5cbiAgICogQHR5cGUge1RpbWV3aXNlTWVhc3VyZXN9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG1lYXN1cmVzKCkgeyByZXR1cm4gdGhpcy5zY29yZS5tZWFzdXJlcyB9XG5cbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byB0aGUgcGFyZW50IG1lYXN1cmUuXG4gICAqIEB0eXBlIHtUaW1ld2lzZU1lYXN1cmV9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG1lYXN1cmUoKSB7IHJldHVybiB0aGlzLm1lYXN1cmVzW3RoaXMuX21JbmRleF0gfVxuXG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBwYXJ0cy5cbiAgICogQHR5cGUge1BhcnR3aXNlUGFydHN9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHBhcnRzKCkgeyByZXR1cm4gdGhpcy5zY29yZS5wYXJ0cyB9XG5cbiAgLyoqXG4gICAqIFJlZmVyZW5jZSB0byB0aGUgcGFyZW50IHBhcnQuXG4gICAqIEB0eXBlIHtQYXJ0d2lzZVBhcnR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHBhcnQoKSB7IHJldHVybiB0aGlzLnBhcnRzW3RoaXMuX3BJbmRleF0gfVxuXG4gIC8qKlxuICAgKiBQcmV2aW91cyBjZWxsIGluIHRoZSBwYXJ0LlxuICAgKiBAdHlwZSB7Q2VsbHx1bmRlZmluZWR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHByZXYoKSB7IHJldHVybiB0aGlzLnBhcnQubWVhc3VyZXNbdGhpcy5fbUluZGV4IC0gMV0gfVxuXG4gIC8qKlxuICAgKiBOZXh0IGNlbGwgaW4gdGhlIHBhcnQuXG4gICAqIEB0eXBlIHtDZWxsfHVuZGVmaW5lZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbmV4dCgpIHsgcmV0dXJuIHRoaXMucGFydC5tZWFzdXJlc1t0aGlzLl9tSW5kZXggKyAxXSB9XG5cbiAgLyoqXG4gICAqIFRoZSBmaXJzdCBtdXNpYyBkYXRhIGluIHRoZSBjZWxsLlxuICAgKiBAdHlwZSB7TXVzaWNEYXRhTWl4aW58dW5kZWZpbmVkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBmaXJzdERhdGEoKSB7IHJldHVybiB0aGlzLmRhdGFbMF0gfVxuXG4gIC8qKlxuICAgKiBUaGUgbGFzdCBtdXNpYyBkYXRhIGluIHRoZSBjZWxsLlxuICAgKiBAdHlwZSB7TXVzaWNEYXRhTWl4aW58dW5kZWZpbmVkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBsYXN0RGF0YSgpIHsgcmV0dXJuIHRoaXMuZGF0YVt0aGlzLmRhdGEubGVuZ3RoIC0gMV0gfVxuXG4gIC8qKlxuICAgKiBUaGUgbGVmdCBiYXIgb2YgdGhpcyBjZWxsLlxuICAgKiBAdHlwZSB7QmFyfHVuZGVmaW5lZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgYmFyTGVmdCgpIHtcbiAgICBjb25zdCB7IGZpcnN0RGF0YSB9ID0gdGhpc1xuICAgIGlmIChmaXJzdERhdGEgJiYgZmlyc3REYXRhLiR0eXBlID09PSAnYmFyJykgcmV0dXJuIGZpcnN0RGF0YVxuXG4gICAgLy8gVGFrZSBmcm9tIHRoZSBwcmV2aW91cyBtZWFzdXJlLlxuICAgIGNvbnN0IHByZXZDZWxsID0gdGhpcy5wcmV2XG4gICAgaWYgKHByZXZDZWxsKSByZXR1cm4gcHJldkNlbGwuYmFyUmlnaHRcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcmlnaHQgYmFyIG9mIHRoaXMgY2VsbC5cbiAgICogQHR5cGUge0Jhcnx1bmRlZmluZWR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGJhclJpZ2h0KCkge1xuICAgIGNvbnN0IHsgbGFzdERhdGEgfSA9IHRoaXNcbiAgICBpZiAobGFzdERhdGEgJiYgbGFzdERhdGEuJHR5cGUgPT09ICdiYXInKSByZXR1cm4gbGFzdERhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmQgYSBtdXNpYyBkYXRhIHRvIHRoZSBjZWxsLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG11c2ljRGF0YSAtIE11c2ljIGRhdGFcbiAgICovXG4gIGFwcGVuZChtdXNpY0RhdGEpIHtcbiAgICBjb25zdCB0eXBlID0gT2JqZWN0LmtleXMobXVzaWNEYXRhKVswXSAvLyBtdXNpY0RhdGEgaGFzIG9ubHkgb25lIGtleVxuICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IENsYXNzZXNbdHlwZV0obXVzaWNEYXRhW3R5cGVdKVxuICAgIGluc3RhbmNlLl9jZWxsID0gdGhpc1xuICAgIGluc3RhbmNlLl9pbmRleCA9IHRoaXMuZGF0YS5sZW5ndGhcbiAgICB0aGlzLmRhdGEucHVzaChpbnN0YW5jZSlcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFdpZHRoXG4gICAqIC0gKEdldHRlcikgR2V0IHRoZSBjZWxsIHdpZHRoLlxuICAgKiAtIChTZXR0ZXIpIFNldCB0aGUgY2VsbCB3aWR0aCwgYW5kIHRoaXMgd2lsbCBjYXVzZSB0aGUgY2VsbCB0byByZWZsb3cuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2lkdGgoKSB7IHJldHVybiB0aGlzLl93IH1cbiAgc2V0IHdpZHRoKHcpIHtcbiAgICB0aGlzLl93ID0gd1xuICAgIHJlZmxvdyh0aGlzKVxuICB9XG5cbiAgZ2V0IGhlaWdodCgpIHsgcmV0dXJuIHRoaXMubGF5b3V0Lm9wdGlvbnMucGFydEhlaWdodCB9XG5cbiAgLyoqXG4gICAqIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBjZWxsIGluIHBhcmVudCB0aW1ld2lzZSBtZWFzdXJlLlxuICAgKiAtIFNldCB0aGUgeCB2YWx1ZSB3aWxsIGNhdXNlIHRoZSBjZWxsIGVsZW1lbnQgdHJhbnNsYXRlLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHgoKSB7IHJldHVybiB0aGlzLl94IH1cbiAgc2V0IHgoeCkge1xuICAgIHRoaXMuX3ggPSB4XG4gICAgdGhpcy5lbC50cmFuc2Zvcm0obWF0cml4KCkudHJhbnNsYXRlKHgsIHRoaXMueTIpKVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB5MiBwb3NpdGlvbiBvZiB0aGUgY2VsbCBpbiBwYXJlbnQgdGltZXdpc2UgbWVhc3VyZS5cbiAgICogLSBTZXQgdGhlIHkyIHZhbHVlIHdpbGwgY2F1c2UgdGhlIGNlbGwgZWxlbWVudCB0cmFuc2xhdGUuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgeTIoKSB7XG4gICAgY29uc3QgeyBwYXJ0SGVpZ2h0LCBwYXJ0U2VwIH0gPSB0aGlzLmxheW91dC5vcHRpb25zXG4gICAgY29uc3QgcCA9IHRoaXMuX3BJbmRleFxuXG4gICAgcmV0dXJuIHAgPyAocCArIDEpICogcGFydEhlaWdodCArIHAgKiBwYXJ0U2VwIDogcGFydEhlaWdodFxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBsZWZ0IGJhciBvZiB0aGlzIGNlbGwuXG4gICAqIC0gYmFyTGVmdCBhdCBmaXJzdCBtZWFzdXJlIG9mIGEgc3lzdGVtOlxuICAgKiBgYGBcbiAgICogfF0gIC0+IHxcbiAgICogOnwgIC0+IHxcbiAgICogOnw6IC0+IHw6XG4gICAqIGBgYFxuICAgKiBAdHlwZSB7QmFyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBiYXJMZWZ0SW5TeXN0ZW0oKSB7XG4gICAgbGV0IGJhciA9IHRoaXMuYmFyTGVmdFxuICAgIGlmICghYmFyKSByZXR1cm4geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH1cblxuICAgIC8vIEZpcnN0IG1lYXN1cmUgaW4gdGhlIHN5c3RlbS5cbiAgICBpZiAodGhpcy5tZWFzdXJlLmluU3lzdGVtQmVnaW4pIHtcbiAgICAgIGlmIChiYXIudmFsdWUgPT09ICdlbmQnIHx8IGJhci52YWx1ZSA9PT0gJ3JlcGVhdC1lbmQnKSB7XG4gICAgICAgIGJhciA9IG5ldyBCYXIoJ3NpbmdsZScpXG4gICAgICB9IGVsc2UgaWYgKGJhci52YWx1ZSA9PT0gJ3JlcGVhdC1ib3RoJykge1xuICAgICAgICBiYXIgPSBuZXcgQmFyKCdyZXBlYXQtYmVnaW4nKVxuICAgICAgfVxuICAgIH1cbiAgICBiYXIuZGVmID0gdGhpcy5sYXlvdXQuZGVmcy5nZXQoYmFyKVxuICAgIHJldHVybiBiYXJcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcmlnaHQgYmFyIG9mIHRoaXMgY2VsbC5cbiAgICogLSBiYXJSaWdodCBhdCBsYXN0IG1lYXN1cmUgb2YgYSBzeXN0ZW06XG4gICAqIGBgYFxuICAgKiAgfDogLT4gIHxcbiAgICogOnw6IC0+IDp8XG4gICAqIGBgYFxuICAgKiBAdHlwZSB7bXVzamUuQmFyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBiYXJSaWdodEluU3lzdGVtKCkge1xuICAgIGNvbnN0IHsgc3lzdGVtIH0gPSB0aGlzLm1lYXN1cmVcbiAgICBsZXQgYmFyID0gdGhpcy5iYXJSaWdodFxuXG4gICAgaWYgKCFiYXIpIHJldHVybiB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfVxuXG4gICAgLy8gTGFzdCBtZWFzdXJlIGluIHRoZSBzeXN0ZW0uXG4gICAgaWYgKHN5c3RlbSAmJiB0aGlzLm1lYXN1cmUuaW5TeXN0ZW1FbmQpIHtcbiAgICAgIGlmIChiYXIudmFsdWUgPT09ICdyZXBlYXQtYmVnaW4nKSB7XG4gICAgICAgIGJhciA9IG5ldyBCYXIoJ3NpbmdsZScpXG4gICAgICB9IGVsc2UgaWYgKGJhci52YWx1ZSA9PT0gJ3JlcGVhdC1ib3RoJykge1xuICAgICAgICBiYXIgPSBuZXcgQmFyKCdyZXBlYXQtZW5kJylcbiAgICAgIH1cbiAgICB9XG4gICAgYmFyLmRlZiA9IHRoaXMubGF5b3V0LmRlZnMuZ2V0KGJhcilcbiAgICByZXR1cm4gYmFyXG4gIH1cblxuICAvKipcbiAgICogRmxvdyB0aGUgY2VsbC5cbiAgICovXG4gIGZsb3coKSB7XG4gICAgY29uc3QgeyBkZWZzLCBvcHRpb25zIH0gPSB0aGlzLmxheW91dFxuICAgIGNvbnN0IHsgbXVzaWNEYXRhU2VwIH0gPSBvcHRpb25zXG4gICAgbGV0IHggPSAwXG4gICAgbGV0IG1pbkhlaWdodFxuXG4gICAgdGhpcy5kYXRhLmZvckVhY2goZGF0YSA9PiB7XG4gICAgICBjb25zdCBkZWYgPSBkYXRhLmRlZiA9IGRlZnMuZ2V0KGRhdGEpXG4gICAgICBkYXRhLnggPSB4XG4gICAgICBkYXRhLnkgPSAwXG4gICAgICB4ICs9IGRlZi53aWR0aCArIG11c2ljRGF0YVNlcFxuICAgICAgbWluSGVpZ2h0ID0gTWF0aC5taW4obWluSGVpZ2h0LCBkZWYuaGVpZ2h0KVxuICAgIH0pXG5cbiAgICB0aGlzLm1pbldpZHRoID0geFxuICAgIHRoaXMubWluSGVpZ2h0ID0gbWluSGVpZ2h0XG4gIH1cblxuICAvKipcbiAgICogRHJhdyBib3ggb2YgdGhlIGNlbGwuXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9IFRoZSBib3ggU1ZHIHJlY3QgZWxlbWVudC5cbiAgICovXG4gIGRyYXdCb3goKSB7XG4gICAgdGhpcy5fYm94RWwgPSB0aGlzLmVsLnJlY3QoMCwgLXRoaXMuaGVpZ2h0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2Jib3gnKVxuICAgIHJldHVybiB0aGlzLl9ib3hFbFxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIHRoZSBib3ggU1ZHIGVsZW1lbnQuXG4gICAqL1xuICBjbGVhckJveCgpIHtcbiAgICB0aGlzLl9ib3hFbC5yZW1vdmUoKVxuICAgIHRoaXMuX2JveEVsID0gdW5kZWZpbmVkXG4gIH1cblxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGNlbGwgdG8gc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbnZlcnRlZCBjZWxsIGluIG11c2plIHNvdXJjZSBjb2RlLlxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5tYXAobXVzaWNEYXRhID0+IG11c2ljRGF0YS50b1N0cmluZygpKS5qb2luKCcgJylcbiAgfVxuXG4gIHRvSlNPTiA9IG1ha2VUb0pTT04oe1xuICAgIGRhdGE6IHVuZGVmaW5lZFxuICB9KVxufVxuXG4vLyBSZWZsb3cgdGhlIGNlbGwuXG5mdW5jdGlvbiByZWZsb3codGhhdCkge1xuICB0aGF0LmRhdGEuZm9yRWFjaChkYXRhID0+IHsgZGF0YS54ICo9IHRoYXQud2lkdGggLyB0aGF0Lm1pbldpZHRoIH0pXG59XG5cblxuLyoqXG4gKiBNYWtlIGJlYW1zIGF1dG9tYXRpY2FsbHkgaW4gZ3JvdXAgYnkgdGhlIGdyb3VwRHVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGdyb3VwRHVyIC0gRHVyYXRpb24gb2YgYSBiZWFtIGdyb3VwIGluIHF1YXJ0ZXIuXG4gKi9cbmZ1bmN0aW9uIG1ha2VCZWFtcyh0aGF0LCBncm91cER1cikge1xuXG4gIGdldEJlYW1Hcm91cHModGhhdCwgZ3JvdXBEdXIpLmZvckVhY2goZ3JvdXAgPT4ge1xuICAgIGNvbnN0IGJlYW1MZXZlbCA9IHt9ICAgLy8gaXQgc3RhcnRzIGZyb20gMCwgd2hpbGUgdW5kZXJiYXIgc3RhcnRzIGZyb20gMVxuXG4gICAgY29uc3QgbmV4dEhhc1NhbWVCZWFtbGV2ZWwgPSAoaW5kZXgsIGxldmVsKSA9PiB7XG4gICAgICBjb25zdCBuZXh0ID0gZ3JvdXBbaW5kZXggKyAxXVxuICAgICAgcmV0dXJuIG5leHQgJiYgbmV4dC5kdXJhdGlvbi51bmRlcmJhciA+IGxldmVsXG4gICAgfVxuXG4gICAgZ3JvdXAuZm9yRWFjaCgoZGF0YSwgaSkgPT4ge1xuICAgICAgY29uc3QgeyB1bmRlcmJhciB9ID0gZGF0YS5kdXJhdGlvblxuXG4gICAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgdW5kZXJiYXI7IGxldmVsKyspIHtcbiAgICAgICAgaWYgKG5leHRIYXNTYW1lQmVhbWxldmVsKGksIGxldmVsKSkge1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQmVhbXMgb2YgdGhlIG5vdGUuXG4gICAgICAgICAgICogLSBQcm9kdWNlZCBieSB0aGUge0BsaW5rIENlbGwjbWFrZUJlYW1zfSBtZXRob2QuXG4gICAgICAgICAgICogLSBUaGUgYWJvdmUgbWV0aG9kIGlzIGNhbGwgaW4ge0BsaW5rIFNjb3JlI3ByZXBhcmVDZWxsc30uXG4gICAgICAgICAgICogQG1lbWJlcm9mIE5vdGUjXG4gICAgICAgICAgICogQGFsaWFzIGJlYW1zXG4gICAgICAgICAgICogQHR5cGUge0FycmF5LjxCZWFtPn1cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBkYXRhLmJlYW1zID0gZGF0YS5iZWFtcyB8fCBbXVxuXG4gICAgICAgICAgaWYgKGJlYW1MZXZlbFtsZXZlbF0pIHtcbiAgICAgICAgICAgIGRhdGEuYmVhbXNbbGV2ZWxdID0gbmV3IEJlYW0oJ2NvbnRpbnVlJywgbGV2ZWwsIGRhdGEpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJlYW1MZXZlbFtsZXZlbF0gPSB0cnVlO1xuICAgICAgICAgICAgZGF0YS5iZWFtc1tsZXZlbF0gPSBuZXcgQmVhbSgnYmVnaW4nLCBsZXZlbCwgZGF0YSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGJlYW1MZXZlbFtsZXZlbF0pIHtcbiAgICAgICAgICAgIGRhdGEuYmVhbXMgPSBkYXRhLmJlYW1zIHx8IFtdO1xuICAgICAgICAgICAgZGF0YS5iZWFtc1tsZXZlbF0gPSBuZXcgQmVhbSgnZW5kJywgbGV2ZWwsIGRhdGEpXG4gICAgICAgICAgICBkZWxldGUgYmVhbUxldmVsW2xldmVsXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBnZXRCZWFtR3JvdXBzKHRoYXQsIGdyb3VwRHVyKSB7XG4gIGNvbnN0IGdyb3VwcyA9IFtdXG4gIGxldCBncm91cCA9IFtdXG4gIGxldCBjb3VudGVyID0gMFxuXG4gIGNvbnN0IGluR3JvdXAgPSAoKSA9PiBjb3VudGVyIDwgZ3JvdXBEdXIgJiYgIW5lYXIoY291bnRlciwgZ3JvdXBEdXIpXG4gIGNvbnN0IHB1dEdyb3VwID0gKCkgPT4ge1xuICAgIGlmIChncm91cC5sZW5ndGggPiAxKSBncm91cHMucHVzaChncm91cClcbiAgICBncm91cCA9IFtdXG4gIH1cblxuICB0aGF0LmRhdGEuZm9yRWFjaChtdXNpY0RhdGEgPT4ge1xuICAgIGlmIChtdXNpY0RhdGEuJHR5cGUgIT09ICdub3RlJyAmJiBtdXNpY0RhdGEuJHR5cGUgIT09ICdyZXN0JykgcmV0dXJuXG5cbiAgICBjb25zdCB7IGR1cmF0aW9uIH0gPSBtdXNpY0RhdGFcbiAgICBjb25zdCBkdXIgPSBkdXJhdGlvbi5xdWFydGVyXG5cbiAgICBjb3VudGVyICs9IGR1clxuXG4gICAgaWYgKGluR3JvdXAoKSkge1xuICAgICAgaWYgKGR1cmF0aW9uLnVuZGVyYmFyKSBncm91cC5wdXNoKG11c2ljRGF0YSlcbiAgICB9IGVsc2UgaWYgKG5lYXIoY291bnRlciwgZ3JvdXBEdXIpKSB7XG4gICAgICBncm91cC5wdXNoKG11c2ljRGF0YSlcbiAgICAgIHB1dEdyb3VwKClcbiAgICAgIGNvdW50ZXIgPSAwXG4gICAgfSBlbHNlIHtcbiAgICAgIHB1dEdyb3VwKClcbiAgICAgIGNvdW50ZXIgJT0gZ3JvdXBEdXJcbiAgICB9XG4gIH0pXG5cbiAgcHV0R3JvdXAoKVxuXG4gIHJldHVybiBncm91cHNcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2VsbFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21vZGVsL0NlbGwuanMiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfOF9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIHtcInJvb3RcIjpcIlNuYXBcIixcImNvbW1vbmpzMlwiOlwic25hcHN2Z1wiLFwiY29tbW9uanNcIjpcInNuYXBzdmdcIixcImFtZFwiOlwic25hcHN2Z1wifVxuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBleHRlbmQsIG1ha2VUb0pTT04gfSBmcm9tICcuLi91dGlsJ1xuaW1wb3J0IE11c2ljRGF0YSBmcm9tICcuL011c2ljRGF0YSdcblxuLyoqXG4gKiBUaW1lIHNpZ25hdHVyZS5cbiAqIEBjbGFzc1xuICogQHBhcmFtIHRpbWUge09iamVjdH1cbiAqIEBtaXhlcyBNdXNpY0RhdGFNaXhpblxuICogQG1peGVzIE11c2ljRGF0YUxheW91dE1peGluXG4gKi9cbmNsYXNzIFRpbWUgZXh0ZW5kcyBNdXNpY0RhdGEge1xuICBjb25zdHJ1Y3Rvcih0aW1lKSB7XG4gICAgc3VwZXIoKVxuICAgIGV4dGVuZCh0aGlzLCB0aW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIFR5cGUgb2YgdGltZS5cbiAgICogQGNvbnN0YW50XG4gICAqIEBkZWZhdWx0IHRpbWVcbiAgICovXG4gICR0eXBlID0gJ3RpbWUnXG5cbiAgLyoqXG4gICAqIEhvdyBtYW55IGJlYXRzIHBlciBtZWFzdXJlLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgYmVhdHMgPSA0XG5cbiAgLyoqXG4gICAqIEJlYXQgdHlwZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgYmVhdFR5cGUgPSA0XG5cbiAgLyoqXG4gICAqIERlZiBpZCB1c2VkIGluIHRoZSBTVkcgPGRlZnM+IGVsZW1lbnQuXG4gICAqIGBgYFxuICAgKiBpZCA6PSAndCcgYmVhdHMgJy0nIGJlYXRUeXBlXG4gICAqIGBgYFxuICAgKiBFLmcuIGB0My00YFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBkZWZJZCgpIHsgcmV0dXJuIGB0JHt0aGlzLmJlYXRzfS0ke3RoaXMuYmVhdFR5cGV9YCB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdG8gbXVzamUgc291cmNlIGNvZGUuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTXVzamUgc291cmNlIGNvZGUuXG4gICAqL1xuICB0b1N0cmluZygpIHsgcmV0dXJuIGAke3RoaXMuYmVhdHN9LyR7dGhpcy5iZWF0VHlwZX1gIH1cblxuICB0b0pTT04gPSBtYWtlVG9KU09OKHtcbiAgICBiZWF0czogNCxcbiAgICBiZWF0VHlwZTogNFxuICB9LCAndGltZScpXG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbWVcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2RlbC9UaW1lLmpzIiwiY2xhc3MgTXVzaWNEYXRhIHtcblxuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgY2VsbC5cbiAgICogQHR5cGUge0NlbGx9XG4gICAqL1xuICBnZXQgY2VsbCgpIHsgcmV0dXJuIHRoaXMuX2NlbGwgfVxuXG4gIC8qKlxuICAgKiBUaGUgYXNjZW5kYW50IHN5c3RlbSBvZiB0aGUgbXVzaWMgZGF0YS5cbiAgICogQHR5cGUge1N5c3RlbUxheW91dH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgc3lzdGVtKCkgeyByZXR1cm4gdGhpcy5jZWxsLm1lYXN1cmUuc3lzdGVtIH1cblxuICAvKipcbiAgICogUHJldmlvdXMgbXVzaWMgZGF0YS5cbiAgICogQHR5cGUge011c2ljRGF0YU1peGlufHVuZGVmaW5lZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcHJldigpIHsgcmV0dXJuIHRoaXMuY2VsbC5kYXRhW3RoaXMuX2luZGV4IC0gMV0gfVxuXG4gIC8qKlxuICAgKiBOZXh0IG11c2ljIGRhdGEuXG4gICAqIEB0eXBlIHtNdXNpY0RhdGFNaXhpbnx1bmRlZmluZWR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG5leHQoKSB7IHJldHVybiB0aGlzLmNlbGwuZGF0YVt0aGlzLl9pbmRleCArIDFdIH1cblxuICAvKipcbiAgICogUHJldmlvdXMgbXVzaWMgZGF0YSBpbiBwYXJ0LCBhY3Jvc3MgbWVhc3VyZS5cbiAgICogQHR5cGUge011c2ljRGF0YU1peGlufHVuZGVmaW5lZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcHJldkluUGFydCgpIHtcbiAgICBsZXQgeyBwcmV2LCBjZWxsIH0gPSB0aGlzXG4gICAgd2hpbGUgKCFwcmV2ICYmIGNlbGwucHJldikge1xuICAgICAgaWYgKCFwcmV2KSB7XG4gICAgICAgIGNlbGwgPSBjZWxsLnByZXZcbiAgICAgICAgcHJldiA9IGNlbGwubGFzdERhdGFcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByZXZcbiAgfVxuXG4gIC8qKlxuICAgKiBOZXh0IG11c2ljIGRhdGEgaW4gcGFydCwgYWNyb3NzIG1lYXN1cmUuXG4gICAqIEB0eXBlIHtNdXNpY0RhdGFNaXhpbnx1bmRlZmluZWR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG5leHRJblBhcnQoKSB7XG4gICAgbGV0IHsgbmV4dCwgY2VsbCB9ID0gdGhpc1xuICAgIHdoaWxlICghbmV4dCAmJiBjZWxsLm5leHQpIHtcbiAgICAgIGlmICghbmV4dCkge1xuICAgICAgICBjZWxsID0gY2VsbC5uZXh0XG4gICAgICAgIG5leHQgPSBjZWxsLmZpcnN0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV4dFxuICB9XG5cbiAgLyoqXG4gICAqIFByZXZpb3VzIG11c2ljIGRhdGEgd2hpY2ggaGFzIGEgZHVyYXRpb24uXG4gICAqIEB0eXBlIHtNdXNpY0RhdGFNaXhpbnx1bmRlZmluZWR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHByZXZEdXJhYmxlKCkge1xuICAgIGxldCB7IHByZXYgfSA9IHRoaXNcbiAgICB3aGlsZSAocHJldiAmJiAhcHJldi5kdXJhdGlvbikgcHJldiA9IHByZXYucHJldlxuICAgIHJldHVybiBwcmV2XG4gIH1cblxuICAvKipcbiAgICogTmV4dCBtdXNpYyBkYXRhIHdoaWNoIGhhcyBhIGR1cmF0aW9uLlxuICAgKiBAdHlwZSB7TXVzaWNEYXRhTWl4aW58dW5kZWZpbmVkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBuZXh0RHVyYWJsZSgpIHtcbiAgICBsZXQgeyBuZXh0IH0gPSB0aGlzXG4gICAgd2hpbGUgKG5leHQgJiYgIW5leHQuZHVyYXRpb24pIG5leHQgPSBuZXh0Lm5leHRcbiAgICByZXR1cm4gbmV4dFxuICB9XG5cbiAgLyoqXG4gICAqIFByZXZpb3VzIG11c2ljIGRhdGEgd2hpY2ggaGFzIGEgZHVyYXRpb24gaW4gcGFydCwgYWNyb3NzIG1lYXN1cmUuXG4gICAqIEB0eXBlIHtNdXNpY0RhdGFNaXhpbnx1bmRlZmluZWR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHByZXZEdXJhYmxlSW5QYXJ0KCkge1xuICAgIGxldCBwcmV2ID0gdGhpcy5wcmV2SW5QYXJ0XG4gICAgd2hpbGUgKHByZXYgJiYgIXByZXYuZHVyYXRpb24pIHByZXYgPSBwcmV2LnByZXZJblBhcnRcbiAgICByZXR1cm4gcHJldlxuICB9XG5cbiAgLyoqXG4gICAqIE5leHQgbXVzaWMgZGF0YSB3aGljaCBoYXMgYSBkdXJhdGlvbiBpbiBwYXJ0LCBhY3Jvc3MgbWVhc3VyZS5cbiAgICogQHR5cGUge011c2ljRGF0YU1peGlufHVuZGVmaW5lZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbmV4dER1cmFibGVJblBhcnQoKSB7XG4gICAgbGV0IG5leHQgPSB0aGlzLm5leHRJblBhcnRcbiAgICB3aGlsZSAobmV4dCAmJiAhbmV4dC5kdXJhdGlvbikgbmV4dCA9IG5leHQubmV4dEluUGFydFxuICAgIHJldHVybiBuZXh0XG4gIH1cblxuXG4gIC8qKlxuICAgKiBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgbXVzaWMgZGF0YSBpbiB0aGUgY2VsbC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB4KCkgeyByZXR1cm4gdGhpcy5feCB9XG4gIHNldCB4KHgpIHtcbiAgICB0aGlzLl94ID0geFxuICAgIGlmICh0aGlzLmVsKSB0aGlzLmVsLmF0dHIoJ3gnLCB4KVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBtdXNpYyBkYXRhIGluIHRoZSBjZWxsLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHkoKSB7IHJldHVybiB0aGlzLl95IH1cbiAgc2V0IHkoeSkge1xuICAgIHRoaXMuX3kgPSB5XG4gICAgaWYgKHRoaXMuZWwpIHRoaXMuZWwuYXR0cigneScsIHkpXG4gIH1cblxuICAvKipcbiAgICogVGhlIHggcG9zaXRpb24gb2YgdGhlIG11c2ljIGRhdGEgaW4gdGhlIHN5c3RlbS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBzeXN0ZW1YKCkgeyByZXR1cm4gdGhpcy54ICsgdGhpcy5jZWxsLnggKyB0aGlzLmNlbGwubWVhc3VyZS54IH1cblxuICAvKipcbiAgICogVGhlIHdpZHRoIG9mIHRoZSBtdXNpYyBkYXRhLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB3aWR0aCgpIHsgcmV0dXJuIHRoaXMuZGVmLndpZHRoIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTXVzaWNEYXRhXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbW9kZWwvTXVzaWNEYXRhLmpzIiwiaW1wb3J0IE11c2ljRGF0YSBmcm9tICcuL011c2ljRGF0YSdcblxuY29uc3QgQkFSX1RPX1NUUklORyA9IHtcbiAgc2luZ2xlOiAnfCcsIGRvdWJsZTogJ3x8JywgZW5kOiAnfF0nLFxuICAncmVwZWF0LWJlZ2luJzogJ3w6JywgJ3JlcGVhdC1lbmQnOiAnOnwnLCAncmVwZWF0LWJvdGgnOiAnOnw6J1xufVxuY29uc3QgQkFSX1RPX0lEID0ge1xuICBzaW5nbGU6ICdicycsIGRvdWJsZTogJ2JkJywgZW5kOiAnYmUnLFxuICAncmVwZWF0LWJlZ2luJzogJ2JyYicsICdyZXBlYXQtZW5kJzogJ2JyZScsICdyZXBlYXQtYm90aCc6ICdicmJlJ1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXIgLSBUaGUgYmFyIHZhbHVlLCB3aGljaCBjYW4gYmUgZWl0aGVyIG9mXG4gKiAtICdzaW5nbGUnIC0gYHxgXG4gKiAtICdkb3VibGUnIC0gYHx8YFxuICogLSAnZW5kJyAtIGB8XWBcbiAqIC0gJ3JlcGVhdC1iZWdpbicgLSBgfDpgXG4gKiAtICdyZXBlYXQtZW5kJyAtIGA6fGBcbiAqIC0gJ3JlcGVhdC1ib3RoJyAtIGA6fDpgXG4gKi9cbmNsYXNzIEJhciBleHRlbmRzIE11c2ljRGF0YSB7XG4gIGNvbnN0cnVjdG9yKGJhcikge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl92YWx1ZSA9IGJhclxuICB9XG5cbiAgLyoqXG4gICAqIFR5cGUgb2YgYmFyLlxuICAgKiBAY29uc3RhbnRcbiAgICogQHJlYWRvbmx5XG4gICAqIEBkZWZhdWx0IGJhclxuICAgKi9cbiAgJHR5cGUgPSAnYmFyJ1xuXG4gIC8qKlxuICAgKiBWYWx1ZSBvZiB0aGUgYmFyLCB3aGljaCBpcyB0aGUgc2FtZSBhcyB0aGUgYmFyIHBhcmFtZXRlciBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0IHNpbmdsZVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB2YWx1ZSgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlIHx8ICh0aGlzLl92YWx1ZSA9ICdzaW5nbGUnKSB9XG5cbiAgLyoqXG4gICAqIERlZiBpZCB1c2VkIGluIHRoZSBTVkcgPGRlZnM+IGVsZW1lbnQuXG4gICAqIGBgYFxuICAgKiBkZWZJZCAgICBCYXIgdmFsdWVcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiAnYnMnICAgLSBzaW5nbGVcbiAgICogJ2JkJyAgIC0gZG91YmxlXG4gICAqICdiZScgICAtIHJlcGVhdC1lbmRcbiAgICogJ2JyYicgIC0gcmVwZWF0LWJlZ2luXG4gICAqICdicmUnICAtIHJlcGVhdC1lbmRcbiAgICogJ2JyYmUnIC0gcmVwZWF0LWJvdGhcbiAgICogYGBgXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGRlZklkKCkgeyByZXR1cm4gQkFSX1RPX0lEW3RoaXMudmFsdWVdIH1cblxuICAvKipcbiAgICogQ29udmVydCBiYXIgdG8gc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbnZlcnRlZCBzdHJpbmcgb2YgdGhlIGJhcmxpbmUgaW4gbXVzamUgc291cmNlIGNvZGUuXG4gICAqL1xuICB0b1N0cmluZygpIHsgcmV0dXJuIEJBUl9UT19TVFJJTkdbdGhpcy52YWx1ZV0gfVxuXG4gIC8qKlxuICAgKiBbdG9KU09OIGRlc2NyaXB0aW9uXVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHsgYmFyOiB2YWx1ZSB9XG4gICAqL1xuICB0b0pTT04oKSB7IHJldHVybiB7IGJhcjogdGhpcy52YWx1ZSB9IH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbW9kZWwvQmFyLmpzIiwiaW1wb3J0IHsgZXh0ZW5kLCBtYWtlVG9KU09OIH0gZnJvbSAnLi4vdXRpbCdcbmltcG9ydCBNdXNpY0RhdGEgZnJvbSAnLi9NdXNpY0RhdGEnXG5pbXBvcnQgUGl0Y2ggZnJvbScuL1BpdGNoJ1xuaW1wb3J0IER1cmF0aW9uIGZyb20gJy4vRHVyYXRpb24nXG5pbXBvcnQgVGllIGZyb20gJy4vVGllJ1xuaW1wb3J0IFNsdXIgZnJvbSAnLi9TbHVyJ1xuXG4vKipcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtPYmplY3R9IG5vdGVcbiAqIEBtaXhlcyBNdXNpY0RhdGFNaXhpblxuICogQG1peGVzIE11c2ljRGF0YUxheW91dE1peGluXG4gKi9cbmNsYXNzIE5vdGUgZXh0ZW5kcyBNdXNpY0RhdGEge1xuICBjb25zdHJ1Y3Rvcihub3RlKSB7XG4gICAgc3VwZXIoKVxuICAgIGV4dGVuZCh0aGlzLCBub3RlKVxuICB9XG5cbiAgLyoqXG4gICAqIFR5cGUgb2Ygbm90ZS5cbiAgICogQGNvbnN0YW50XG4gICAqIEBkZWZhdWx0IG5vdGVcbiAgICovXG4gICR0eXBlID0gJ25vdGUnXG5cbiAgLyoqXG4gICAqIFVuaXF1ZSBkZWYgaWQgb2YgdGhlIG5vdGUgdXNlZCBpbiB0aGUgU1ZHIDxkZWZzPiBlbGVtZW50LlxuICAgKiBgYGBcbiAgICogZGVmSWQgOj0gJ24nIGFjY2lkZW50YWwgc3RlcCBvY3RhdmUgdHlwZSBkb3RcbiAgICogYGBgXG4gICAqIEUuZy5cbiAgICogYGBgXG4gICAqIE5vdGUgICAgIGRlZklkXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiAxICAgICAgICBuMTA0MFxuICAgKiBiMy0gICAgICBuYjMwMjBcbiAgICogIzUnXy4gICAgbnM1MTgxXG4gICAqIDYsLCAgICAgIG42LTJcbiAgICogYGBgXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGRlZklkKCkge1xuICAgIGNvbnN0IHsgYWNjaWRlbnRhbCwgc3RlcCwgb2N0YXZlIH0gPSB0aGlzLnBpdGNoXG4gICAgY29uc3QgeyB0eXBlLCBkb3QgfSA9IHRoaXMuZHVyYXRpb25cbiAgICByZXR1cm4gYG4ke2FjY2lkZW50YWwucmVwbGFjZSgvIy9nLCAncycpfSR7c3RlcH0ke29jdGF2ZX0ke3R5cGV9JHtkb3R9YFxuICB9XG5cbiAgLyoqXG4gICAqIFBpdGNoIG9mIHRoZSBub3RlLlxuICAgKiBAdHlwZSB7bXVzamUuUGl0Y2h9XG4gICAqL1xuICBnZXQgcGl0Y2goKSB7IHJldHVybiB0aGlzLl9waXRjaCB8fCAodGhpcy5fcGl0Y2ggPSBuZXcgUGl0Y2godGhpcykpIH1cbiAgc2V0IHBpdGNoKHBpdGNoKSB7IHRoaXMuX3BpdGNoID0gbmV3IFBpdGNoKHRoaXMsIHBpdGNoKSB9XG5cbiAgLyoqXG4gICAqIER1cmF0aW9uIG9mIHRoZSBub3RlLlxuICAgKiBAdHlwZSB7bXVzamUuRHVyYXRpb259XG4gICAqL1xuICBnZXQgZHVyYXRpb24oKSB7IHJldHVybiB0aGlzLl9kdXJhdGlvbiB8fCAodGhpcy5fZHVyYXRpb24gPSBuZXcgRHVyYXRpb24oKSkgfVxuICBzZXQgZHVyYXRpb24gKGR1cmF0aW9uKSB7IHRoaXMuX2R1cmF0aW9uID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKSB9XG5cbiAgZ2V0IGJlYW1zKCkgeyByZXR1cm4gdGhpcy5fYmVhbXMgfHwgKHRoaXMuX2JlYW1zID0gW10pIH1cbiAgc2V0IGJlYW1zKGJlYW1zKSB7IHRoaXMuX2JlYW1zID0gYmVhbXMgfVxuXG4gIC8qKlxuICAgKiBUaWVcbiAgICogQHR5cGUge211c2plLlRpZX1cbiAgICovXG4gIGdldCB0aWUoKSB7IHJldHVybiB0aGlzLl90aWUgfHwgKHRoaXMuX3RpZSA9IG5ldyBUaWUodGhpcykpIH1cbiAgc2V0IHRpZSh0aWUpIHtcbiAgICAvKipcbiAgICAgKiBWYWx1ZSBvZiB0aGUgdGllLlxuICAgICAqIEBtZW1iZXJvZiBUaWUjXG4gICAgICogQGFsaWFzIHZhbHVlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy50aWUudmFsdWUgPSB0aWVcbiAgfVxuXG4gIC8qKlxuICAgKiBTbHVyXG4gICAqIEB0eXBlIHtTbHVyfVxuICAgKi9cbiAgZ2V0IHNsdXIoKSB7IHJldHVybiB0aGlzLl9zbHVyIHx8ICh0aGlzLl9zbHVyID0gbmV3IFNsdXIodGhpcykpIH1cbiAgc2V0IHNsdXIoc2x1cikgeyBleHRlbmQodGhpcy5zbHVyLCBzbHVyKSB9XG5cbiAgLyoqIEBtZXRob2QgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2x1ci5iZWdpbiArIHRoaXMucGl0Y2ggKyB0aGlzLmR1cmF0aW9uICtcbiAgICAgICAgICAgdGhpcy5zbHVyLmVuZCArIHRoaXMudGllLnZhbHVlXG4gIH1cblxuICB0b0pTT04gPSBtYWtlVG9KU09OKHtcbiAgICBwaXRjaDogdW5kZWZpbmVkLFxuICAgIGR1cmF0aW9uOiB1bmRlZmluZWQsXG4gICAgdGllOiB1bmRlZmluZWQsXG4gICAgc2x1cjogdW5kZWZpbmVkXG4gIH0sICdub3RlJylcbn1cblxuZXhwb3J0IGRlZmF1bHQgTm90ZVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21vZGVsL05vdGUuanMiLCJpbXBvcnQgeyBtYWtlVG9KU09OLCBleHRlbmQgfSBmcm9tICcuLi91dGlsJ1xuXG5jb25zdCBBNF9GUkVRVUVOQ1kgPSA0NDBcbmNvbnN0IEE0X01JRElfTlVNQkVSID0gNjlcbmNvbnN0IFNURVBfVE9fTUlESV9OVU1CRVIgPSBbdW5kZWZpbmVkLCAwLCAyLCA0LCA1LCA3LCA5LCAxMV1cbmNvbnN0IEFDQ0lERU5UQUxfVE9fQUxURVIgPSB7ICcjJyA6IDEsICcjIyc6IDIsIG46IDAsIGIgOiAtMSwgYmI6IC0yIH1cblxuY29uc3QgY2hhcnMgPSAoY2gsIG51bSkgPT4gbmV3IEFycmF5KG51bSArIDEpLmpvaW4oY2gpXG5jb25zdCBvY3RhdmVTdHJpbmcgPSAob2N0YXZlKSA9PlxuICBvY3RhdmUgPiAwID8gY2hhcnMoJ1xcJycsIG9jdGF2ZSkgOlxuICBvY3RhdmUgPCAwID8gY2hhcnMoJywnLCAtb2N0YXZlKSA6ICcnXG5cbi8vIC8qKlxuLy8gICogU3RlcCBpcyBhIHZhbHVlIG9mIGAxYCwgYDJgLCBgM2AsIGA0YCwgYDVgLCBgNmAsIG9yIGA3YC5cbi8vICAqIEB0eXBlIHtudW1iZXJ9XG4vLyAgKiBAZGVmYXVsdFxuLy8gICovXG4vLyBzdGVwID0gMVxuXG4vLyAvKipcbi8vICAqIE9jdGF2ZSBpcyBhbiBpbnRlZ2VyIHZhbHVlIGZyb20gYC01YCB0byBgNWAgaW5jbHVzaXZlLlxuLy8gICogQHR5cGUge251bWJlcn1cbi8vICAqIEBkZWZhdWx0XG4vLyAgKi9cbi8vIG9jdGF2ZSA9IDBcblxuLy8gLyoqXG4vLyAgKiBBY2NpZGVudGFsIGlzIGVpdGhlciBvZlxuLy8gICogLSBgJyMnYCAtIHNoYXJwXG4vLyAgKiAtIGAnIyMnYCAtIGRvdWJsZSBzaGFycFxuLy8gICogLSBgJ2InYCAtIGZsYXRcbi8vICAqIC0gYCdiYidgIC0gZG91YmxlIGZsYXRcbi8vICAqIC0gYCduJ2AgLSBuYXR1cmFsXG4vLyAgKiAtIGAnJ2AgLSAobm9uZSlcbi8vICAqIEB0eXBlIHtzdHJpbmd9XG4vLyAgKi9cbi8vIGFjY2lkZW50YWwgPSAnJ1xuXG4vKipcbiAqIEBjbGFzc1xuICogQHBhcmFtIHBhcmVudCB7Tm90ZXxDaG9yZH1cbiAqIEBwYXJhbSBwaXRjaCB7T2JqZWN0fVxuICovXG5jbGFzcyBQaXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwge1xuICAgIHN0ZXAgPSAxLFxuICAgIG9jdGF2ZSA9IDAsXG4gICAgYWNjaWRlbnRhbCA9ICcnXG4gIH0pIHtcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnRcbiAgICBleHRlbmQodGhpcywgeyBzdGVwLCBvY3RhdmUsIGFjY2lkZW50YWwgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBwYXJlbnQuXG4gICAqIEB0eXBlIHtOb3RlfENob3JkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBwYXJlbnQoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQgfVxuXG4gIC8qKlxuICAgKiBEZWYgaWQgdXNlZCBpbiB0aGUgU1ZHIDxkZWZzPiBlbGVtZW50LlxuICAgKiBgYGBcbiAgICogZGVmSWQgOj0gJ3AnIGFjY2lkZW50YWwgc3RlcCBvY3RhdmVcbiAgICogYGBgXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGRlZklkKCkge1xuICAgIHJldHVybiBgcCR7dGhpcy5hY2NpZGVudGFsLnJlcGxhY2UoLyMvZywgJ3MnKX0ke3RoaXMuc3RlcH0ke3RoaXMub2N0YXZlfWBcbiAgfVxuXG4gIC8qKlxuICAgKiBBbHRlciAoZnJvbSAtMiB0byAyIGluY2x1c2l2ZSkuXG4gICAqXG4gICAqIElmIG5vIGFjY2lkZW50YWwgaW4gdGhpcyBwaXRjaCwgaXQgbWlnaHQgYmUgYWZmZWN0ZWQgYnkgYSBwcmV2aW91cyBub3RlIGluIHRoZSBzYW1lIGNlbGwgKHRoZSBzYW1lIHBhcnQgYW5kIHRoZSBzYW1lIG1lYXN1cmUpLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBhbHRlcigpIHtcbiAgICBpZiAodGhpcy5hY2NpZGVudGFsKSByZXR1cm4gQUNDSURFTlRBTF9UT19BTFRFUlt0aGlzLmFjY2lkZW50YWxdXG4gICAgY29uc3QgeyBhbHRlckxpbmsgfSA9IHRoaXNcbiAgICByZXR1cm4gYWx0ZXJMaW5rID8gYWx0ZXJMaW5rLmFsdGVyIDogMFxuICB9XG5cbiAgLyoqXG4gICAqIFBpdGNoIGxpbmtlZCB0aGF0IHdpbGwgYWZmZWN0IHRoZSBhbHRlciBpbiB0aGlzIHBpdGNoLlxuICAgKiBAdHlwZSB7UGl0Y2h8dW5kZWZpbmVkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBhbHRlckxpbmsoKSB7XG4gICAgbGV0IHByZXZEYXRhID0gdGhpcy5wYXJlbnQucHJldlxuXG4gICAgd2hpbGUocHJldkRhdGEpIHtcbiAgICAgIGlmIChwcmV2RGF0YS4kdHlwZSA9PT0gJ25vdGUnICYmXG4gICAgICAgICAgcHJldkRhdGEucGl0Y2guc3RlcCA9PT0gdGhpcy5zdGVwICYmIHByZXZEYXRhLnBpdGNoLmFjY2lkZW50YWwpIHtcbiAgICAgICAgcmV0dXJuIHByZXZEYXRhLnBpdGNoXG4gICAgICB9XG4gICAgICBwcmV2RGF0YSA9IHByZXZEYXRhLnByZXZcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIE1JREkgbm90ZSBudW1iZXIgb2YgdGhlIHBpdGNoXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWlkaU51bWJlcigpIHtcbiAgICByZXR1cm4gKHRoaXMub2N0YXZlICsgNSkgKiAxMiArIFNURVBfVE9fTUlESV9OVU1CRVJbdGhpcy5zdGVwXSArIHRoaXMuYWx0ZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBGcmVxdWVuY3kgb2YgdGhlIHBpdGNoXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGZyZXF1ZW5jeSgpIHtcbiAgICByZXR1cm4gQTRfRlJFUVVFTkNZICogTWF0aC5wb3coMiwgKHRoaXMubWlkaU51bWJlciAtIEE0X01JRElfTlVNQkVSKSAvIDEyKVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdG8gbXVzamUgc291cmNlIGNvZGUgc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbnZlcnRlZCBtdXNqZSBzb3VyY2UgY29kZSBzdHJpbmcuXG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5hY2NpZGVudGFsICsgdGhpcy5zdGVwICsgb2N0YXZlU3RyaW5nKHRoaXMub2N0YXZlKVxuICB9XG5cbiAgdG9KU09OID0gbWFrZVRvSlNPTih7XG4gICAgc3RlcDogMSxcbiAgICBvY3RhdmU6IDAsXG4gICAgYWNjaWRlbnRhbDogJydcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgUGl0Y2hcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2RlbC9QaXRjaC5qcyIsImltcG9ydCB7IG1ha2VUb0pTT04sIGV4dGVuZCB9IGZyb20gJy4uL3V0aWwnXG5cbmNvbnN0IFRZUEVfVE9fU1RSSU5HID0ge1xuICAxOiAnIC0gLSAtICcsIDI6ICcgLSAnLCA0OiAnJywgODogJ18nLCAxNjogJz0nLCAzMjogJz1fJyxcbiAgNjQ6ICc9PScsIDEyODogJz09XycsIDI1NjogJz09PScsIDUxMjogJz09PV8nLCAxMDI0OiAnPT09PSdcbn1cbmNvbnN0IFRZUEVfVE9fVU5ERVJCQVIgPSB7XG4gICAxOiAwLCAgIDI6IDAsICAgNDogMCwgICA4OiAxLCAgIDE2OiAyLCAzMjogMyxcbiAgNjQ6IDQsIDEyODogNSwgMjU2OiA2LCA1MTI6IDcsIDEwMjQ6IDhcbn1cbmNvbnN0IERPVF9UT19TVFJJTkcgPSBbJycsICcuJywgJy4uJ11cblxuXG4gIC8vIC8qKlxuICAvLyAgKiBCZWF0IHR5cGVcbiAgLy8gICogQHR5cGUge251bWJlcn1cbiAgLy8gICogQGRlZmF1bHRcbiAgLy8gICovXG4gIC8vIHR5cGUgPSA0XG5cbiAgLy8gKlxuICAvLyAgKiBEb3Qgd2l0aCB2YWx1ZSBvZiAwLCAxLCBvciAyLlxuICAvLyAgKiBAdHlwZSB7bnVtYmVyfVxuICAvLyAgKiBAZGVmYXVsdFxuXG4gIC8vIGRvdCA9IDBcblxuY2xhc3MgRHVyYXRpb257XG4gIGNvbnN0cnVjdG9yKHsgdHlwZSA9IDQsIGRvdCA9IDAgfSA9IHt9KSB7XG4gICAgZXh0ZW5kKHRoaXMsIHsgdHlwZSwgZG90IH0pXG4gIH1cblxuICAvKipcbiAgICogVHlwZSBvZiBkdXJhdGlvbi5cbiAgICogQGNvbnN0YW50XG4gICAqIEBkZWZhdWx0IGR1cmF0aW9uXG4gICAqL1xuICAkdHlwZSA9ICdkdXJhdGlvbidcblxuICAvKipcbiAgICogRGVmIGlkIHVzZWQgaW4gdGhlIFNWRyA8ZGVmcz4gZWxlbWVudC5cbiAgICogYGBgXG4gICAqIGRlZklkIDo9ICdkJyB0eXBlIGRvdFxuICAgKiBgYGBcbiAgICogKkUuZy4qXG4gICAqIGBgYFxuICAgKiBOb3RlICAgICBkZWZJZFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tXG4gICAqIDEuICAgICAgIGQ0MVxuICAgKiAxXyAgICAgICBkODBcbiAgICogMT0gICAgICAgZDE2MFxuICAgKiAxLS4uICAgICBkMjJcbiAgICogYGBgXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGRlZklkKCkgeyByZXR1cm4gYGQke3RoaXMudHlwZX0ke3RoaXMuZG90fWAgfVxuXG4gIC8qKlxuICAgKiBgKEdldHRlcilgIER1cmF0aW9uIG1lYXN1cmVkIGluIHF1YXJ0ZXIgbm90ZS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBxdWFydGVyKCkge1xuICAgIGNvbnN0IGQgPSA0IC8gdGhpcy50eXBlXG4gICAgcmV0dXJuIHRoaXMuZG90ID09PSAwID8gZCA6XG4gICAgICAgICAgIHRoaXMuZG90ID09PSAxID8gZCAqIDEuNSA6IGQgKiAxLjc1XG4gIH1cblxuICAvKipcbiAgICogYChHZXR0ZXIpYCBEdXJhdGlvbiBpbiBzZWNvbmRcbiAgICogQWZmZWN0ZWQgYnkgdGhlIHRlbXBvLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBzZWNvbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVhcnRlciAqIDYwIC8gODAgIC8vIC8gVEVNUE87XG4gIH1cblxuICAvKipcbiAgICogYChHZXR0ZXIpYCBOdW1iZXIgb2YgdW5kZXJiYXJzIGluIHRoZSBiZWFtLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB1bmRlcmJhcigpIHsgcmV0dXJuIFRZUEVfVE9fVU5ERVJCQVJbdGhpcy50eXBlXSB8fCAwIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7IHJldHVybiBUWVBFX1RPX1NUUklOR1t0aGlzLnR5cGVdICsgRE9UX1RPX1NUUklOR1t0aGlzLmRvdF0gfVxuXG4gIC8qKlxuICAgKiBbdG9KU09OIGRlc2NyaXB0aW9uXVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICB0b0pTT04gPSBtYWtlVG9KU09OKHtcbiAgICB0eXBlOiA0LFxuICAgIGRvdDogMFxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBEdXJhdGlvblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21vZGVsL0R1cmF0aW9uLmpzIiwiLyoqXG4gKiBUaWUgb2YgdGhlIG5vdGUuXG4gKiBAcGFyYW0gcGFyZW50IHtOb3RlfENob3JkfVxuICovXG5jbGFzcyBUaWUge1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnRcbiAgfVxuXG4gIHZhbHVlID0gJydcblxuICBnZXQgcGFyZW50KCkgeyByZXR1cm4gdGhpcy5fcGFyZW50IH1cblxuICBnZXQgYmVnaW4oKSB7IHJldHVybiB0aGlzLnZhbHVlIH1cblxuICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5wcmV2UGFyZW50IH1cblxuICAvKipcbiAgICogVGhlIHByZXZpb3VzIGR1cmFibGUgbXVzaWMgZGF0YSBpbiBwYXJ0LCBpZiBpdCBpcyBhIHRpZSBiZWdpbi5cbiAgICogQHR5cGUge0R1cmFibGV8dW5kZWZpbmVkfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBwcmV2UGFyZW50KCkge1xuICAgIHZhciBwcmV2ID0gdGhpcy5wYXJlbnQucHJldkR1cmFibGVJblBhcnRcbiAgICByZXR1cm4gcHJldiAmJiBwcmV2LnRpZSAmJiBwcmV2LnRpZS52YWx1ZSAmJiBwcmV2XG4gIH1cblxuICAvKipcbiAgICogVGhlIG5leHQgZHVyYWJsZSBtdXNpYyBkYXRhIGluIHBhcnQuXG4gICAqIEB0eXBlIHtEdXJhYmxlfHVuZGVmaW5lZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbmV4dFBhcmVudCgpIHsgcmV0dXJuIHRoaXMudmFsdWUgJiYgdGhpcy5wYXJlbnQubmV4dER1cmFibGVJblBhcnQgfVxuXG4gIC8qKlxuICAgKiBJZiBwcmV2aW91cyBkdXJhYmxlIG11c2ljIGRhdGEgaW4gcGFydCBoYXMgZXJyb3IuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBwcmV2SGFzRXJyb3IoKSB7XG4gICAgY29uc3QgcHJldiA9IHRoaXMucHJldlBhcmVudFxuICAgIGlmICghcHJldiB8fCAhcHJldi5waXRjaCkgcmV0dXJuIHRydWVcbiAgICByZXR1cm4gcHJldi5waXRjaCAmJiBwcmV2LnBpdGNoLm1pZGlOdW1iZXIgIT09IHRoaXMucGFyZW50LnBpdGNoLm1pZGlOdW1iZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBuZXh0IGR1cmFibGUgbXVzaWMgZGF0YSBpbiBwYXJ0IGhhcyBlcnJvci5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG5leHRIYXNFcnJvcigpIHtcbiAgICB2YXIgbmV4dCA9IHRoaXMubmV4dFBhcmVudFxuICAgIGlmICghbmV4dCB8fCAhbmV4dC5waXRjaCkgcmV0dXJuIHRydWVcbiAgICByZXR1cm4gbmV4dC5waXRjaC5taWRpTnVtYmVyICE9PSB0aGlzLnBhcmVudC5waXRjaC5taWRpTnVtYmVyXG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUaWVcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2RlbC9UaWUuanMiLCJpbXBvcnQgeyBtYWtlVG9KU09OIH0gZnJvbSAnLi4vdXRpbCdcblxuLyoqXG4gKiBTbHVyXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSBwYXJlbnQge05vdGV8Q2hvcmR9XG4gKi9cbmNsYXNzIFNsdXIge1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnRcbiAgfVxuXG4gIGJlZ2luID0gJydcblxuICBlbmQgPSAnJ1xuXG4gIC8qKlxuICAgKiBQYXJlbnQgbXVzaWMgZGF0YS5cbiAgICogQHR5cGUge05vdGV8Q2hvcmR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHBhcmVudCgpIHsgcmV0dXJuIHRoaXMuX3BhcmVudCB9XG5cbiAgLyoqXG4gICAqIFByZXZpb3VzIHNsdXJyZWQgcGFyZW50LlxuICAgKiBAdHlwZSB7Tm90ZXxDaG9yZH1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcHJldlBhcmVudCgpIHtcbiAgICBpZiAoIXRoaXMuZW5kKSByZXR1cm5cblxuICAgIGxldCBwcmV2ID0gdGhpcy5wYXJlbnQucHJldkluUGFydFxuICAgIHdoaWxlIChwcmV2KSB7XG4gICAgICBpZiAocHJldi5zbHVyICYmICFwcmV2LnNsdXIuaXNFbXB0eSkgcmV0dXJuIHByZXZcbiAgICAgIHByZXYgPSBwcmV2LnByZXZJblBhcnRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTmV4dCBTbHVycmVkIHBhcmVudC5cbiAgICogQHR5cGUge05vdGV8Q2hvcmR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG5leHRQYXJlbnQoKSB7XG4gICAgaWYgKCF0aGlzLmJlZ2luKSByZXR1cm5cblxuICAgIGxldCBuZXh0ID0gdGhpcy5wYXJlbnQubmV4dEluUGFydFxuICAgIHdoaWxlIChuZXh0KSB7XG4gICAgICBpZiAobmV4dC5zbHVyICYmICFuZXh0LnNsdXIuaXNFbXB0eSkgcmV0dXJuIG5leHRcbiAgICAgIG5leHQgPSBuZXh0Lm5leHRJblBhcnRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRvZG8gTmVzdGVkIHRpZSBpbiBzbHVyLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcHJldkNyb3NzVGllKCkge31cblxuICAvKipcbiAgICogQHRvZG8gTmVzdGVkIHRpZSBpbiBzbHVyLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbmV4dENyb3NzVGllKCkge31cblxuICAvKipcbiAgICogSWYgdGhlIHByZXZpb3VzIHNsdXIgaGFzIGVycm9yLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgcHJldkhhc0Vycm9yKCkge1xuICAgIGNvbnN0IHsgcHJldlBhcmVudCB9ID0gdGhpc1xuICAgIHJldHVybiAhcHJldlBhcmVudCB8fCAhcHJldlBhcmVudC5zbHVyLmJlZ2luXG4gIH1cblxuICAvKipcbiAgICogSWYgdGhlIG5leHQgc2x1ciBoYXMgZXJyb3IuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBuZXh0SGFzRXJyb3IoKSB7XG4gICAgY29uc3QgeyBuZXh0UGFyZW50IH0gPSB0aGlzXG4gICAgcmV0dXJuICFuZXh0UGFyZW50IHx8ICFuZXh0UGFyZW50LnNsdXIuZW5kXG4gIH1cblxuICAvKipcbiAgICogSWYgdGhlIHNsdXIgaXMgZW1wdHkuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBpc0VtcHR5KCkgeyByZXR1cm4gISh0aGlzLmJlZ2luIHx8IHRoaXMuZW5kKSB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhlIHNsdXIgdG8gSlNPTiBvYmplY3QuXG4gICAqIEBtZXRob2RcbiAgICogQHJldHVybiB7T2JqZWN0fSBKU09OIG9iamVjdC5cbiAgICovXG4gIHRvSlNPTiA9IG1ha2VUb0pTT04oe1xuICAgIGJlZ2luOiB1bmRlZmluZWQsXG4gICAgZW5kOiB1bmRlZmluZWRcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgU2x1clxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21vZGVsL1NsdXIuanMiLCJpbXBvcnQgeyBleHRlbmQsIG1ha2VUb0pTT04gfSBmcm9tICcuLi91dGlsJ1xuaW1wb3J0IE11c2ljRGF0YSBmcm9tICcuL011c2ljRGF0YSdcbmltcG9ydCBEdXJhdGlvbiBmcm9tICcuL0R1cmF0aW9uJ1xuXG4vKipcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtyZXN0fSByZXN0XG4gKiBAbWl4ZXMgTXVzaWNEYXRhTWl4aW5cbiAqIEBtaXhlcyBNdXNpY0RhdGFMYXlvdXRNaXhpblxuICovXG5jbGFzcyBSZXN0IGV4dGVuZHMgTXVzaWNEYXRhIHtcbiAgY29uc3RydWN0b3IocmVzdCkge1xuICAgIHN1cGVyKClcbiAgICBleHRlbmQodGhpcywgcmVzdClcbiAgfVxuXG4gIC8qKlxuICAgKiBUeXBlIG9mIHJlc3QuXG4gICAqIEBjb25zdGFudFxuICAgKiBAZGVmYXVsdCByZXN0XG4gICAqL1xuICAkdHlwZSA9ICdyZXN0J1xuXG4gIC8qKlxuICAgKiBVbmlxdWUgZGVmIGlkIG9mIHRoZSByZXN0IHVzZWQgaW4gdGhlIFNWRyA8ZGVmcz4gZWxlbWVudC5cbiAgICogYGBgXG4gICAqIGRlZklkIDo9ICdyJyB0eXBlIGRvdFxuICAgKiBgYGBcbiAgICogRS5nLlxuICAgKiBgYGBcbiAgICogUmVzdCAgICAgZGVmSWRcbiAgICogLS0tLS0tLS0tLS0tLS0tLVxuICAgKiAwICAgICAgICByNDBcbiAgICogMCAtICAgICAgcjIwXG4gICAqIDA9LiAgICAgIHIxNjFcbiAgICogYGBgXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGRlZklkKCkge1xuICAgIGNvbnN0IHsgdHlwZSwgZG90IH0gPSB0aGlzLmR1cmF0aW9uXG4gICAgcmV0dXJuIGByJHt0eXBlfSR7ZG90fWBcbiAgfVxuXG4gIC8qKlxuICAgKiBEdXJhdGlvbiBvZiB0aGUgcmVzdC5cbiAgICogQHR5cGUge0R1cmF0aW9ufVxuICAgKi9cbiAgZ2V0IGR1cmF0aW9uKCkgeyByZXR1cm4gdGhpcy5fZHVyYXRpb24gfHwgKHRoaXMuX2R1cmF0aW9uID0gbmV3IER1cmF0aW9uKCkpIH1cbiAgc2V0IGR1cmF0aW9uKGR1cmF0aW9uKSB7IHRoaXMuX2R1cmF0aW9uID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKSB9XG5cbiAgZ2V0IGJlYW1zKCkgeyByZXR1cm4gdGhpcy5fYmVhbXMgfHwgKHRoaXMuX2JlYW1zID0gW10pIH1cbiAgc2V0IGJlYW1zKGJlYW1zKSB7IHRoaXMuX2JlYW1zID0gYmVhbXMgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoZSByZXN0IHRvIG11c2plIHNvdXJjZSBjb2RlIHN0cmluZy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBDb252ZXJ0ZWQgbXVzamUgc291cmNlIGNvZGUuXG4gICAqL1xuICB0b1N0cmluZygpIHsgcmV0dXJuIGAwJHt0aGlzLmR1cmF0aW9ufWAgfVxuXG4gIHRvSlNPTiA9IG1ha2VUb0pTT04oe1xuICAgIGR1cmF0aW9uOiB1bmRlZmluZWQsXG4gIH0sICdyZXN0Jylcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVzdFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21vZGVsL1Jlc3QuanMiLCJpbXBvcnQgeyBleHRlbmQsIG1ha2VUb0pTT04gfSBmcm9tICcuLi91dGlsJ1xuaW1wb3J0IE11c2ljRGF0YSBmcm9tICcuL011c2ljRGF0YSdcbmltcG9ydCBQaXRjaCBmcm9tICcuL1BpdGNoJ1xuaW1wb3J0IER1cmF0aW9uIGZyb20gJy4vRHVyYXRpb24nXG5cbi8qKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge09iamVjdH0gY2hvcmRcbiAqIEBtaXhlcyBNdXNpY0RhdGFNaXhpblxuICogQG1peGVzIE11c2ljRGF0YUxheW91dE1peGluXG4gKi9cbmNsYXNzIENob3JkIGV4dGVuZHMgTXVzaWNEYXRhIHtcbiAgY29uc3RydWN0b3IoY2hvcmQpIHtcbiAgICBzdXBlcigpXG4gICAgZXh0ZW5kKHRoaXMsIGNob3JkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUeXBlIG9mIGNob3JkLlxuICAgKiBAY29uc3RhbnRcbiAgICogQGRlZmF1bHQgY2hvcmRcbiAgICovXG4gICR0eXBlID0gJ2Nob3JkJ1xuXG4gIC8qKlxuICAgKiBQaXRjaGVzIGluIHRoZSBjaG9yZC5cbiAgICogQHR5cGUge0FycmF5LjxQaXRjaD59XG4gICAqL1xuICBnZXQgcGl0Y2hlcygpIHsgcmV0dXJuIHRoaXMuX3BpdGNoZXMgfHwgKHRoaXMuX3BpdGNoZXMgPSBbXSkgfVxuICBzZXQgcGl0Y2hlcyhwaXRjaGVzKSB7IHRoaXMuX3BpdGNoZXMgPSBwaXRjaGVzLm1hcChwaXRjaCA9PiBuZXcgUGl0Y2gocGl0Y2gpKSB9XG5cbiAgLyoqXG4gICAqIER1cmF0aW9uIG9mIHRoZSBjaG9yZC5cbiAgICogQHR5cGUge0R1cmF0aW9ufVxuICAgKi9cbiAgZ2V0IGR1cmF0aW9uKCkgeyByZXR1cm4gdGhpcy5fZHVyYXRpb24gfHwgKHRoaXMuX2R1cmF0aW9uID0gbmV3IER1cmF0aW9uKCkpIH1cbiAgc2V0IGR1cmF0aW9uKGR1cmF0aW9uKSB7IHRoaXMuX2R1cmF0aW9uID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKSB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgY2hvcmQgdG8gdGhlIG11c2plIHNvdXJjZSBjb2RlIHN0cmluZy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBDb252ZXJ0ZWQgbXVzamUgc291cmNlIGNvZGUgb2YgdGhlIGNob3JkLlxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICc8JyArIHRoaXMucGl0Y2hlcy5tYXAocGl0Y2ggPT4gcGl0Y2gudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcnKSArICc+JyArIHRoaXMuZHVyYXRpb25cbiAgfVxuXG4gIHRvSlNPTiA9IG1ha2VUb0pTT04oe1xuICAgIHBpdGNoZXM6IHVuZGVmaW5lZCxcbiAgICBkdXJhdGlvbjogdW5kZWZpbmVkLFxuICB9LCAnY2hvcmQnKVxufVxuXG5leHBvcnQgZGVmYXVsdCBDaG9yZFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21vZGVsL0Nob3JkLmpzIiwiaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnLi4vdXRpbCdcbmltcG9ydCBNdXNpY0RhdGEgZnJvbSAnLi9NdXNpY0RhdGEnXG5cbi8qKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge09iamVjdH0gdm9pY2VcbiAqL1xuY2xhc3MgVm9pY2UgZXh0ZW5kcyBNdXNpY0RhdGEge1xuICBjb25zdHJ1Y3Rvcih2b2ljZSkge1xuICAgIHN1cGVyKClcbiAgICBleHRlbmQodGhpcywgdm9pY2UpXG4gIH1cblxuICAvKipcbiAgICogVHlwZSBvZiB2b2ljZS5cbiAgICogQGNvbnN0YW50XG4gICAqIEBkZWZhdWx0IHZvaWNlXG4gICAqL1xuICAkdHlwZSA9ICd2b2ljZSdcblxuICAvKipcbiAgICogQ29udmVydCB0aGUgdm9pY2UgdG8gbXVzamUgc291cmNlIGNvZGUgc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbnZlcnRlZCBtdXNqZSBzb3VyY2UgY29kZSBzdHJpbmcuXG4gICAqL1xuICB0b1N0cmluZygpIHtcblxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZvaWNlXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbW9kZWwvVm9pY2UuanMiLCIvKipcbiAqIEEgW2JlYW1dW3dpa2ldIGlzIGEgaG9yaXpvbnRhbCBvciBkaWFnb25hbCBsaW5lIHVzZWQgdG8gY29ubmVjdCBtdWx0aXBsZSBjb25zZWN1dGl2ZSBub3RlcyAoYW5kIG9jY2FzaW9uYWxseSByZXN0cykgaW4gb3JkZXIgdG8gaW5kaWNhdGUgcmh5dGhtaWMgZ3JvdXBpbmcuIE9ubHkgZWlnaHRoIG5vdGVzIChxdWF2ZXJzKSBvciBzaG9ydGVyIGNhbiBiZSBiZWFtZWQuXG4gKlxuICogW3dpa2ldOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CZWFtXyhtdXNpYylcbiAqXG4gKiBCZWFtIGlzIGNyZWF0ZWQgYnkge0BsaW5rIENlbGwjbWFrZUJlYW1zfSBhbmRcbiAqIGF0dGFjaGVkIHRvIHtAbGluayBEdXJhYmxlfSBpbiB7QGxpbmsgRHVyYWJsZSNiZWFtc31bbGV2ZWxdXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIEJlYW0gdmFsdWU6IGAnYmVnaW4nYCwgYCdjb250aW51ZSdgIG9yIGAnZW5kJ2AuXG4gKiBAcGFyYW0ge251bWJlcn0gbGV2ZWwgLSBCZWFtIGxldmVsIHN0YXJ0aW5nIGZyb20gMCB0byB1cC5cbiAqIEBwYXJhbSB7RHVyYWJsZX0gcGFyZW50IC0gVGhlIHBhcmVudCBkdXJhYmxlIG11c2ljIGRhdGEuXG4gKi9cbmNsYXNzIEJlYW0ge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgbGV2ZWwsIHBhcmVudCkge1xuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWVcbiAgICB0aGlzLl9sZXZlbCA9IGxldmVsXG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50XG4gIH1cblxuICAvKipcbiAgICogUGFyZW50XG4gICAqIEB0eXBlIHtOb3RlfFJlc3R8Q2hvcmR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHBhcmVudCgpIHsgcmV0dXJuIHRoaXMuX3BhcmVudCB9XG5cbiAgLyoqXG4gICAqIEJlYW0gdmFsdWU6IGAnYmVnaW4nYCwgYCdjb250aW51ZSdgIG9yIGAnZW5kJ2AuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHZhbHVlKCkgeyByZXR1cm4gdGhpcy5fdmFsdWUgfVxuXG4gIC8qKlxuICAgKiBCZWFtIGxldmVsIHN0YXJ0aW5nIGZyb20gMCB0byB1cC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgbGV2ZWwoKSB7IHJldHVybiB0aGlzLl9sZXZlbCB9XG5cbiAgLyoqXG4gICAqIFRoZSBlbmQgcGFyZW50IG11c2ljIGRhdGEgb2YgdGhlIGJlYW0gZ3JvdXAuXG4gICAqIEB0eXBlIHtNdXNpY0RhdGFNaXhpbn1cbiAgICovXG4gIGdldCBlbmREdXJhYmxlKCkge1xuICAgIGxldCBuZXh0RGF0YSA9IHRoaXMucGFyZW50Lm5leHRcbiAgICB3aGlsZSAobmV4dERhdGEgJiYgbmV4dERhdGEuYmVhbXNbdGhpcy5sZXZlbF0udmFsdWUgIT09ICdlbmQnKSB7XG4gICAgICBuZXh0RGF0YSA9IG5leHREYXRhLm5leHRcbiAgICB9XG4gICAgcmV0dXJuIG5leHREYXRhXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmVhbVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21vZGVsL0JlYW0uanMiLCJpbXBvcnQgVGltZXdpc2VNZWFzdXJlIGZyb20gJy4vVGltZXdpc2VNZWFzdXJlJ1xuXG4vKipcbiAqIENvbnN0cnVjdCB0aW1ld2lzZSBzY29yZSBtZWFzdXJlcy5cbiAqIEBjbGFzc1xuICogQGNsYXNzZGVzYyBUaW1ld2lzZSBzY29yZSBtZWFzdXJlcy5cbiAqIEBwYXJhbSBzY29yZSB7U2NvcmV9XG4gKiBAYXVnbWVudHMge0FycmF5fVxuICovXG5jbGFzcyBUaW1ld2lzZU1lYXN1cmVzIGV4dGVuZHMgQXJyYXkge1xuICBjb25zdHJ1Y3RvcihzY29yZSkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9zY29yZSA9IHNjb3JlXG4gIH1cblxuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgc2NvcmUuXG4gICAqIEB0eXBlIHtTY29yZX1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgc2NvcmUoKSB7IHJldHVybiB0aGlzLl9zY29yZSB9XG5cbiAgLyoqXG4gICAqIE1ha2UgdGltZXdpc2Ugc2NvcmUgbWVhc3VyZXMgZnJvbSB0aGUgcGFydHdpc2UgcGFydHMuXG4gICAqL1xuICBmcm9tUGFydHdpc2UoKSB7XG4gICAgdGhpcy5yZW1vdmVBbGwoKVxuICAgIHRoaXMuc2NvcmUud2Fsa0NlbGxzKChjZWxsLCBtKSA9PiB7XG4gICAgICBpZiAobSA9PT0gdGhpcy5sZW5ndGggJiYgIXRoaXNbbV0pIHRoaXMucHVzaChuZXcgVGltZXdpc2VNZWFzdXJlKG0sIHRoaXMpKVxuICAgICAgdGhpc1ttXS5wYXJ0cy5wdXNoKGNlbGwpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIG1lYXN1cmVzLlxuICAgKi9cbiAgcmVtb3ZlQWxsKCkgeyB0aGlzLmxlbmd0aCA9IDAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUaW1ld2lzZU1lYXN1cmVzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbW9kZWwvVGltZXdpc2VNZWFzdXJlcy5qcyIsImltcG9ydCB7IG1hdHJpeCB9IGZyb20gJ3NuYXBzdmcnXG5cbi8qKlxuICogQGNsYXNzXG4gKiBAcGFyYW0gbWVhc3VyZSB7T2JqZWN0fVxuICogQG1peGVzIFRpbWV3aXNlTWVhc3VyZUxheW91dE1peGluXG4gKi9cbmNsYXNzIFRpbWV3aXNlTWVhc3VyZSB7XG4gIGNvbnN0cnVjdG9yKGluZGV4LCBtZWFzdXJlcykge1xuICAgIC8vIHRoaXMuX2luZGV4ID0gaW5kZXhcbiAgICB0aGlzLl9tZWFzdXJlcyA9IG1lYXN1cmVzXG4gIH1cblxuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgbWVhc3VyZXMgaW5zdGFuY2UuXG4gICAqIEBtZW1iZXIge1RpbWV3aXNlTWVhc3VyZXN9XG4gICAqL1xuICBnZXQgbWVhc3VyZXMoKSB7IHJldHVybiB0aGlzLl9tZWFzdXJlcyB9XG5cbiAgLyoqXG4gICAqIFBhcnRzIGluIHRpbWV3aXNlIG1lYXN1cmUuXG4gICAqIEB0eXBlIHtBcnJheS48Q2VsbD59XG4gICAqL1xuICBnZXQgcGFydHMoKSB7IHJldHVybiB0aGlzLl9wYXJ0cyB8fCAodGhpcy5fcGFydHMgPSBbXSkgfVxuICBzZXQgcGFydHMocGFydHMpIHsgdGhpcy5fcGFydHMgPSBwYXJ0cyB9XG5cbiAgLyoqXG4gICAqIExlZnQgYmFyIG9mIHRoZSBtZWFzdXJlLlxuICAgKiBAdHlwZSB7QmFyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBiYXJMZWZ0KCkgeyByZXR1cm4gdGhpcy5wYXJ0c1swXS5iYXJMZWZ0IH1cblxuICAvKipcbiAgICogUmlnaHQgYmFyIG9mIHRoZSBtZWFzdXJlLlxuICAgKiBAdHlwZSB7QmFyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBiYXJSaWdodCgpIHsgcmV0dXJuIHRoaXMucGFydHNbMF0uYmFyUmlnaHQgfVxuXG5cbiAgLyoqXG4gICAqIE1lYXN1cmUgU1ZHIGdyb3VwIGVsZW1lbnQuXG4gICAqIEB0eXBlIHtTbmFwLkVsZW1lbnR9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGVsKCkgeyByZXR1cm4gdGhpcy5fZWwgfVxuXG4gIC8qKlxuICAgKiBNaW5pbXVuIHdpZHRoIG9mIHRoZSBtZWFzdXJlLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pbldpZHRoKCkge1xuICAgIHZhciBtaW5XaWR0aCA9IDBcbiAgICB0aGlzLnBhcnRzLmZvckVhY2goZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgIG1pbldpZHRoID0gTWF0aC5tYXgobWluV2lkdGgsIGNlbGwubWluV2lkdGgpXG4gICAgfSlcbiAgICByZXR1cm4gbWluV2lkdGggKyB0aGlzLnBhZGRpbmdcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBzeXN0ZW0gb2YgdGhpcyBtZWFzdXJlLlxuICAgKiAtIChHZXR0ZXIpXG4gICAqIC0gKFNldHRlcikgVGhlIG1lYXN1cmUgZWwgd2lsbCBiZSBjcmVhdGVkLCBhbmQgdGhlIGhlaWdodCBvZiB0aGUgbWVhc3VyZSB3aWxsIGJlIHNldC5cbiAgICogQHR5cGUge1N5c3RlbUxheW91dH1cbiAgICovXG4gIGdldCBzeXN0ZW0oKSB7IHJldHVybiB0aGlzLl9zIH1cbiAgc2V0IHN5c3RlbShzeXN0ZW0pIHtcbiAgICB0aGlzLl9zID0gc3lzdGVtXG4gICAgdGhpcy5fZWwgPSBzeXN0ZW0uZWwuZygpLmFkZENsYXNzKCdtdXMtbWVhc3VyZScpXG4gIH1cblxuICBnZXQgcGFkZGluZygpIHtcbiAgICBjb25zdCBsbyA9IHRoaXMubGF5b3V0Lm9wdGlvbnNcbiAgICByZXR1cm4gbG8ubWVhc3VyZVBhZGRpbmdSaWdodCArIGxvLm1lYXN1cmVQYWRkaW5nTGVmdFxuICB9XG5cbiAgZ2V0IG91dGVyV2lkdGgoKSB7IHJldHVybiB0aGlzLm91dGVyV2lkdGhMZWZ0ICsgdGhpcy5vdXRlcldpZHRoUmlnaHQgfVxuXG4gIGdldCBvdXRlcldpZHRoTGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXlvdXQub3B0aW9ucy5tZWFzdXJlUGFkZGluZ0xlZnQgK1xuICAgICAgICAgICAgdGhpcy5iYXJMZWZ0SW5TeXN0ZW0ud2lkdGggLyAyXG4gIH1cblxuICBnZXQgb3V0ZXJXaWR0aFJpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmxheW91dC5vcHRpb25zLm1lYXN1cmVQYWRkaW5nUmlnaHQgK1xuICAgICAgICAgICAgdGhpcy5iYXJSaWdodEluU3lzdGVtLndpZHRoIC8gMlxuICB9XG5cbiAgLyoqXG4gICAqIFdpZHRoIG9mIHRoZSBtZWFzdXJlLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdpZHRoKCkgeyByZXR1cm4gdGhpcy5fdyB8fCAodGhpcy5fdyA9IHRoaXMubWluV2lkdGgpIH1cbiAgc2V0IHdpZHRoKHcpIHtcbiAgICB0aGlzLl93ID0gd1xuICAgIHRoaXMucGFydHMuZm9yRWFjaChjZWxsID0+IHsgY2VsbC53aWR0aCA9IHcgLSB0aGlzLm91dGVyV2lkdGggfSlcbiAgfVxuXG4gIGdldCBoZWlnaHQoKSB7IHJldHVybiB0aGlzLnN5c3RlbS5oZWlnaHQgfVxuXG4gIGdldCBtaW5IZWlnaHQoKSB7XG4gICAgY29uc3QgeyBwYXJ0U2VwIH0gPSB0aGlzLmxheW91dC5vcHRpb25zXG4gICAgbGV0IG1pbkhlaWdodCA9IDBcblxuICAgIHRoaXMucGFydHMuZm9yRWFjaChjZWxsID0+IHsgbWluSGVpZ2h0ICs9IGNlbGwuaGVpZ2h0ICsgcGFydFNlcCB9KVxuICAgIHJldHVybiBtaW5IZWlnaHQgPyBtaW5IZWlnaHQgLSBwYXJ0U2VwIDogMFxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBtZWFzdXJlIGluIHRoZSBzeXN0ZW0uXG4gICAqIC0gKEdldHRlcilcbiAgICogLSAoU2V0dGVyKSBTZXQgeCBjYXVzZSB0aGUgbWVhc3VyZSBlbGVtZW50IHRvIHRyYW5zbGF0ZS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB4KCkgeyByZXR1cm4gdGhpcy5feCB9XG4gIHNldCB4KHgpIHtcbiAgICB0aGlzLl94ID0geFxuICAgIHRoaXMuZWwudHJhbnNmb3JtKFNuYXAubWF0cml4KCkudHJhbnNsYXRlKHgsIDApKVxuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSBtZWFzdXJlIGluIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHN5c3RlbS5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGluU3lzdGVtQmVnaW4oKSB7IHJldHVybiB0aGlzLl9zSW5kZXggPT09IDAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgbWVhc3VyZSBpbiB0aGUgZW5kIG9mIHRoZSBzeXN0ZW0uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBpblN5c3RlbUVuZCgpIHsgcmV0dXJuIHRoaXMuX3NJbmRleCA9PT0gdGhpcy5zeXN0ZW0ubWVhc3VyZXMubGVuZ3RoIC0gMSB9XG5cbiAgLyoqXG4gICAqIExlZnQgYmFyIG9mIHRoZSBtZWFzdXJlIGluIHN5c3RlbS5cbiAgICogQHR5cGUge211c2plLkJhcn1cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgYmFyTGVmdEluU3lzdGVtKCkgeyByZXR1cm4gdGhpcy5wYXJ0c1swXS5iYXJMZWZ0SW5TeXN0ZW0gfVxuXG4gIC8qKlxuICAgKiBSaWdodCBiYXIgb2YgdGhlIG1lYXN1cmUgaW4gc3lzdGVtLlxuICAgKiBAdHlwZSB7QmFyfVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBiYXJSaWdodEluU3lzdGVtKCkgeyByZXR1cm4gdGhpcy5wYXJ0c1swXS5iYXJSaWdodEluU3lzdGVtIH1cblxuICAvKipcbiAgICogRmxvdyB0aGUgbWVhc3VyZS5cbiAgICovXG4gIGZsb3coKSB7XG4gICAgdGhpcy5wYXJ0cy5mb3JFYWNoKGNlbGwgPT4ge1xuXG4gICAgICAvKipcbiAgICAgICAqIENlbGwgU1ZHIGdyb3VwIGVsZW1lbnQuXG4gICAgICAgKiBAbWVtYmVyb2YgQ2VsbExheW91dCNcbiAgICAgICAqIEBhbGlhcyBlbFxuICAgICAgICogQHR5cGUge1NuYXAuRWxlbWVudH1cbiAgICAgICAqIEByZWFkb25seVxuICAgICAgICovXG4gICAgICBjZWxsLmVsID0gdGhpcy5lbC5nKCkuYWRkQ2xhc3MoJ211cy1jZWxsJylcblxuICAgICAgY2VsbC54ID0gdGhpcy5vdXRlcldpZHRoTGVmdFxuXG4gICAgICAvLyBjZWxsLmRyYXdCb3goKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRHJhdyBib3ggb2YgdGhlIGNlbGwuXG4gICAqIEByZXR1cm4ge1NuYXAuRWxlbWVudH0gVGhlIGJveCBTVkcgcmVjdCBlbGVtZW50LlxuICAgKi9cbiAgZHJhd0JveCgpIHtcbiAgICB0aGlzLl9ib3hFbCA9IHRoaXMuZWwucmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cih7IHN0cm9rZTogJ2dyZWVuJywgZmlsbDogJ25vbmUnIH0pXG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgdGhlIGJveCBTVkcgZWxlbWVudC5cbiAgICovXG4gIGNsZWFyQm94KCkge1xuICAgIHRoaXMuX2JveEVsLnJlbW92ZSgpXG4gICAgdGhpcy5fYm94RWwgPSB1bmRlZmluZWRcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUaW1ld2lzZU1lYXN1cmVcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tb2RlbC9UaW1ld2lzZU1lYXN1cmUuanMiLCJpbXBvcnQgeyBtYXRyaXggfSBmcm9tICdzbmFwc3ZnJ1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnLi4vLi4vdXRpbCdcbmltcG9ydCBMYXlvdXQgZnJvbSAnLi4vTGF5b3V0L0xheW91dCdcbmltcG9ydCByZW5kZXJCYXIgZnJvbSAnLi9yZW5kZXJCYXInXG5pbXBvcnQgcmVuZGVyRHVyYXRpb24gZnJvbSAnLi9yZW5kZXJEdXJhdGlvbidcbmltcG9ydCByZW5kZXJDdXJ2ZSBmcm9tICcuL3JlbmRlckN1cnZlJ1xuXG5jbGFzcyBSZW5kZXJlciB7XG4gIGNvbnN0cnVjdG9yKHN2ZywgbG8pIHtcbiAgICB0aGlzLl9sbyA9IGV4dGVuZChMYXlvdXQub3B0aW9ucywgbG8pXG4gICAgdGhpcy5sYXlvdXQgPSBuZXcgTGF5b3V0KHN2ZywgdGhpcy5fbG8pXG4gIH1cblxuICByZW5kZXIoc2NvcmUpIHtcbiAgICB0aGlzLl9zY29yZSA9IHNjb3JlXG4gICAgdGhpcy5sYXlvdXQuZmxvdyhzY29yZSlcbiAgICB0aGlzLnJlbmRlckhlYWRlcigpXG4gICAgdGhpcy5yZW5kZXJDb250ZW50KClcbiAgfVxuXG4gIHJlbmRlckhlYWRlcigpIHtcbiAgICBjb25zdCBsbyA9IHRoaXMuX2xvXG4gICAgY29uc3QgeyBoZWFkZXIgfSA9IHRoaXMubGF5b3V0XG4gICAgY29uc3QgeyBlbCwgd2lkdGggfSA9IGhlYWRlclxuXG4gICAgZWwudGV4dCh3aWR0aC8yLCBsby50aXRsZUZvbnRTaXplLCB0aGlzLl9zY29yZS5oZWFkLnRpdGxlKS5hdHRyKHtcbiAgICAgIGZvbnRTaXplOiBsby50aXRsZUZvbnRTaXplICogMixcbiAgICAgIGZvbnRXZWlnaHQ6IGxvLnRpdGxlRm9udFdlaWdodCxcbiAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnXG4gICAgfSlcblxuICAgIGVsLnRleHQod2lkdGgsIGxvLnRpdGxlRm9udFNpemUgKiAxLjUsIHRoaXMuX3Njb3JlLmhlYWQuY29tcG9zZXIpLmF0dHIoe1xuICAgICAgZm9udFNpemU6IGxvLmNvbXBvc2VyRm9udFNpemUsXG4gICAgICBmb250V2VpZ2h0OiBsby5jb21wb3NlckZvbnRXZWlnaHQsXG4gICAgICB0ZXh0QW5jaG9yOiAnZW5kJ1xuICAgIH0pXG5cbiAgICBoZWFkZXIuaGVpZ2h0ID0gZWwuZ2V0QkJveCgpLmhlaWdodFxuICB9XG5cbiAgcmVuZGVyQ29udGVudCgpIHtcbiAgICBjb25zdCBsbyA9IHRoaXMuX2xvXG5cbiAgICB0aGlzLmxheW91dC5jb250ZW50LnN5c3RlbXMuZm9yRWFjaChzeXN0ZW0gPT4ge1xuICAgICAgY29uc3QgeyBtZWFzdXJlcyB9ID0gc3lzdGVtXG4gICAgICBtZWFzdXJlcy5mb3JFYWNoKG1lYXN1cmUgPT4ge1xuICAgICAgICByZW5kZXJCYXIobWVhc3VyZSwgbG8pXG4gICAgICAgIG1lYXN1cmUucGFydHMuZm9yRWFjaChjZWxsID0+IHsgcmVuZGVyQ2VsbChjZWxsLCBsbykgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJOb3RlKG5vdGUsIGNlbGwsIGxvKSB7XG4gIG5vdGUuZWwgPSBjZWxsLmVsLmcoKS50cmFuc2Zvcm0obWF0cml4KCkudHJhbnNsYXRlKG5vdGUueCwgbm90ZS55KSlcbiAgbm90ZS5lbC51c2Uobm90ZS5kZWYucGl0Y2hEZWYuZWwpXG4gIHJlbmRlckR1cmF0aW9uKG5vdGUsIGxvKVxufVxuXG5mdW5jdGlvbiByZW5kZXJDZWxsKGNlbGwsIGxvKSB7XG4gIGNlbGwuZGF0YS5mb3JFYWNoKGRhdGEgPT4ge1xuICAgIHN3aXRjaCAoZGF0YS4kdHlwZSkge1xuICAgICAgY2FzZSAncmVzdCc6XG4gICAgICAgIHJlbmRlck5vdGUoZGF0YSwgY2VsbCwgbG8pXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdub3RlJzpcbiAgICAgICAgcmVuZGVyTm90ZShkYXRhLCBjZWxsLCBsbylcbiAgICAgICAgcmVuZGVyQ3VydmUoJ3RpZScsIGRhdGEpXG4gICAgICAgIHJlbmRlckN1cnZlKCdzbHVyJywgZGF0YSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3RpbWUnOlxuICAgICAgICBkYXRhLmVsID0gY2VsbC5lbC51c2UoZGF0YS5kZWYuZWwpLmF0dHIoeyB4OiBkYXRhLngsIHk6IGRhdGEueSB9KVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlbmRlcmVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVuZGVyZXIvUmVuZGVyZXIvUmVuZGVyZXIuanMiLCJpbXBvcnQgbGF5b3V0T3B0aW9ucyBmcm9tICcuL2xheW91dE9wdGlvbnMnXG5pbXBvcnQgRGVmcyBmcm9tICcuLi9kZWZzL0RlZnMnXG5pbXBvcnQgU3ZnTGF5b3V0IGZyb20gJy4vU3ZnTGF5b3V0J1xuaW1wb3J0IEJvZHlMYXlvdXQgZnJvbSAnLi9Cb2R5TGF5b3V0J1xuaW1wb3J0IEhlYWRlckxheW91dCBmcm9tICcuL0hlYWRlckxheW91dCdcbmltcG9ydCBDb250ZW50TGF5b3V0IGZyb20gJy4vQ29udGVudExheW91dCdcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSBzdmcge3N0cmluZ31cbiAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9IExheW91dCBvcHRpb25zXG4gKi9cbmNsYXNzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHN2Zywgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLnN2ZyA9IHN2Z1xuXG4gICAgdGhpcy5zdmcgPSBuZXcgU3ZnTGF5b3V0KHRoaXMpXG4gICAgdGhpcy5ib2R5ID0gbmV3IEJvZHlMYXlvdXQodGhpcylcbiAgICB0aGlzLmhlYWRlciA9IG5ldyBIZWFkZXJMYXlvdXQodGhpcylcbiAgICB0aGlzLmNvbnRlbnQgPSBuZXcgQ29udGVudExheW91dCh0aGlzKVxuXG4gICAgdGhpcy5kZWZzID0gbmV3IERlZnModGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtTY29yZX0gc2NvcmVcbiAgICovXG4gIGZsb3coc2NvcmUpIHtcbiAgICBpbml0KHRoaXMsIHNjb3JlKVxuICAgIHRoaXMuY29udGVudC5mbG93KHNjb3JlLm1lYXN1cmVzKVxuICB9XG59XG5cbkxheW91dC5vcHRpb25zID0gbGF5b3V0T3B0aW9uc1xuXG5mdW5jdGlvbiBpbml0KHRoYXQsIHNjb3JlKSB7XG4gIGNvbnN0IHsgbWVhc3VyZXMgfSA9IHNjb3JlXG4gIG1lYXN1cmVzLmZvckVhY2goKG1lYXN1cmUsIG0pID0+IHtcbiAgICBtZWFzdXJlID0gbWVhc3VyZXNbbV1cbiAgICBtZWFzdXJlLmxheW91dCA9IHRoYXRcbiAgICBtZWFzdXJlLnBhcnRzLmZvckVhY2goY2VsbCA9PiB7XG4gICAgICBjZWxsLmxheW91dCA9IHRoYXRcbiAgICAgIGNlbGwuZmxvdygpXG4gICAgfSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgTGF5b3V0XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVuZGVyZXIvTGF5b3V0L0xheW91dC5qcyIsImltcG9ydCB7IG9iakVhY2ggfSBmcm9tICcuLi8uLi91dGlsJ1xuXG5jb25zdCBsYXlvdXRPcHRpb25zID0ge1xuICBtb2RlOiAnYmxvY2snLCAvLyBpbmxpbmUgfCBibG9jayB8IHBhcGVyXG4gIC8vIHdpZHRoOiA2NTAsXG4gIC8vIGhlaWdodDogNjAwLFxuICBtYXJnaW5Ub3A6IDI1LFxuICBtYXJnaW5SaWdodDogMzAsXG4gIG1hcmdpbkJvdHRvbTogMjUsXG4gIG1hcmdpbkxlZnQ6IDMwLFxuXG4gIGZvbnRTaXplOiAyMCxcbiAgZm9udEZhbWlseTogJ0hlbHZldGljYSwgQXJpYWwsIFNhbnMgU2VyaWYnLFxuXG4gIHRpdGxlRm9udFNpemU6ICcxMTAlJyxcbiAgLy8gdGl0bGVGb250RmFtaWx5XG4gIHRpdGxlRm9udFdlaWdodDogJ2JvbGQnLFxuICBjb21wb3NlckZvbnRTaXplOiAnOTAlJyxcbiAgLy8gY29tcG9zZXJGb250RmFtaWx5OlxuICBjb21wb3NlckZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgLy8gY29tcG9zZXJGb250U3R5bGUsXG4gIHRpbWVGb250U2l6ZTogJzk1JScsXG4gIHRpbWVGb250V2VpZ2h0OiAnYm9sZCcsXG5cbiAgaGVhZGVyU2VwOiAnMTAwJScsXG4gIHN5c3RlbVNlcDogJzE4MCUnLFxuICBtdXNpY0RhdGFTZXA6ICcyMCUnLFxuXG4gIHBhcnRIZWlnaHQ6ICcxMjAlJyxcbiAgcGFydFNlcDogJzgwJScsXG5cbiAgbWVhc3VyZVBhZGRpbmdMZWZ0OiAnNTAlJyxcbiAgbWVhc3VyZVBhZGRpbmdSaWdodDogJzUwJScsXG5cbiAgYmFybGluZUhlaWdodDogJzEyMCUnLFxuICB0aGluQmFybGluZVdpZHRoOiAnNCUnLFxuICB0aGlja0JhcmxpbmVXaWR0aDogJzE2JScsXG4gIGJhcmxpbmVTZXA6ICcxOCUnLFxuICBiYXJsaW5lRG90UmFkaXVzOiAnNy41JScsXG4gIGJhcmxpbmVEb3RTZXA6ICcyMiUnLFxuXG4gIGFjY2lkZW50YWxGb250U2l6ZTogJzk1JScsXG4gIGFjY2lkZW50YWxTaGlmdDogJzEwJScsXG5cbiAgb2N0YXZlUmFkaXVzOiAnNi42JScsXG4gIG9jdGF2ZU9mZnNldDogJzAlJyxcbiAgb2N0YXZlU2VwOiAnMjMlJyxcblxuICBzdGVwQmFzZWxpbmVTaGlmdDogJzEyJScsICAvLyBmb3Igc3RlcCB3aXRob3V0IGxvd2VyIG9jdGF2ZSBhbmQgdW5kZXJsaW5lXG5cbiAgdHlwZVN0cm9rZVdpZHRoOiAnNSUnLFxuICB0eXBlYmFyT2Zmc2V0OiAnMzAlJywgICAvLyAxIC0gLSAtXG4gIHR5cGViYXJMZW5ndGg6ICc1NSUnLCAgIC8vIG9mZiBsZW4gc2VwIGxlbiBzZXAgbGVuIChkb3QpIGV4dFxuICB0eXBlYmFyU2VwOiAnNDUlJywgICAgICAvLyAxIC1cbiAgdHlwZWJhckV4dDogJzIwJScsICAgICAgLy8gb2ZmIGxlbiAoZG90KSBleHRcbiAgdW5kZXJiYXJTZXA6ICcxNyUnLFxuXG4gIGRvdE9mZnNldDogJzYwJScsICAgICAgIC8vIGZvciB0eXBlID0gMlxuICBkb3RSYWRpdXM6ICc2LjYlJywgICAgICAvLyAxIC0gLiAuXG4gIGRvdFNlcDogJzYwJScsICAgICAgICAgIC8vIG9mZiBsZW4gZG90T2ZmIC4gZG90U2VwIC4gZXh0XG4gIHQ0RG90T2Zmc2V0OiAnMzAlJyxcbiAgdDREb3RTZXA6ICc1MCUnLFxuICB0NERvdEV4dDogJzI1JScsXG4gIHQ0RG90QmFzZWxpbmVTaGlmdDogJzIwJSdcbn1cblxuY29uc3QgeyBmb250U2l6ZSB9ID0gbGF5b3V0T3B0aW9uc1xuXG5vYmpFYWNoKGxheW91dE9wdGlvbnMsICh2YWx1ZSwga2V5KSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSByZXR1cm5cblxuICBjb25zdCB1bml0ID0gdmFsdWUucmVwbGFjZSgvW1xcZFxcLl0rLywgJycpXG4gIHZhbHVlID0gK3ZhbHVlLnJlcGxhY2UoL1teXFxkXFwuXSsvLCAnJylcblxuICBzd2l0Y2ggKHVuaXQpIHtcbiAgICBjYXNlICclJzpcbiAgICAgIGxheW91dE9wdGlvbnNba2V5XSA9IGZvbnRTaXplICogdmFsdWUgLyAxMDBcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnJzpcbiAgICAgIC8vIGZhbGwgdGhyb3VnaFxuICAgIGNhc2UgJ3B4JzpcbiAgICAgIGxheW91dE9wdGlvbnNba2V5XSA9IHZhbHVlXG4gICAgICBicmVha1xuICAgIGNhc2UgJ290aGVycyB0byBiZSBpbXBsZW1lbnRlZCc6XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gIH1cbn0pXG5cbmV4cG9ydCBkZWZhdWx0IGxheW91dE9wdGlvbnNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZW5kZXJlci9MYXlvdXQvbGF5b3V0T3B0aW9ucy5qcyIsImltcG9ydCBBY2NpZGVudGFsRGVmIGZyb20gJy4vQWNjaWRlbnRhbERlZidcbmltcG9ydCBCYXJEZWYgZnJvbSAnLi9CYXJEZWYnXG5pbXBvcnQgRHVyYXRpb25EZWYgZnJvbSAnLi9EdXJhdGlvbkRlZidcbmltcG9ydCBQaXRjaERlZiBmcm9tICcuL1BpdGNoRGVmJ1xuaW1wb3J0IFRpbWVEZWYgZnJvbSAnLi9UaW1lRGVmJ1xuaW1wb3J0IE5vdGUgZnJvbSAnLi4vLi4vbW9kZWwvTm90ZSdcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7TGF5b3V0fSBsYXlvdXRcbiAqL1xuY2xhc3MgRGVmcyB7XG4gIGNvbnN0cnVjdG9yKGxheW91dCkge1xuICAgIHRoaXMuX2xheW91dCA9IGxheW91dFxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3ZnIGRlZiBvZiB0aGUgbXVzaWMgZGF0YS5cbiAgICogQHBhcmFtICBtdXNpY0RhdGEge011c2ljRGF0YU1peGlufSBtdXNpYyBkYXRhXG4gICAqIEByZXR1cm4ge0RlZn1cbiAgICovXG4gIGdldChtdXNpY0RhdGEpIHtcbiAgICB2YXIgaWQgPSBtdXNpY0RhdGEuZGVmSWRcbiAgICByZXR1cm4gdGhpc1tpZF0gfHwgKHRoaXNbaWRdID0gbWFrZURlZihpZCwgbXVzaWNEYXRhLCB0aGlzKSlcbiAgfVxuXG4gIGdldEFjY2lkZW50YWwoYWNjaWRlbnRhbCkge1xuICAgIHZhciBpZCA9ICdhJyArIGFjY2lkZW50YWwucmVwbGFjZSgvIy9nLCAncycpXG4gICAgcmV0dXJuIHRoaXNbaWRdIHx8XG4gICAgICAgICAgKHRoaXNbaWRdID0gbmV3IEFjY2lkZW50YWxEZWYoaWQsIGFjY2lkZW50YWwsIHRoaXMuX2xheW91dCkpXG4gIH1cblxuICBfZ2V0UGl0Y2goaWQsIHBpdGNoLCB1bmRlcmJhcikge1xuICAgIHJldHVybiB0aGlzW2lkXSB8fFxuICAgICAgICAgICh0aGlzW2lkXSA9IG5ldyBQaXRjaERlZihpZCwgcGl0Y2gsIHVuZGVyYmFyLCB0aGlzKSlcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIG1ha2VEZWYoaWQsIG11c2ljRGF0YSwgZGVmcykge1xuICBzd2l0Y2ggKG11c2ljRGF0YS4kdHlwZSkge1xuICAgIGNhc2UgJ2Jhcic6XG4gICAgICByZXR1cm4gbmV3IEJhckRlZihpZCwgbXVzaWNEYXRhLCBkZWZzLl9sYXlvdXQpXG4gICAgY2FzZSAndGltZSc6XG4gICAgICByZXR1cm4gbmV3IFRpbWVEZWYoaWQsIG11c2ljRGF0YSwgZGVmcy5fbGF5b3V0KVxuICAgIGNhc2UgJ25vdGUnOlxuICAgICAgcmV0dXJuIG1ha2VOb3RlRGVmKG11c2ljRGF0YSwgZGVmcylcbiAgICBjYXNlICdyZXN0JzpcbiAgICAgIHJldHVybiBtYWtlUmVzdERlZihtdXNpY0RhdGEsIGRlZnMpXG4gICAgY2FzZSAnZHVyYXRpb24nOlxuICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbkRlZihpZCwgbXVzaWNEYXRhLCBkZWZzLl9sYXlvdXQpXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VOb3RlRGVmKG5vdGUsIGRlZnMpIHtcbiAgY29uc3QgdW5kZXJiYXIgPSBub3RlLmR1cmF0aW9uLnVuZGVyYmFyXG4gIGNvbnN0IHBpdGNoSWQgPSBub3RlLnBpdGNoLmRlZklkICsgdW5kZXJiYXJcbiAgY29uc3QgcGl0Y2hEZWYgPSBkZWZzLl9nZXRQaXRjaChwaXRjaElkLCBub3RlLnBpdGNoLCB1bmRlcmJhcilcbiAgY29uc3QgZHVyYXRpb25EZWYgPSBkZWZzLmdldChub3RlLmR1cmF0aW9uKVxuICByZXR1cm4ge1xuICAgIHBpdGNoRGVmOiBwaXRjaERlZixcbiAgICBkdXJhdGlvbkRlZjogZHVyYXRpb25EZWYsXG4gICAgaGVpZ2h0OiBwaXRjaERlZi5oZWlnaHQsXG4gICAgd2lkdGg6IHBpdGNoRGVmLndpZHRoICsgZHVyYXRpb25EZWYud2lkdGggKiAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKHVuZGVyYmFyID8gcGl0Y2hEZWYuc2NhbGUueCA6IDEpXG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZVJlc3REZWYocmVzdCwgZGVmcykge1xuICBjb25zdCByZXN0Tm90ZSA9IG5ldyBOb3RlKHsgcGl0Y2g6IHsgc3RlcDogMCB9LCBkdXJhdGlvbjogcmVzdC5kdXJhdGlvbiB9KVxuICByZXR1cm4gbWFrZU5vdGVEZWYocmVzdE5vdGUsIGRlZnMpXG59XG5cbmV4cG9ydCBkZWZhdWx0IERlZnNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZW5kZXJlci9kZWZzL0RlZnMuanMiLCJpbXBvcnQgU25hcCBmcm9tICdzbmFwc3ZnJ1xuaW1wb3J0IHN2Z1BhdGhzIGZyb20gJy4uL3N2Z1BhdGhzJ1xuXG4vKipcbiAqIFNWRyBkZWZpbml0aW9uIGZvciBhY2NpZGVudGFsLlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0ge3N0cmluZ30gYWNjaWRlbnRhbCBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0ICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIEFjY2lkZW50YWxEZWYoaWQsIGFjY2lkZW50YWwsIGxheW91dCkge1xuICBjb25zdCB7IGFjY2lkZW50YWxTaGlmdCwgYWNjaWRlbnRhbEZvbnRTaXplIH0gPSBsYXlvdXQub3B0aW9uc1xuICBjb25zdCBlbCA9IHRoaXMuZWwgPSBsYXlvdXQuc3ZnLmVsLmcoKS5hdHRyKCdpZCcsIGlkKVxuICBjb25zdCBhY2NLZXkgPSBhY2NpZGVudGFsLnJlcGxhY2UoL2JiLywgJ2InKSAvLyBkb3VibGUgZmxhdCB0byBiZSBzeW50aGVzaXplZFxuICBjb25zdCBwYXRoRGF0YSA9IHN2Z1BhdGhzW2FjY0tleV1cbiAgY29uc3QgcmF0aW8gPSBzdmdQYXRocy5BQ0NJREVOVEFMX1JBVElPU1thY2NLZXldXG4gIGNvbnN0IHNoaWZ0ID0gc3ZnUGF0aHMuQUNDSURFTlRBTF9TSElGVFNbYWNjS2V5XVxuICBjb25zdCBwYXRoID0gZWwucGF0aChwYXRoRGF0YSlcbiAgbGV0IGJiID0gZWwuZ2V0QkJveCgpXG5cbiAgcGF0aC50cmFuc2Zvcm0oU25hcC5tYXRyaXgoKVxuICAgIC50cmFuc2xhdGUoMC4xICogYWNjaWRlbnRhbFNoaWZ0LCAtYWNjaWRlbnRhbFNoaWZ0KVxuICAgIC5zY2FsZShyYXRpbyAqIGFjY2lkZW50YWxGb250U2l6ZSlcbiAgICAudHJhbnNsYXRlKC1iYi54LCBzaGlmdCAtIGJiLnkyKVxuICApXG5cbiAgLy8gQ29tYmluZSB0d28gZmxhdCB0byBiZSBkb3VibGUgZmxhdC5cbiAgaWYgKGFjY2lkZW50YWwgPT09ICdiYicpIHtcbiAgICBlbC51c2UocGF0aCkuYXR0cigneCcsIGFjY2lkZW50YWxGb250U2l6ZSAqIDAuMjQpXG4gICAgZWwudHJhbnNmb3JtKCdzY2FsZSgwLjksMSknKVxuICB9XG5cbiAgYmIgPSBlbC5nZXRCQm94KClcbiAgdGhpcy53aWR0aCA9IGJiLndpZHRoICogMS4yXG5cbiAgZWwudG9EZWZzKClcbn1cblxuZXhwb3J0IGRlZmF1bHQgQWNjaWRlbnRhbERlZlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlbmRlcmVyL2RlZnMvQWNjaWRlbnRhbERlZi5qcyIsImNvbnN0IHN2Z1BhdGhzID0ge1xuICAvLyBodHRwczovL3VwbG9hZC53aWtpbWVkaWEub3JnL3dpa2lwZWRpYS9jb21tb25zL2EvYTYvU2hhcnAuc3ZnXG4gICcjJzogJ002LjEwMiw3LjQ1N1YyLjc1M0w4LjEwMiwyLjIwMVY2Ljg4MUw2LjEwMiw3LjQ1N3pNMTAuMDQsNi4zMTlMOC42NjUsNi43MTNWMi4wMzNMMTAuMDQsMS42NDlWLTAuMjk1TDguNjY1LDAuMDg5Vi00LjY5Mjc3SDguMTAyVjAuMjM0TDYuMTAyLDAuODA5Vi0zLjg0MDc3SDUuNTcxVjAuOTg2TDQuMTk2LDEuMzcxVjMuMzE5TDUuNTcxLDIuOTM1VjcuNjA2TDQuMTk2LDcuOTg5VjkuOTI5TDUuNTcxLDkuNTQ1VjE0LjI5OUw2LjEwMiwxNC4yOTk3N1Y5LjM3NUw4LjEwMiw4LjgyNVYxMy40NTA3N0g4LjY2NVY4LjY1MUwxMC4wNCw4LjI2NlY2LjMxOXonLFxuXG4gIC8vIGh0dHBzOi8vdXBsb2FkLndpa2ltZWRpYS5vcmcvd2lraXBlZGlhL2NvbW1vbnMvMy8zYS9Eb3VibGVTaGFycC5zdmdcbiAgJyMjJzogJ001LjAwOSw4LjMwNzIxQzQuMjc0NDMsOC4xOTE5MiAzLjUyNzY5LDguMTkyMDkgMi43ODU4LDguMTkyOTRDMi43NzAwNyw3LjY1MDExIDIuODU2NzQsNy4wNzI5IDIuNjQxNSw2LjU2MzQzQzIuNDk4MjEsNi4yMjQyNiAyLjIyNTMyLDUuOTU2NjUgMS45ODI2OSw1LjY4MTU1QzEuNTk1NTIsNi4wMjc4IDEuMjc3NTEsNi40ODQ3NSAxLjI0NzA0LDcuMDE2MzhDMS4yMTcwNiw3LjQwNzY3IDEuMjM5MDIsNy44MDA4NSAxLjIzMjIsOC4xOTI5NEMwLjQ5MDQsOC4yMDQxNi0wLjI1OTE4LDguMTY4MjgtMC45OTEsOC4zMTRDLTAuODQ5ODgsNy41ODYzLTAuODgxOTUsNi44NDE3MS0wLjg2OTE3LDYuMTA0OEMtMC4zMDQzLDYuMDg5NTMgMC4zMDAyMyw2LjE3MTAxIDAuODI0ODQsNS45MjUyNkMxLjEzNDQxLDUuNzgwMjMgMS4zOTY1Myw1LjU1Mjk1IDEuNjU5MSw1LjMzNjc2QzEuMzE3Myw0Ljk0OTY1IDAuODczNDYsNC42MDg2MSAwLjMzNjY1LDQuNTc2NTFDLTAuMDY0MjcsNC41NDQ4NS0wLjQ2NzM0LDQuNTY3OTMtMC44NjkxNyw0LjU2MDk3Qy0wLjg5NDM0LDMuODI5NDktMC44MDg5NSwzLjA4ODU1LTAuOTYwNzksMi4zNjYzQy0wLjIzNzMzLDIuNDk2OTcgMC41MDA2NSwyLjQ2MzQzIDEuMjMyMiwyLjQ3Mjg0QzEuMjQzMDYsMi45OTM4MyAxLjE4NDgzLDMuNTMzODEgMS4zMzE5MSw0LjAzNTVDMS40NDQxNCw0LjQxODM4IDEuNzQ5NzgsNC43MTI5MyAyLjAwNTEsNS4wMTUyMUMyLjM2NTUzLDQuNzAxMTEgMi42OTA1Nyw0LjMwNzA2IDIuNzUwMTEsMy44MTQxMkMyLjgwNCwzLjM2NzkzIDIuNzYxMjMsMi45MTk3NyAyLjc4NTgsMi40NzI4NEMzLjUyMjYzLDIuNDUzNDggNC4yODIxNSwyLjU0NzEzIDQuOTk1MzUsMi4zMTRDNC44ODg5MSwzLjA1NzExIDQuODc4ODksMy44MTE1MiA0Ljg4NzE3LDQuNTYwOTdDNC4zNjEyNyw0LjU3NTgyIDMuODA5NTQsNC41MTc0NyAzLjMwOTU1LDQuNjk0NTdDMi45Mjk3NSw0LjgyOTEgMi42MzExNCw1LjEyMzQxIDIuMzI4NjksNS4zODMyNUMyLjY1NjYxLDUuNzE4NjcgMy4wNTE2LDYuMDI4MDIgMy41NDAzLDYuMDczNjhDMy45ODgzNCw2LjExNTU0IDQuNDM4MjksNi4wOTY1OCA0Ljg4NzE3LDYuMTA0OEM0Ljg5ODI4LDYuODM5NTggNC44NjE5Myw3LjU4MjUgNS4wMDksOC4zMDcyMXonLFxuXG4gIC8vIGh0dHBzOi8vdXBsb2FkLndpa2ltZWRpYS5vcmcvd2lraXBlZGlhL2NvbW1vbnMvYi9iYS9GbGF0LnN2Z1xuICBiOiAnTTguMTY2LDMuNjU3QzguMTY2LDQuMjMyIDcuOTUwNDI1LDQuNzgyNzMgNy4zNTksNS41MjE4OEM2LjczMjQzNSw2LjMwNDk0IDYuMjA1LDYuNzUzMTMgNS41MSw3LjI4MDEzVjMuODQ4QzUuNjY4LDMuNDQ5IDUuOTAxLDMuMTI2IDYuMjEsMi44NzhDNi41MTgsMi42MzEgNi44MywyLjUwNyA3LjE0NiwyLjUwN0M3LjY2OCwyLjUwNyA3Ljk5OSwyLjgwMyA4LjE0MiwzLjM5M0M4LjE1OCwzLjQ0MSA4LjE2NiwzLjUyOSA4LjE2NiwzLjY1N3pNOC4wOTEsMS4yNTdDNy42NiwxLjI1NyA3LjIyMiwxLjM3NiA2Ljc3NiwxLjYxNUM2LjMzLDEuODUzIDUuOTA4LDIuMTcyIDUuNTEsMi41NjlWLTQuNzAyNjdINC45NDcgVjcuNzUyMTNDNC45NDcsOC4xMDQxMyA1LjA0Myw4LjI4MDEzIDUuMjM1LDguMjgwMTNDNS4zNDYsOC4yODAxMyA1LjQ4MzkxMyw4LjE4NzEzIDUuNjksOC4wNjQxM0M2LjI3MzM0LDcuNzE1OTggNi42MzY5MzUsNy40ODMzMiA3LjAzMiw3LjIzNzg4QzcuNDgyNjE3LDYuOTU3OTIgNy45OSw2LjYzMSA4LjY2MSw1Ljk5MUM5LjEyNCw1LjUyNiA5LjQ1OSw1LjA1NyA5LjY2Nyw0LjU4NUM5Ljg3NCw0LjExMiA5Ljk3OCwzLjY0NCA5Ljk3OCwzLjE3OUM5Ljk3OCwyLjQ5MSA5Ljc5NSwyLjAwMiA5LjQyOSwxLjcxM0M5LjAxNSwxLjQwOSA4LjU2OCwxLjI1NyA4LjA5MSwxLjI1N3onLFxuXG4gIC8vIGh0dHBzOi8vdXBsb2FkLndpa2ltZWRpYS5vcmcvd2lraXBlZGlhL2NvbW1vbnMvZi9mNC9NdXNpYy1uYXR1cmFsLnN2Z1xuICBuOiAnTSAwLDE0LjExMlY0MS41MmgtMS4yNDhWMzEuMjQ4bC02LjY3MiwxLjcyOFY1LjIzMmgxLjJ2MTAuNzA0bDYuNzIsLTEuODI0em0tNi43Miw2LjQzMnY3LjUzNmw1LjQ3MiwtMS40NHYtNy41MzZsLTUuNDcyLDEuNDR6JyxcblxuICBBQ0NJREVOVEFMX1JBVElPUzogeyAnIyc6IDAuMDQzLCAnbic6IDAuMDIzLCAnIyMnOiAwLjA2MiwgYjogMC4wNTcgfSxcbiAgQUNDSURFTlRBTF9TSElGVFM6IHsgJyMnOiAxLCAnbic6IDIsICcjIyc6IC00LCBiOiAwIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgc3ZnUGF0aHNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZW5kZXJlci9zdmdQYXRocy5qcyIsIi8qKlxuICogU1ZHIGRlZmluaXRpb24gZm9yIGJhcmxpbmUuXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCAgICAgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtIHtCYXJ9IGJhciAgICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0IFtkZXNjcmlwdGlvbl1cbiAqL1xuZnVuY3Rpb24gQmFyRGVmKGlkLCBiYXIsIGxheW91dCkge1xuICBjb25zdCB7XG4gICAgdGhpbkJhcmxpbmVXaWR0aCwgdGhpY2tCYXJsaW5lV2lkdGgsXG4gICAgYmFybGluZVNlcCwgYmFybGluZURvdFNlcCwgYmFybGluZURvdFJhZGl1c1xuICB9ID0gbGF5b3V0Lm9wdGlvbnNcbiAgbGV0IHggPSAwXG4gIGxldCBsaW5lV2lkdGhcbiAgdGhpcy5lbCA9IGxheW91dC5zdmcuZWwuZygpLmF0dHIoJ2lkJywgaWQpLnRvRGVmcygpXG5cbiAgc3dpdGNoIChiYXIudmFsdWUpIHtcbiAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgbGluZVdpZHRoID0gdGhpbkJhcmxpbmVXaWR0aFxuICAgICAgYWRkQmFybGluZSh0aGlzLCB4LCBsaW5lV2lkdGgpXG4gICAgICB4ICs9IGxpbmVXaWR0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdkb3VibGUnOlxuICAgICAgbGluZVdpZHRoID0gdGhpbkJhcmxpbmVXaWR0aFxuICAgICAgYWRkQmFybGluZSh0aGlzLCB4LCBsaW5lV2lkdGgpXG4gICAgICB4ICs9IGxpbmVXaWR0aCArIGJhcmxpbmVTZXBcbiAgICAgIGFkZEJhcmxpbmUodGhpcywgeCwgbGluZVdpZHRoKVxuICAgICAgeCArPSBsaW5lV2lkdGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnZW5kJzpcbiAgICAgIGxpbmVXaWR0aCA9IHRoaW5CYXJsaW5lV2lkdGhcbiAgICAgIGFkZEJhcmxpbmUodGhpcywgeCwgbGluZVdpZHRoKVxuICAgICAgeCArPSBsaW5lV2lkdGggKyBiYXJsaW5lU2VwXG4gICAgICBsaW5lV2lkdGggPSB0aGlja0JhcmxpbmVXaWR0aFxuICAgICAgYWRkQmFybGluZSh0aGlzLCB4LCBsaW5lV2lkdGgpXG4gICAgICB4ICs9IGxpbmVXaWR0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdyZXBlYXQtYmVnaW4nOlxuICAgICAgbGluZVdpZHRoID0gdGhpY2tCYXJsaW5lV2lkdGhcbiAgICAgIGFkZEJhcmxpbmUodGhpcywgeCwgbGluZVdpZHRoKVxuICAgICAgeCArPSBsaW5lV2lkdGggKyBiYXJsaW5lU2VwXG4gICAgICBsaW5lV2lkdGggPSB0aGluQmFybGluZVdpZHRoXG4gICAgICBhZGRCYXJsaW5lKHRoaXMsIHgsIGxpbmVXaWR0aClcbiAgICAgIHggKz0gbGluZVdpZHRoICsgYmFybGluZURvdFNlcCArIGJhcmxpbmVEb3RSYWRpdXNcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAncmVwZWF0LWVuZCc6XG4gICAgICB4ID0gYmFybGluZURvdFNlcCArIGJhcmxpbmVEb3RSYWRpdXNcbiAgICAgIGxpbmVXaWR0aCA9IHRoaW5CYXJsaW5lV2lkdGhcbiAgICAgIGFkZEJhcmxpbmUodGhpcywgeCwgbGluZVdpZHRoKVxuICAgICAgeCArPSBsaW5lV2lkdGggKyBiYXJsaW5lU2VwXG4gICAgICBsaW5lV2lkdGggPSB0aGlja0JhcmxpbmVXaWR0aFxuICAgICAgYWRkQmFybGluZSh0aGlzLCB4LCBsaW5lV2lkdGgpXG4gICAgICB4ICs9IGxpbmVXaWR0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdyZXBlYXQtYm90aCc6XG4gICAgICB4ID0gYmFybGluZURvdFNlcCArIGJhcmxpbmVEb3RSYWRpdXNcbiAgICAgIGxpbmVXaWR0aCA9IHRoaW5CYXJsaW5lV2lkdGhcbiAgICAgIGFkZEJhcmxpbmUodGhpcywgeCwgbGluZVdpZHRoKVxuICAgICAgeCArPSBsaW5lV2lkdGggKyBiYXJsaW5lU2VwXG4gICAgICBsaW5lV2lkdGggPSB0aGlja0JhcmxpbmVXaWR0aFxuICAgICAgYWRkQmFybGluZSh0aGlzLCB4LCBsaW5lV2lkdGgpXG4gICAgICB4ICs9IGxpbmVXaWR0aCArIGJhcmxpbmVTZXBcbiAgICAgIGxpbmVXaWR0aCA9IHRoaW5CYXJsaW5lV2lkdGhcbiAgICAgIGFkZEJhcmxpbmUodGhpcywgeCwgbGluZVdpZHRoKVxuICAgICAgeCArPSBsaW5lV2lkdGggKyBiYXJsaW5lRG90U2VwICsgYmFybGluZURvdFJhZGl1c1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICB9XG4gIHRoaXMud2lkdGggPSB4XG59XG5cbmZ1bmN0aW9uIGFkZEJhcmxpbmUodGhhdCwgeCwgd2lkdGgpIHsgdGhhdC5lbC5yZWN0KHgsIDAsIHdpZHRoLCAxKSB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhckRlZlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlbmRlcmVyL2RlZnMvQmFyRGVmLmpzIiwiLyoqXG4gKiBTVkcgZGVmaW5pdGlvbiBmb3IgZHVyYXRpb24uXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCAgICAgICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0ge0R1cmF0aW9ufSBkdXJhdGlvbiBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0ICAgW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBEdXJhdGlvbkRlZihpZCwgZHVyYXRpb24sIGxheW91dCkge1xuICB0aGlzLl9pZCA9IGlkXG4gIHRoaXMuX2xheW91dCA9IGxheW91dFxuXG4gIC8vIG9ubHkgbWFrZSBkZWYgZWwgZm9yOlxuICAvLyBpZCA9IGQxMCwgZDExLCBkMTIsIGQyMCwgZDIxLCBkMjAsIGQ0MSwgZDQwXG4gIHN3aXRjaCAoZHVyYXRpb24udHlwZSkge1xuICAgIGNhc2UgMTogICAvLyB3aG9sZSBub3RlXG4gICAgICBtYWtlRWwodGhpcylcbiAgICAgIG1ha2VUeXBlMSh0aGlzLCBpZCwgZHVyYXRpb24uZG90KVxuICAgICAgYnJlYWtcbiAgICBjYXNlIDI6ICAgLy8gaGFsZiBub3RlXG4gICAgICBtYWtlRWwodGhpcylcbiAgICAgIG1ha2VUeXBlMih0aGlzLCBpZCwgZHVyYXRpb24uZG90KVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OiAgLy8gb3RoZXIgbm90ZSB0eXBlcyB0eXBlIHF1YXJ0ZXIgbm90ZSBkZWZcbiAgICAgIGlmIChkdXJhdGlvbi5kb3QgPT09IDApIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IDBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1ha2VFbCh0aGlzKVxuICAgICAgICBtYWtlVHlwZTQodGhpcywgaWQsIGR1cmF0aW9uLmRvdClcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlVHlwZTEodGhhdCwgaWQsIGRvdCkge1xuICBjb25zdCB7IHR5cGViYXJMZW5ndGgsIHR5cGViYXJTZXAsIHR5cGViYXJPZmZzZXQgfSA9IHRoYXQuX2xheW91dC5vcHRpb25zXG4gIGxldCB4ID0gdHlwZWJhck9mZnNldFxuXG4gIGFkZExpbmUodGhhdCwgeClcbiAgeCArPSB0eXBlYmFyTGVuZ3RoICsgdHlwZWJhclNlcFxuICBhZGRMaW5lKHRoYXQsIHgpXG4gIHggKz0gdHlwZWJhckxlbmd0aCArIHR5cGViYXJTZXBcbiAgYWRkTGluZSh0aGF0LCB4KVxuICB4ICs9IHR5cGViYXJMZW5ndGhcblxuICB0aGF0LndpZHRoID0gYWRkRG90KHRoYXQsIHgsIGRvdCwgMSlcbn1cblxuZnVuY3Rpb24gbWFrZVR5cGUyKHRoYXQsIGlkLCBkb3QpIHtcbiAgY29uc3QgeyB0eXBlYmFyT2Zmc2V0LCB0eXBlYmFyTGVuZ3RoIH0gPSB0aGF0Ll9sYXlvdXQub3B0aW9uc1xuICBsZXQgeCA9IHR5cGViYXJPZmZzZXRcblxuICBhZGRMaW5lKHRoYXQsIHR5cGViYXJPZmZzZXQpXG4gIHggKz0gdHlwZWJhckxlbmd0aFxuICB0aGF0LndpZHRoID0gYWRkRG90KHRoYXQsIHgsIGRvdCwgMilcbn1cblxuZnVuY3Rpb24gbWFrZVR5cGU0KHRoYXQsIGlkLCBkb3QpIHtcbiAgY29uc3Qge1xuICAgIHQ0RG90T2Zmc2V0LCB0NERvdEJhc2VsaW5lU2hpZnQsIHQ0RG90U2VwLCB0NERvdEV4dCwgZG90UmFkaXVzXG4gIH0gPSB0aGF0Ll9sYXlvdXQub3B0aW9uc1xuICBsZXQgeCA9IHQ0RG90T2Zmc2V0XG5cbiAgdGhhdC5lbC5jaXJjbGUoeCwgLXQ0RG90QmFzZWxpbmVTaGlmdCwgZG90UmFkaXVzKVxuXG4gIGlmIChkb3QgPiAxKSB7XG4gICAgeCArPSB0NERvdFNlcFxuICAgIHRoYXQuZWwuY2lyY2xlKHgsIC10NERvdEJhc2VsaW5lU2hpZnQsIGRvdFJhZGl1cylcbiAgfVxuICB0aGF0LndpZHRoID0geCArIHQ0RG90RXh0XG59XG5cbmZ1bmN0aW9uIG1ha2VFbCh0aGF0KSB7XG4gIHRoYXQuZWwgPSB0aGF0Ll9sYXlvdXQuc3ZnLmVsLmcoKVxuICAgICAgICAgICAgICAuYXR0cignaWQnLCB0aGF0Ll9pZClcbiAgICAgICAgICAgICAgLnRvRGVmcygpXG59XG5cbmZ1bmN0aW9uIGFkZExpbmUodGhhdCwgeCkge1xuICBjb25zdCB7IHR5cGVTdHJva2VXaWR0aCwgdHlwZWJhckxlbmd0aCB9ID0gdGhhdC5fbGF5b3V0Lm9wdGlvbnNcbiAgdGhhdC5lbC5yZWN0KHgsIC10eXBlU3Ryb2tlV2lkdGgsIHR5cGViYXJMZW5ndGgsIHR5cGVTdHJva2VXaWR0aClcbn1cblxuLy8gQWRkIGRvdCBmb3IgdHlwZSAxICh3aG9sZSkgb3IgdHlwZSAyIChoYWxmKSBub3RlLlxuZnVuY3Rpb24gYWRkRG90KHRoYXQsIHgsIGRvdCwgdHlwZSkge1xuICBjb25zdCB7IGRvdE9mZnNldCwgZG90U2VwLCBkb3RSYWRpdXMsIHR5cGViYXJFeHQgfSA9IHRoYXQuX2xheW91dC5vcHRpb25zXG5cbiAgaWYgKGRvdCA+IDApIHtcbiAgICB4ICs9IGRvdE9mZnNldCAqICh0eXBlID09PSAxID8gMS4yIDogMSlcbiAgICB0aGF0LmVsLmNpcmNsZSh4LCAwLCBkb3RSYWRpdXMpXG4gIH1cbiAgaWYgKGRvdCA+IDEpIHtcbiAgICB4ICs9IGRvdFNlcCAqICh0eXBlID09PSAxID8gMS4yIDogMSlcbiAgICB0aGF0LmVsLmNpcmNsZSh4LCAwLCBkb3RSYWRpdXMpXG4gIH1cbiAgcmV0dXJuIHggKyB0eXBlYmFyRXh0XG59XG5cbmV4cG9ydCBkZWZhdWx0IER1cmF0aW9uRGVmXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVuZGVyZXIvZGVmcy9EdXJhdGlvbkRlZi5qcyIsImltcG9ydCBTbmFwIGZyb20gJ3NuYXBzdmcnXG5pbXBvcnQgeyBleHRlbmQsIG5lYXIgfSBmcm9tICcuLi8uLi91dGlsJ1xuXG4vKipcbiAqIFNWRyBkZWZpbml0aW9uIGZvciBwaXRjaC5cbiAqIFRoZSBgUGl0Y2hEZWZgIGlzIGRlZmluZWQgYnkgcHJvcGVydGllczogYSBzIG8gdVxuICogYWNjaWRlbnRhbCBzdGVwIG9jdGF2ZSB1bmRlcmJhclxuICogQGNsYXNzXG4gKiBAcGFyYW0gaWQge3N0cmluZ30gICAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSBwaXRjaCB7UGl0Y2h9ICAgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtIGxheW91dCB7TGF5b3V0fSBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIFBpdGNoRGVmKGlkLCBwaXRjaCwgdW5kZXJiYXIsIGRlZnMpIHtcbiAgY29uc3QgbGF5b3V0ID0gdGhpcy5fbGF5b3V0ID0gZGVmcy5fbGF5b3V0XG4gIGNvbnN0IHsgYWNjaWRlbnRhbCwgb2N0YXZlIH0gPSBwaXRjaFxuICAvLyBjb25zdCBzY2FsZSA9IGdldFNjYWxlKGFjY2lkZW50YWwsIG9jdGF2ZSwgdW5kZXJiYXIpXG4gIGNvbnN0IGVsID0gdGhpcy5lbCA9IGxheW91dC5zdmcuZWwuZygpLmF0dHIoe1xuICAgIGlkLFxuICAgIHN0cm9rZTogJ2JsYWNrJyxcbiAgICBzdHJva2VXaWR0aDogMC4xLy8gLSAoc2NhbGUueCArIHNjYWxlLnkpXG4gIH0pXG4gIGxldCBtYXRyaXgsIHNiYm94LCBwYmJveFxuXG4gIHRoaXMuX2RlZnMgPSBkZWZzXG4gIGFkZEFjY2lkZW50YWwodGhpcywgYWNjaWRlbnRhbClcbiAgYWRkU3RlcCh0aGlzLCBwaXRjaC5zdGVwKVxuICBhZGRPY3RhdmUodGhpcywgb2N0YXZlKVxuXG4gIG1hdHJpeCA9IGdldE1hdHJpeCh0aGlzLCBvY3RhdmUsIHVuZGVyYmFyKVxuICBlbC50cmFuc2Zvcm0obWF0cml4KVxuXG4gIHNiYm94ID0gdGhpcy5fc2Jib3hcbiAgc2Jib3ggPSBnZXRCQm94QWZ0ZXJUcmFuc2Zvcm0odGhpcy5lbCwgc2Jib3gsIG1hdHJpeClcblxuICBwYmJveCA9IGVsLmdldEJCb3goKVxuICBlbC50b0RlZnMoKVxuXG4gIGV4dGVuZCh0aGlzLCB7XG4gICAgLy8gc2NhbGUsXG4gICAgbWF0cml4LFxuICAgIHdpZHRoOiBwYmJveC53aWR0aCxcbiAgICBoZWlnaHQ6IC1wYmJveC55LFxuICAgIHN0ZXBDeDogc2Jib3guY3gsXG4gICAgc3RlcFk6IHNiYm94LnksXG4gICAgc3RlcEN5OiBzYmJveC5jeSxcbiAgICBzdGVwWTI6IHNiYm94LnkyLFxuICAgIHN0ZXBUb3A6IG9jdGF2ZSA+IDAgPyBwYmJveC55IDogc2Jib3gueSArIGxheW91dC5vcHRpb25zLmZvbnRTaXplICogMC4yXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGFkZEFjY2lkZW50YWwodGhhdCwgYWNjaWRlbnRhbCkge1xuICBpZiAoIWFjY2lkZW50YWwpIHtcbiAgICB0aGF0Ll9hY2NpZGVudGFsWDIgPSAwXG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgYWNjRGVmID0gdGhhdC5fZGVmcy5nZXRBY2NpZGVudGFsKGFjY2lkZW50YWwpXG4gIHRoYXQuZWwudXNlKGFjY0RlZi5lbCkuYXR0cigneScsIC10aGF0Ll9sYXlvdXQub3B0aW9ucy5hY2NpZGVudGFsU2hpZnQpXG4gIHRoYXQuX2FjY2lkZW50YWxYMiA9IGFjY0RlZi53aWR0aFxufVxuXG4vLyBzdGVw5Zyo6L+Z6YeM5bCx5piv6Z+z6Zi255qE5pWw5a2XXG5mdW5jdGlvbiBhZGRTdGVwKHRoYXQsIHN0ZXApIHtcbiAgdGhhdC5fc2Jib3ggPSB0aGF0LmVsXG4gICAgLnRleHQodGhhdC5fYWNjaWRlbnRhbFgyLCAwLCAnJyArIHN0ZXApXG4gICAgLmF0dHIoJ2ZvbnQtc2l6ZScsIHRoYXQuX2xheW91dC5vcHRpb25zLmZvbnRTaXplKVxuICAgIC5nZXRCQm94KClcbn1cblxuZnVuY3Rpb24gYWRkT2N0YXZlKHRoYXQsIG9jdGF2ZSkge1xuICBpZiAoIW9jdGF2ZSkgcmV0dXJuXG5cbiAgY29uc3QgeyBvY3RhdmVSYWRpdXMsIG9jdGF2ZU9mZnNldCwgb2N0YXZlU2VwIH0gPSB0aGF0Ll9sYXlvdXQub3B0aW9uc1xuICBjb25zdCBvY3RhdmVFbCA9IHRoYXQuZWwuZygpXG5cbiAgLy8g5Yqg5LiK5YWr5bqm5ZKM6Z+z55qE54K5XG4gIGlmIChvY3RhdmUgPiAwKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvY3RhdmU7IGkrKykge1xuICAgICAgb2N0YXZlRWwuY2lyY2xlKFxuICAgICAgICB0aGF0Ll9zYmJveC5jeCxcbiAgICAgICAgdGhhdC5fc2Jib3gueSArIG9jdGF2ZU9mZnNldCAtIG9jdGF2ZVNlcCAqIGksXG4gICAgICAgIG9jdGF2ZVJhZGl1c1xuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA+IG9jdGF2ZTsgaS0tKSB7XG4gICAgICBvY3RhdmVFbC5jaXJjbGUoXG4gICAgICAgIHRoYXQuX3NiYm94LmN4LFxuICAgICAgICB0aGF0Ll9zYmJveC55MiAtIG9jdGF2ZU9mZnNldCAtIG9jdGF2ZVNlcCAqIGksXG4gICAgICAgIG9jdGF2ZVJhZGl1c1xuICAgICAgKVxuICAgIH1cbiAgfVxuICB0aGF0LmVsLmFkZChvY3RhdmVFbClcbn1cblxuLy8gVHJhbnNmb3JtIHRoZSBwaXRjaCB0byBiZSBpbiBhIGdvb2QgYmFzZWxpbmUgcG9zaXRpb24gYW5kXG4vLyBzY2FsZSBpdCB0byBiZSBtb3JlIHNxdWFyZS5cbmZ1bmN0aW9uIGdldE1hdHJpeCh0aGF0LCBvY3RhdmUsIHVuZGVyYmFyKSB7XG4gIGNvbnN0IHsgc3RlcEJhc2VsaW5lU2hpZnQsIHVuZGVyYmFyU2VwIH0gPSB0aGF0Ll9sYXlvdXQub3B0aW9uc1xuICBjb25zdCBwYmJveCA9IHRoYXQuZWwuZ2V0QkJveCgpXG4gIGNvbnN0IGR5ID0gKG9jdGF2ZSA+PSAwICYmIHVuZGVyYmFyID09PSAwID8gLXN0ZXBCYXNlbGluZVNoaWZ0IDogMCkgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlcmJhciAqIHVuZGVyYmFyU2VwXG4gIHJldHVybiBTbmFwLm1hdHJpeCgpXG4gICAgLnRyYW5zbGF0ZSgtcGJib3gueCwgZHkpXG4gICAgLy/nvKnlsI/pn7PnrKbnmoTmr5TkvotcbiAgICAvLyAuc2NhbGUoc2NhbGUueCwgc2NhbGUueSlcbiAgICAvL+aKiumfs+espuaKrOWIsOabtOmrmOeahOS9jee9ruS4iu+8jOazqOmHiuWQjuS9jumfs+WwseS4jeWGjeaPkOmrmOS6hu+8iOWFs+mUruaYr3ky77yJ55qE5bel5L2cXG4gICAgLnRyYW5zbGF0ZSgwLCBuZWFyKHBiYm94LnkyLCB0aGF0Ll9zYmJveC55MikgPyAwIDogLXBiYm94LnkyKVxufVxuXG5mdW5jdGlvbiBnZXRCQm94QWZ0ZXJUcmFuc2Zvcm0oY29udGFpbmVyLCBiYm94LCBtYXRyaXgpIHtcbiAgY29uc3QgcmVjdCA9IGNvbnRhaW5lci5yZWN0KGJib3gueCwgYmJveC55LCBiYm94LndpZHRoLCBiYm94LmhlaWdodClcbiAgY29uc3QgZyA9IGNvbnRhaW5lci5nKHJlY3QpXG4gIHJlY3QudHJhbnNmb3JtKG1hdHJpeClcbiAgYmJveCA9IGcuZ2V0QkJveCgpXG4gIGcucmVtb3ZlKClcbiAgcmV0dXJuIGJib3hcbn1cblxuZnVuY3Rpb24gZ2V0U2NhbGUoaGFzQWNjaWRlbnRhbCwgb2N0YXZlLCB1bmRlcmJhcikge1xuICBjb25zdCBhYnNPY3RhdmUgPSBNYXRoLmFicyhvY3RhdmUpXG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5wb3coMC45NywgYWJzT2N0YXZlICsgdW5kZXJiYXIgKyAoaGFzQWNjaWRlbnRhbCA/IDIgOiAwKSksXG4gICAgeTogTWF0aC5wb3coMC45NSwgYWJzT2N0YXZlICsgdW5kZXJiYXIgKyAoaGFzQWNjaWRlbnRhbCA/IDEgOiAwKSlcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQaXRjaERlZlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlbmRlcmVyL2RlZnMvUGl0Y2hEZWYuanMiLCJpbXBvcnQgU25hcCBmcm9tICdzbmFwc3ZnJ1xuXG4vKipcbiAqIFNWRyBkZWZpbml0aW9uIGZvciB0aW1lIHNpZ25hdHVyZS5cbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmd9IGlkICAgICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0ge1RpbWV9IHRpbWUgICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0IFtkZXNjcmlwdGlvbl1cbiAqL1xuZnVuY3Rpb24gVGltZURlZihpZCwgdGltZSwgbGF5b3V0KSB7XG4gIGNvbnN0IHsgdGltZUZvbnRTaXplOiBmb250U2l6ZSwgdGltZUZvbnRXZWlnaHQ6IGZvbnRXZWlnaHQgfSA9IGxheW91dC5vcHRpb25zXG4gIGNvbnN0IGxpbmVFeHRlbmQgPSBmb250U2l6ZSAqIDAuMVxuICBjb25zdCBlbCA9IHRoaXMuZWwgPSBsYXlvdXQuc3ZnLmVsLmcoKS5hdHRyKHtcbiAgICBpZCxcbiAgICBmb250U2l6ZSxcbiAgICBmb250V2VpZ2h0LFxuICAgIHRleHRBbmNob3I6ICdtaWRkbGUnXG4gIH0pXG4gIGNvbnN0IGxpbmVZID0gLTAuODUgKiBmb250U2l6ZVxuICBsZXQgYmJcblxuICBlbC50ZXh0KDAsIC0xICogZm9udFNpemUsIHRpbWUuYmVhdHMpXG4gIGVsLnRleHQoMCwgMCwgdGltZS5iZWF0VHlwZSkgICAvLyBiYXNlbGluZSB5ID0gMFxuICBiYiA9IGVsLmdldEJCb3goKVxuICBlbC5saW5lKGJiLnggLSBsaW5lRXh0ZW5kLCBsaW5lWSwgYmIueDIgKyBsaW5lRXh0ZW5kLCBsaW5lWSlcbiAgZWwudHJhbnNmb3JtKFNuYXAubWF0cml4KCkuc2NhbGUoMSwgMC44KS50cmFuc2xhdGUobGluZUV4dGVuZCAtIGJiLngsIDApKVxuXG4gIGJiID0gZWwuZ2V0QkJveCgpXG4gIGVsLnRvRGVmcygpXG5cbiAgdGhpcy53aWR0aCA9IGJiLndpZHRoXG4gIHRoaXMuaGVpZ2h0ID0gLWJiLnlcbn1cblxuZXhwb3J0IGRlZmF1bHQgVGltZURlZlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlbmRlcmVyL2RlZnMvVGltZURlZi5qcyIsImltcG9ydCBTbmFwIGZyb20gJ3NuYXBzdmcnXG5cbi8qKlxuICogQGNsYXNzXG4gKiBAcGFyYW0gbGF5b3V0IHtMYXlvdXR9XG4gKi9cbmNsYXNzIFN2Z0xheW91dCB7XG4gIGNvbnN0cnVjdG9yKGxheW91dCkge1xuICAgIHRoaXMuX2xheW91dCA9IGxheW91dFxuICAgIGNvbnN0IHsgZm9udEZhbWlseSwgd2lkdGggfSA9IGxheW91dC5vcHRpb25zXG4gICAgdGhpcy5fZWwgPSBTbmFwKGxheW91dC5zdmcpXG4gICAgICAuYXR0cih7IGZvbnRGYW1pbHkgfSlcbiAgICAgIC5hZGRDbGFzcygnbXVzamUnKVxuICAgIHRoaXMuZWwuY2xlYXIoKVxuICAgIHRoaXMud2lkdGggPSB3aWR0aFxuICB9XG5cbiAgZ2V0IGVsKCkgeyByZXR1cm4gdGhpcy5fZWwgfVxuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiB0aGUgc3ZnLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdpZHRoKCkgeyByZXR1cm4gdGhpcy5fdyB9XG4gIHNldCB3aWR0aCh3KSB7XG4gICAgdGhpcy5fdyA9IHdcbiAgICB0aGlzLmVsLmF0dHIoJ3dpZHRoJywgdylcbiAgICBjb25zdCB7IGJvZHkgfSA9IHRoaXMuX2xheW91dFxuICAgIGlmIChib2R5KSBib2R5LndpZHRoID0gd1xuICB9XG5cbiAgLyoqXG4gICAqIEhlaWdodCBvZiB0aGUgc3ZnLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGhlaWdodCgpIHsgcmV0dXJuIHRoaXMuX2ggfVxuICBzZXQgaGVpZ2h0KGgpIHtcbiAgICB0aGlzLl9oID0gaFxuICAgIHRoaXMuZWwuYXR0cignaGVpZ2h0JywgaClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTdmdMYXlvdXRcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZW5kZXJlci9MYXlvdXQvU3ZnTGF5b3V0LmpzIiwiaW1wb3J0IHsgbWF0cml4IH0gZnJvbSAnc25hcHN2ZydcblxuLyoqXG4gKiBCb2R5XG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7TGF5b3V0fSBsYXlvdXRcbiAqL1xuY2xhc3MgQm9keUxheW91dCB7XG4gIGNvbnN0cnVjdG9yKGxheW91dCkge1xuICAgIHRoaXMuX2xheW91dCA9IGxheW91dFxuICAgIGNvbnN0IHsgc3ZnLCBvcHRpb25zIH0gPSBsYXlvdXRcbiAgICBjb25zdCB7IG1hcmdpblRvcCwgbWFyZ2luUmlnaHQsIG1hcmdpbkxlZnQsIHdpZHRoIH0gPSBvcHRpb25zXG4gICAgdGhpcy5fZWwgPSBzdmcuZWwuZygpXG4gICAgICAgIC50cmFuc2Zvcm0obWF0cml4KCkudHJhbnNsYXRlKG1hcmdpbkxlZnQsIG1hcmdpblRvcCkpXG4gICAgICAgIC5hZGRDbGFzcygnbXVzLWJvZHknKVxuICAgIHRoaXMud2lkdGggPSB3aWR0aCAtIG1hcmdpbkxlZnQgLSBtYXJnaW5SaWdodFxuICB9XG5cbiAgZ2V0IGVsKCkgeyByZXR1cm4gdGhpcy5fZWwgfVxuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiB0aGUgYm9keS5cbiAgICogLSAoR2V0dGVyKSBHZXQgdGhlIGJvZHkgd2lkdGguXG4gICAqIC0gKFNldHRlcikgU2V0IHRoZSBib2R5IHdpZHRoIGFuZCB0aGlzIGFsc28gaW5kdWNlcyBzZXR0aW5nIHRoZVxuICAgKiBoZWFkZXIgYW5kIGNvbnRlbnQgd2lkdGggaWYgb25lIGV4aXN0cy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3aWR0aCgpIHsgcmV0dXJuIHRoaXMuX3cgfVxuICBzZXQgd2lkdGgodykge1xuICAgIHRoaXMuX3cgPSB3XG4gICAgY29uc3QgbGF5b3V0ID0gdGhpcy5fbGF5b3V0XG4gICAgaWYgKGxheW91dC5oZWFkZXIpIGxheW91dC5oZWFkZXIud2lkdGggPSB3XG4gICAgaWYgKGxheW91dC5jb250ZW50KSBsYXlvdXQuY29udGVudC53aWR0aCA9IHdcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWlnaHQgb2YgdGhlIGJvZHkuXG4gICAqIC0gKEdldHRlcikgR2V0IHRoZSBib2R5IGhlaWdodC5cbiAgICogLSAoU2V0dGVyKSBTZXQgdGhlIGJvZHkgaGVpZ2h0IGFuZCB0aGlzIHdpbGwgYWxzbyBjYXVzZSB0aGUgaGVpZ2h0IG9mIHN2ZyB0byB2YXJ5LlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGhlaWdodCgpIHsgcmV0dXJuIHRoaXMuX2ggfVxuICBzZXQgaGVpZ2h0KGgpIHtcbiAgICBjb25zdCBsYXlvdXQgPSB0aGlzLl9sYXlvdXRcbiAgICBjb25zdCB7IG1hcmdpblRvcCwgbWFyZ2luQm90dG9tIH0gPSBsYXlvdXQub3B0aW9uc1xuICAgIGxheW91dC5zdmcuaGVpZ2h0ID0gaCArIG1hcmdpblRvcCArIG1hcmdpbkJvdHRvbVxuICAgIHRoaXMuX2ggPSBoXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQm9keUxheW91dFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlbmRlcmVyL0xheW91dC9Cb2R5TGF5b3V0LmpzIiwiLyoqXG4gKiBIZWFkZXIgbGF5b3V0LlxuICogQHBhcmFtIHtMYXlvdXR9IGxheW91dFxuICovXG5jbGFzcyBIZWFkZXJMYXlvdXQge1xuICBjb25zdHJ1Y3RvcihsYXlvdXQpIHtcbiAgICB0aGlzLl9sYXlvdXQgPSBsYXlvdXRcbiAgICB0aGlzLmVsID0gbGF5b3V0LmJvZHkuZWwuZygpLmFkZENsYXNzKCdtdXMtaGVhZGVyJylcbiAgICB0aGlzLndpZHRoID0gbGF5b3V0LmJvZHkud2lkdGhcbiAgfVxuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiB0aGUgaGVhZGVyLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdpZHRoKCkgeyByZXR1cm4gdGhpcy5fdyB9XG4gIHNldCB3aWR0aCh3KSB7IHRoaXMuX3cgPSB3IH1cblxuICAvKipcbiAgICogSGVpZ2h0IG9mIHRoZSBoZWFkZXIuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgaGVpZ2h0KCkgeyByZXR1cm4gdGhpcy5faCB9XG4gIHNldCBoZWlnaHQoaCkge1xuICAgIHRoaXMuX2ggPSBoXG4gICAgY29uc3QgeyBjb250ZW50LCBvcHRpb25zIH0gPSB0aGlzLl9sYXlvdXRcbiAgICBjb250ZW50LnkgPSBoID8gaCArIG9wdGlvbnMuaGVhZGVyU2VwIDogMFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEhlYWRlckxheW91dFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlbmRlcmVyL0xheW91dC9IZWFkZXJMYXlvdXQuanMiLCJpbXBvcnQgeyBtYXRyaXggfSBmcm9tICdzbmFwc3ZnJ1xuaW1wb3J0IFN5c3RlbUxheW91dCBmcm9tICcuL1N5c3RlbUxheW91dCdcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXlvdXQgLSBSZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBsYXlvdXQgaW5zdGFuY2UuXG4gKi9cbmNsYXNzIENvbnRlbnRMYXlvdXQge1xuICBjb25zdHJ1Y3RvcihsYXlvdXQpIHtcbiAgICB0aGlzLmxheW91dCA9IGxheW91dFxuICAgIHRoaXMuZWwgPSBsYXlvdXQuYm9keS5lbC5nKCkuYWRkQ2xhc3MoJ211cy1jb250ZW50JylcbiAgICB0aGlzLndpZHRoID0gbGF5b3V0LmJvZHkud2lkdGhcbiAgfVxuXG4gIGdldCB5KCkgeyByZXR1cm4gdGhpcy5feSB9XG4gIHNldCB5KHkpIHtcbiAgICB0aGlzLl95ID0geVxuICAgIHRoaXMuZWwudHJhbnNmb3JtKG1hdHJpeCgpLnRyYW5zbGF0ZSgwLCB5KSlcbiAgICByZXNpemVCb2R5KHRoaXMpXG4gIH1cblxuICBnZXQgd2lkdGgoKSB7IHJldHVybiB0aGlzLl93IH1cbiAgc2V0IHdpZHRoKHcpIHsgdGhpcy5fdyA9IHcgfVxuXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgY29uc3QgbGFzdCA9IHRoaXMuc3lzdGVtc1t0aGlzLnN5c3RlbXMubGVuZ3RoIC0gMV1cbiAgICByZXR1cm4gbGFzdCA/IGxhc3QueSArIGxhc3QuaGVpZ2h0IDogMFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBzY29yZU1lYXN1cmUge211c2plLlRpbWV3aXNlTWVhc3VyZXN9IFRoZSB0aW1ld2lzZSBzY29yZSBtZWFzdXJlLlxuICAgKi9cbiAgZmxvdyhzY29yZU1lYXN1cmVzKSB7XG4gICAgbWFrZVN5c3RlbXModGhpcywgc2NvcmVNZWFzdXJlcylcbiAgICBiYWxhbmNlU3lzdGVtcyh0aGlzKVxuICAgIHRoaXMuc3lzdGVtcy5mb3JFYWNoKHN5c3RlbSA9PiB7IHN5c3RlbS5mbG93KCkgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNpemVCb2R5KHRoYXQpIHtcbiAgY29uc3QgbGF5b3V0ID0gdGhhdC5sYXlvdXRcbiAgY29uc3QgaEhlaWdodCA9IGxheW91dC5oZWFkZXIuaGVpZ2h0XG5cbiAgbGF5b3V0LmJvZHkuaGVpZ2h0ID0gdGhhdC5oZWlnaHQgK1xuICAgICAgICAoaEhlaWdodCA/IGhIZWlnaHQgKyBsYXlvdXQub3B0aW9ucy5oZWFkZXJTZXAgOiAwKVxufVxuXG4vKipcbiAqIERpdmlkZSBtZWFzdXJlcyBpbiB0aW1ld2lzZSBzY29yZSBpbnRvIHRoZSBzeXN0ZW1zLlxuICogQHBhcmFtIHNjb3JlTWVhc3VyZSB7bXVzamUuVGltZXdpc2VNZWFzdXJlc30gVGhlIHRpbWV3aXNlIHNjb3JlIG1lYXN1cmUuXG4gKi9cbmZ1bmN0aW9uIG1ha2VTeXN0ZW1zKHRoYXQsIHNjb3JlTWVhc3VyZXMpIHtcbiAgY29uc3QgeyBsYXlvdXQgfSA9IHRoYXRcbiAgY29uc3QgeyBtZWFzdXJlUGFkZGluZ1JpZ2h0LCBtZWFzdXJlUGFkZGluZ0xlZnQgfSA9IGxheW91dC5vcHRpb25zXG4gIGNvbnN0IG1lYXN1cmVQYWRkaW5nID0gbWVhc3VyZVBhZGRpbmdMZWZ0ICsgbWVhc3VyZVBhZGRpbmdSaWdodFxuICBjb25zdCBzeXN0ZW1zID0gdGhhdC5zeXN0ZW1zID0gW11cbiAgbGV0IHN5c3RlbSA9IG5ldyBTeXN0ZW1MYXlvdXQobGF5b3V0LCAwKVxuICBzeXN0ZW1zLnB1c2goc3lzdGVtKVxuXG4gIHNjb3JlTWVhc3VyZXMuZm9yRWFjaChtZWFzdXJlID0+IHtcbiAgICBjb25zdCBtaW5XaWR0aCA9IG1lYXN1cmUubWluV2lkdGggKyBtZWFzdXJlUGFkZGluZyArXG4gICAgICAgICAgICAgICAgICAobWVhc3VyZS5iYXJMZWZ0SW5TeXN0ZW0ud2lkdGggK1xuICAgICAgICAgICAgICAgICAgIG1lYXN1cmUuYmFyUmlnaHRJblN5c3RlbS53aWR0aCkgLyAyXG5cbiAgICAvLyBDb250aW51ZSBwdXQgdGhpcyBtZWFzdXJlIGluIHRoZSBzeXN0ZW0uXG4gICAgaWYgKHN5c3RlbS5taW5XaWR0aCArIG1pbldpZHRoIDwgdGhhdC53aWR0aCkge1xuICAgICAgc3lzdGVtLm1lYXN1cmVzLnB1c2gobWVhc3VyZSlcblxuICAgIC8vIE5ldyBzeXN0ZW1cbiAgICB9IGVsc2Uge1xuICAgICAgc3lzdGVtID0gbmV3IFN5c3RlbUxheW91dChsYXlvdXQsIHN5c3RlbXMubGVuZ3RoKVxuICAgICAgc3lzdGVtcy5wdXNoKHN5c3RlbSlcbiAgICAgIHN5c3RlbS5tZWFzdXJlcy5wdXNoKG1lYXN1cmUpXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBnZXRNYXhMZW5ndGhTeXN0ZW0odGhhdCkge1xuICBsZXQgbWF4TGVuZ3RoID0gMFxuICBsZXQgc3lzdGVtXG5cbiAgdGhhdC5zeXN0ZW1zLmZvckVhY2goc3lzdGVtID0+IHtcbiAgICBtYXhMZW5ndGggPSBNYXRoLm1heChtYXhMZW5ndGgsIHN5c3RlbS5tZWFzdXJlcy5sZW5ndGgpXG4gIH0pXG5cbiAgLy8gRmluZCB0aGUgZmlyc3QgbWF4IGxlbmd0aCBzeXN0ZW0gYmFja3dhcmQuXG4gIGZvcihsZXQgaSA9IHRoYXQuc3lzdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHN5c3RlbSA9IHRoYXQuc3lzdGVtc1tpXVxuICAgIGlmIChzeXN0ZW0ubWVhc3VyZXMubGVuZ3RoID09PSBtYXhMZW5ndGgpIHJldHVybiBzeXN0ZW1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc05vdEJhbGFuY2FibGUodGhhdCkge1xuICBjb25zdCB7IHN5c3RlbXMsIHdpZHRoIH0gPSB0aGF0XG4gIGNvbnN0IHsgbGVuZ3RoIH0gPSBzeXN0ZW1zXG4gIHJldHVybiBsZW5ndGggPT09IDEgfHwgICAgICAgLy8gb25seSAxIHN5c3RlbVxuICAgIChsZW5ndGggPT09IDIgJiYgc3lzdGVtc1sxXS5taW5XaWR0aCA8IHdpZHRoICogMC40KSAvLyAxIDIvNSBzeXN0ZW1zXG59XG5cbmZ1bmN0aW9uIGJhbGFuY2VTeXN0ZW1zKHRoYXQpIHtcbiAgaWYgKGlzTm90QmFsYW5jYWJsZSh0aGF0KSkgcmV0dXJuXG5cbiAgY29uc3QgeyBzeXN0ZW1zIH0gPSB0aGF0XG4gIGNvbnN0IGxhc3QgPSBzeXN0ZW1zW3N5c3RlbXMubGVuZ3RoIC0gMV1cbiAgbGV0IHN5c3RlbSA9IGdldE1heExlbmd0aFN5c3RlbSh0aGF0KVxuICBsZXQgbmV4dCwgcHJldlxuXG4gIC8vIE1vdmUgbWVhc3VyZXMgZG93biB0byBiYWxhbmNlIHRoZSBsYXN0IHN5c3RlbS5cbiAgd2hpbGUgKGxhc3QubWVhc3VyZXMubGVuZ3RoIDwgc3lzdGVtLm1lYXN1cmVzLmxlbmd0aCAtIDEpIHtcblxuICAgIC8vIE1vdmUgYSBtZWFzdXJlIHRhaWwtdG8taGVhZCBkb3dud2FyZCB0byB0aGUgbGFzdCBtZWFzdXJlLlxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBuZXh0ID0gc3lzdGVtLm5leHRcbiAgICAgIGlmICghbmV4dCkgYnJlYWtcbiAgICAgIG5leHQubWVhc3VyZXMudW5zaGlmdChzeXN0ZW0ubWVhc3VyZXMucG9wKCkpXG4gICAgICBzeXN0ZW0gPSBuZXh0XG4gICAgfVxuICAgIHN5c3RlbSA9IGdldE1heExlbmd0aFN5c3RlbSh0aGF0KVxuICB9XG5cbiAgLy8gTW92ZSBiYWNrIG1lYXN1cmVzIGlmIHRoZSBzeXN0ZW0gZXhjZWVkcyB0aGUgY29udGVudCB3aWR0aC5cbiAgc3lzdGVtID0gbGFzdFxuICB3aGlsZSAoc3lzdGVtKSB7XG4gICAgcHJldiA9IHN5c3RlbS5wcmV2XG4gICAgd2hpbGUgKHN5c3RlbS5taW5XaWR0aCA+IHRoYXQud2lkdGgpIHtcbiAgICAgIHByZXYubWVhc3VyZXMucHVzaChzeXN0ZW0ubWVhc3VyZXMuc2hpZnQoKSlcbiAgICB9XG4gICAgc3lzdGVtID0gcHJldlxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbnRlbnRMYXlvdXRcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZW5kZXJlci9MYXlvdXQvQ29udGVudExheW91dC5qcyIsImltcG9ydCB7IG1hdHJpeCB9IGZyb20gJ3NuYXBzdmcnXG5cbi8qKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7TGF5b3V0fSBsYXlvdXRcbiAqL1xuY2xhc3MgU3lzdGVtTGF5b3V0IHtcbiAgY29uc3RydWN0b3IobGF5b3V0LCBpbmRleCkge1xuICAgIHRoaXMuX2luZGV4ID0gaW5kZXhcbiAgICB0aGlzLl9sYXlvdXQgPSBsYXlvdXRcbiAgICB0aGlzLl9lbCA9IGxheW91dC5jb250ZW50LmVsLmcoKS5hZGRDbGFzcygnbXVzLXN5c3RlbScpXG4gIH1cblxuICBnZXQgZWwoKSB7IHJldHVybiB0aGlzLl9lbCB9XG5cbiAgLyoqXG4gICAqIE1lYXN1cmVzIGluIGEgc3lzdGVtLlxuICAgKiBAdHlwZSB7QXJyYXkuPFRpbWV3aXNlTWVhc3VyZT59XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IG1lYXN1cmVzKCkgeyByZXR1cm4gdGhpcy5fbWVhc3VyZXMgfHwgKHRoaXMuX21lYXN1cmVzID0gW10pIH1cblxuICAvKipcbiAgICogUHJldmlvdXMgc3lzdGVtLlxuICAgKiBAdHlwZSB7U3lzdGVtTGF5b3V0fVxuICAgKi9cbiAgZ2V0IHByZXYoKSB7IHJldHVybiB0aGlzLl9sYXlvdXQuY29udGVudC5zeXN0ZW1zW3RoaXMuX2luZGV4IC0gMV0gfVxuXG4gIC8qKlxuICAgKiBOZXh0IHN5c3RlbS5cbiAgICogQHR5cGUge1N5c3RlbUxheW91dH1cbiAgICovXG4gIGdldCBuZXh0KCkgeyByZXR1cm4gdGhpcy5fbGF5b3V0LmNvbnRlbnQuc3lzdGVtc1t0aGlzLl9pbmRleCArIDFdIH1cblxuICBnZXQgeSgpIHsgcmV0dXJuIHRoaXMuX3kgfVxuICBzZXQgeSh5KSB7XG4gICAgdGhpcy5feSA9IHlcbiAgICB0aGlzLmVsLnRyYW5zZm9ybShtYXRyaXgoKS50cmFuc2xhdGUoMCwgeSkpXG4gIH1cblxuICBnZXQgd2lkdGgoKSB7IHJldHVybiB0aGlzLl9sYXlvdXQuY29udGVudC53aWR0aCB9XG5cbiAgZ2V0IG1pbldpZHRoKCkge1xuICAgIGxldCBtaW4gPSAwXG4gICAgdGhpcy5tZWFzdXJlcy5mb3JFYWNoKG1lYXN1cmUgPT4geyBtaW4gKz0gbWVhc3VyZS5taW5XaWR0aCB9KVxuICAgIHJldHVybiBtaW5cbiAgfVxuXG4gIGdldCBjb250ZW50KCkgeyByZXR1cm4gdGhpcy5fbGF5b3V0LmNvbnRlbnQgfVxuXG4gIGdldCBzeXN0ZW1zKCkgeyByZXR1cm4gdGhpcy5jb250ZW50LnN5c3RlbXMgfVxuXG4gIGZsb3coKSB7XG4gICAgbGV0IG1pbkhlaWdodCA9IDBcbiAgICBsZXQgeCA9IDBcblxuICAgIHR1bmVNZWFzdXJlc1dpZHRocyh0aGlzKVxuXG4gICAgdGhpcy5tZWFzdXJlcy5mb3JFYWNoKChtZWFzdXJlLCBtKSA9PiB7XG4gICAgICBtZWFzdXJlLnN5c3RlbSA9IHRoaXNcbiAgICAgIG1lYXN1cmUuX3NJbmRleCA9IG1cbiAgICAgIG1lYXN1cmUuZmxvdygpXG4gICAgICBtZWFzdXJlLnggPSB4XG4gICAgICB4ICs9IG1lYXN1cmUud2lkdGhcbiAgICAgIG1pbkhlaWdodCA9IE1hdGgubWF4KG1pbkhlaWdodCwgbWVhc3VyZS5taW5IZWlnaHQpXG4gICAgfSlcblxuICAgIGNvbnN0IHsgcHJldiB9ID0gdGhpc1xuICAgIHRoaXMueSA9IHByZXYgPyBwcmV2LnkgKyBwcmV2LmhlaWdodCArIHRoaXMuX2xheW91dC5vcHRpb25zLnN5c3RlbVNlcCA6IDBcbiAgICB0aGlzLmhlaWdodCA9IG1pbkhlaWdodFxuICB9XG59XG5cbmZ1bmN0aW9uIHR1bmVNZWFzdXJlc1dpZHRocyh0aGF0KSB7XG4gIGlmICghaXNUdW5hYmxlKHRoYXQpKSByZXR1cm5cblxuICB2YXIgcGFpcnMgPSBnZXRQYWlycyh0aGF0Lm1lYXN1cmVzKVxuICB2YXIgbGVuZ3RoID0gcGFpcnMubGVuZ3RoXG4gIHZhciB3aWR0aExlZnQgPSB0aGF0LndpZHRoXG4gIHZhciBpdGVtTGVmdCA9IGxlbmd0aFxuICB2YXIgaSA9IDAgICAgLy8gaSArIGl0ZW1MZWZ0ID09PSBsZW5ndGhcbiAgdmFyIHdpZHRoXG5cbiAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICBpZiAod2lkdGhMZWZ0ID49IHBhaXJzW2ldLndpZHRoICogaXRlbUxlZnQpIHtcbiAgICAgIHdpZHRoID0gd2lkdGhMZWZ0IC8gaXRlbUxlZnRcbiAgICAgIGRvIHtcbiAgICAgICAgcGFpcnNbaV0ubWVhc3VyZS53aWR0aCA9IHdpZHRoXG4gICAgICAgIGkrK1xuICAgICAgfSB3aGlsZSAoaSA8IGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gcGFpcnNbaV0ud2lkdGhcbiAgICAgIHBhaXJzW2ldLm1lYXN1cmUud2lkdGggPSB3aWR0aFxuICAgICAgd2lkdGhMZWZ0IC09IHdpZHRoXG4gICAgICBpKytcbiAgICAgIGl0ZW1MZWZ0LS1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNUdW5hYmxlKHRoYXQpIHtcbiAgY29uc3QgY3RXaWR0aCA9IHRoYXQuY29udGVudC53aWR0aFxuICBjb25zdCBzID0gdGhhdC5faW5kZXhcbiAgY29uc3Qgc3NMZW4gPSB0aGF0LnN5c3RlbXMubGVuZ3RoXG4gIHJldHVybiBzc0xlbiA+IDIgfHxcbiAgICAgKHNzTGVuID09PSAxICYmIHRoYXQubWluV2lkdGggPiBjdFdpZHRoICogMC43KSB8fFxuICAgICAoc3NMZW4gPT09IDIgJiYgKHMgPT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgIChzID09PSAxICYmIHRoYXQubWluV2lkdGggPiBjdFdpZHRoICogMC40KSkpXG59XG5cbmNvbnN0IGRlc2NlbmRpbmdTb3J0ID0gKGEsIGIpID0+IGIud2lkdGggLSBhLndpZHRoXG5cbmNvbnN0IGdldFBhaXJzID0gbWVhc3VyZXMgPT4gbWVhc3VyZXMubWFwKG1lYXN1cmUgPT4gKHtcbiAgd2lkdGg6IG1lYXN1cmUubWluV2lkdGgsXG4gIG1lYXN1cmU6IG1lYXN1cmVcbn0pKS5zb3J0KGRlc2NlbmRpbmdTb3J0KVxuXG5leHBvcnQgZGVmYXVsdCBTeXN0ZW1MYXlvdXRcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZW5kZXJlci9MYXlvdXQvU3lzdGVtTGF5b3V0LmpzIiwiaW1wb3J0IHsgbWF0cml4IH0gZnJvbSAnc25hcHN2ZydcblxuZnVuY3Rpb24gcmVuZGVyRG90cyhlbCwgeCwgcmFkaXVzLCBtZWFzdXJlSGVpZ2h0KSB7XG4gIGNvbnN0IGN5ID0gbWVhc3VyZUhlaWdodCAvIDJcbiAgY29uc3QgZHkgPSBtZWFzdXJlSGVpZ2h0ICogMC4xNVxuXG4gIGVsLmNpcmNsZSh4LCBjeSAtIGR5LCByYWRpdXMpXG4gIGVsLmNpcmNsZSh4LCBjeSArIGR5LCByYWRpdXMpXG59XG5cbmZ1bmN0aW9uIHJlbmRlcihiYXIsIG1lYXN1cmUsIGxvKSB7XG4gIGNvbnN0IHsgYmFybGluZURvdFJhZGl1cyB9ID0gbG9cbiAgY29uc3QgeyBoZWlnaHQgfSA9IG1lYXN1cmVcbiAgY29uc3QgZWwgPSBtZWFzdXJlLmVsLmcoKS5hZGRDbGFzcygnbXVzLWJhcmxpbmUnKVxuICBlbC51c2UoYmFyLmRlZi5lbCkudHJhbnNmb3JtKG1hdHJpeCgpLnNjYWxlKDEsIGhlaWdodCkpXG5cbiAgc3dpdGNoIChiYXIudmFsdWUpIHtcbiAgICBjYXNlICdyZXBlYXQtYmVnaW4nOlxuICAgICAgcmVuZGVyRG90cyhlbCwgYmFyLndpZHRoIC0gYmFybGluZURvdFJhZGl1cywgYmFybGluZURvdFJhZGl1cywgaGVpZ2h0KVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdyZXBlYXQtZW5kJzpcbiAgICAgIHJlbmRlckRvdHMoZWwsIGJhcmxpbmVEb3RSYWRpdXMsIGJhcmxpbmVEb3RSYWRpdXMsIGhlaWdodClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAncmVwZWF0LWJvdGgnOlxuICAgICAgcmVuZGVyRG90cyhlbCwgYmFyLndpZHRoIC0gYmFybGluZURvdFJhZGl1cywgYmFybGluZURvdFJhZGl1cywgaGVpZ2h0KVxuICAgICAgcmVuZGVyRG90cyhlbCwgYmFybGluZURvdFJhZGl1cywgYmFybGluZURvdFJhZGl1cywgaGVpZ2h0KVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICB9XG5cbiAgcmV0dXJuIGVsXG59XG5cbmNvbnN0IHRyYW5zbGF0ZSA9IChlbCwgeCkgPT4geyBlbC50cmFuc2Zvcm0obWF0cml4KCkudHJhbnNsYXRlKHgsIDApKSB9XG5cbi8vIEBwYXJhbSBtIHtudW1iZXJ9IE1lYXN1cmUgaW5kZXggaW4gbWVhc3VyZXMuXG4vLyBAcGFyYW0gbGVuIHtudW1iZXJ9IExlbmd0aCBvZiBtZWFzdXJlcy5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlbmRlckJhcihtZWFzdXJlLCBsbykge1xuICBsZXQgYmFyID0gbWVhc3VyZS5iYXJSaWdodEluU3lzdGVtXG4gIGxldCBlbFxuXG4gIGlmIChiYXIuZGVmKSB7XG4gICAgZWwgPSByZW5kZXIoYmFyLCBtZWFzdXJlLCBsbylcblxuICAgIC8vIEFsaWduIGVuZCBpbiBzeXN0ZW0gZW5kLlxuICAgIGlmIChtZWFzdXJlLmluU3lzdGVtRW5kKSB0cmFuc2xhdGUoZWwsIG1lYXN1cmUud2lkdGggLSBiYXIud2lkdGgpXG4gICAgLy8gT3RoZXJzIGFsaWduIG1pZGRsZS5cbiAgICBlbHNlIHRyYW5zbGF0ZShlbCwgbWVhc3VyZS53aWR0aCAtIGJhci53aWR0aCAvIDIpXG4gIH1cblxuICAvLyBSZW5kZXIgcmlnaHQgYmFyIGFuZCBhbGlnbiBiZWdpbiBpbiBzeXN0ZW0gYmVnaW4uXG4gIGlmIChtZWFzdXJlLmluU3lzdGVtQmVnaW4pIHtcbiAgICBiYXIgPSBtZWFzdXJlLmJhckxlZnRJblN5c3RlbVxuICAgIGlmIChiYXIuZGVmKSByZW5kZXIoYmFyLCBtZWFzdXJlLCBsbylcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlbmRlcmVyL1JlbmRlcmVyL3JlbmRlckJhci5qcyIsImltcG9ydCB7IG1hdHJpeCB9IGZyb20gJ3NuYXBzdmcnXG5cbmZ1bmN0aW9uIHJlbmRlckR1cmF0aW9uKG5vdGUsIGxvKSB7XG4gIGNvbnN0IHsgZHVyYXRpb25EZWYsIHBpdGNoRGVmIH0gPSBub3RlLmRlZlxuICBjb25zdCB7IHVuZGVyYmFyIH0gPSBub3RlLmR1cmF0aW9uXG4gIGxldCB5ID0gMFxuXG4gIC8vIFdob2xlIGFuZCBoYWxmIG5vdGVzXG4gIGlmIChub3RlLmR1cmF0aW9uLnR5cGUgPCA0KSB7XG4gICAgbm90ZS5lbC51c2UoZHVyYXRpb25EZWYuZWwpLmF0dHIoe1xuICAgICAgeDogcGl0Y2hEZWYud2lkdGgsXG4gICAgICB5OiBwaXRjaERlZi5zdGVwQ3lcbiAgICB9KVxuXG4gIC8vIFF1YXJ0ZXIgb3Igc2hvcnRlciBub3Rlc1xuICB9IGVsc2Uge1xuXG4gICAgLy8gQWRkIHVuZGVyYmFycyBmb3IgZWlndGggb3Igc2hvcnRlciBub3Rlc1xuICAgIGlmICh1bmRlcmJhcikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1bmRlcmJhcjsgaSsrKSB7XG5cbiAgICAgICAgLy8gT25seSByZW5kZXIgYmVhbSBmb3IgdGhlIGJlZ2luIG9uZS5cbiAgICAgICAgaWYgKG5vdGUuYmVhbXNbaV0pIHtcbiAgICAgICAgICBpZiAobm90ZS5iZWFtc1tpXS52YWx1ZSA9PT0gJ2JlZ2luJykge1xuXG4gICAgICAgICAgICAgIC8vIHJlbmRlciB0aGUgYmFyIGZyb20gdGhlIGJlZ2lubmluZyBub3RlIHRvIHRoZSBlbmRpbmcgbm90ZSBhc3NvY2lhdGVkXG4gICAgICAgICAgICAgIC8vIHdpdGggdGhlIGJlZ2lubmluZyBub3RlLiBZIHN0YW5kcyBmb3IgdGhlIHN0YXJ0aW5nIGhlaWdodC5cbiAgICAgICAgICAgIHJlbmRlclVuZGVyYmFyKG5vdGUsIG5vdGUuYmVhbXNbaV0uZW5kRHVyYWJsZSwgeSwgbG8pXG4gICAgICAgICAgfVxuXG4gICAgICAgIC8vIFVuYmVhbWVkIHVuZGVyYmFyXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL3JlbmRlcnMgc2luZ2xlIG5vdGVcbiAgICAgICAgICByZW5kZXJVbmRlcmJhcihub3RlLCBub3RlLCB5LCBsbylcbiAgICAgICAgfVxuICAgICAgICB5IC09IGxvLnVuZGVyYmFyU2VwXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGRvdHNcbiAgICBpZiAobm90ZS5kdXJhdGlvbi5kb3QpIHtcbiAgICAgIG5vdGUuZWwuZygpLnRyYW5zZm9ybShtYXRyaXgoKS50cmFuc2xhdGUocGl0Y2hEZWYud2lkdGgsIDApKVxuICAgICAgICAudXNlKGR1cmF0aW9uRGVmLmVsKS50cmFuc2Zvcm0ocGl0Y2hEZWYubWF0cml4KVxuICAgIH1cblxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlclVuZGVyYmFyKG5vdGUxLCBub3RlMiwgeSwgbG8pIHtcbiAgbm90ZTEuZWwubGluZSgwLCB5LCBub3RlMi54IC0gbm90ZTEueCArIG5vdGUyLndpZHRoLCB5KVxuICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIGxvLnR5cGVTdHJva2VXaWR0aClcbn1cblxuZXhwb3J0IGRlZmF1bHQgcmVuZGVyRHVyYXRpb25cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZW5kZXJlci9SZW5kZXJlci9yZW5kZXJEdXJhdGlvbi5qcyIsImltcG9ydCB7IGZvcm1hdCB9IGZyb20gJ3NuYXBzdmcnXG5cbmZ1bmN0aW9uIGdldEN1cnZlUGF0aCh4MSwgeTEsIHgyLCB5Mikge1xuICBjb25zdCBkeCA9IHgyIC0geDFcbiAgY29uc3QgZHkgPSB5MiAtIHkxXG4gIGNvbnN0IGMxeCA9IDAgLy8tMC4xICogZHhcbiAgY29uc3QgYzF5ID0gMCAvLy0wLjEgKiBkeVxuICBjb25zdCBjMnggPSBkeCAvLzEuMSAqIGR4XG4gIGNvbnN0IGMyeSA9IGR5IC8vMS4xICogZHlcblxuICByZXR1cm4gZm9ybWF0KCdNe3gxfSx7eTF9Y3tjMXh9LHtjMXl9IHtjMnh9LHtjMnl9IHtkeH0se2R5fWN7YzN4fSx7YzN5fSB7YzR4fSx7YzR5fSB7bmVnRHh9LHtuZWdEeX0nLCB7XG4gICAgeDEsXG4gICAgeTEsXG4gICAgYzF4LFxuICAgIGMxeTogYzF5IC0gOCxcbiAgICBjMngsXG4gICAgYzJ5OiBjMnkgLSA4LFxuICAgIGR4LFxuICAgIGR5LFxuICAgIGMzeDogLWMxeCxcbiAgICBjM3k6IC1jMXkgLSAxMCxcbiAgICBjNHg6IC1jMngsXG4gICAgYzR5OiAtYzJ5IC0gMTAsXG4gICAgbmVnRHg6IC1keCxcbiAgICBuZWdEeTogLWR5XG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJlbmRlckVuZEN1cnZlKG5vdGUsIGVycm9yKSB7XG4gIGNvbnN0IHsgc3RlcEN4OiB4MSwgc3RlcFRvcDogeTEgfSA9IG5vdGUuZGVmLnBpdGNoRGVmXG4gIGNvbnN0IHgyID0gLSBub3RlLnN5c3RlbVggLSAzXG4gIGNvbnN0IGVsID0gbm90ZS5lbC5wYXRoKGdldEN1cnZlUGF0aCh4MSwgeTEsIHgyLCB5MSAtIDMpKVxuXG4gIGlmIChlcnJvcikgZWwuYWRkQ2xhc3MoJ211cy1lcnJvcicpXG4gIHJldHVybiBlbFxufVxuXG5mdW5jdGlvbiByZW5kZXJCZWdpbkN1cnZlKG5vdGUsIGVycm9yKSB7XG4gIGNvbnN0IHsgc3RlcEN4OiB4MSwgc3RlcFRvcDogeTEgfSA9IG5vdGUuZGVmLnBpdGNoRGVmXG4gIGNvbnN0IHgyID0gbm90ZS5zeXN0ZW0ud2lkdGggLSBub3RlLnN5c3RlbVggKyAzXG4gIGNvbnN0IGVsID0gbm90ZS5lbC5wYXRoKGdldEN1cnZlUGF0aCh4MSwgeTEsIHgyLCB5MSAtIDMpKVxuXG4gIGlmIChlcnJvcikgZWwuYWRkQ2xhc3MoJ211cy1lcnJvcicpXG4gIHJldHVybiBlbFxufVxuXG5mdW5jdGlvbiByZW5kZXJDb21wbGV0ZUN1cnZlKG5vdGUxLCBub3RlMiwgZXJyb3IpIHtcbiAgY29uc3QgeyBzdGVwQ3g6IHgxLCBzdGVwVG9wOiB5MSB9ID0gbm90ZTEuZGVmLnBpdGNoRGVmXG4gIGNvbnN0IHsgc3RlcEN4OiB4Miwgc3RlcFRvcDogeTIgfSA9IG5vdGUyLmRlZi5waXRjaERlZlxuICBjb25zdCBub3RlRHggPSBub3RlMi5zeXN0ZW1YIC0gbm90ZTEuc3lzdGVtWFxuICBjb25zdCBlbCA9IG5vdGUxLmVsLnBhdGgoZ2V0Q3VydmVQYXRoKHgxLCB5MSwgbm90ZUR4ICsgeDIsIHkyKSlcblxuICBpZiAoZXJyb3IpIGVsLmFkZENsYXNzKCdtdXMtZXJyb3InKVxuICByZXR1cm4gZWxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVuZGVyQ3VydmUodHlwZSwgbm90ZSkge1xuICBpZiAobm90ZVt0eXBlXS5lbmQpIHtcbiAgICBjb25zdCBwcmV2ID0gbm90ZVt0eXBlXS5wcmV2UGFyZW50XG4gICAgY29uc3QgeyBwcmV2SGFzRXJyb3IgfSA9IG5vdGVbdHlwZV1cblxuICAgIGlmICghcHJldiB8fCBwcmV2LnN5c3RlbSAhPT0gbm90ZS5zeXN0ZW0pIHJlbmRlckVuZEN1cnZlKG5vdGUsIHByZXZIYXNFcnJvcilcbiAgICBlbHNlIGlmIChwcmV2SGFzRXJyb3IpIHJlbmRlckNvbXBsZXRlQ3VydmUobm90ZSwgcHJldiwgcHJldkhhc0Vycm9yKVxuICB9XG5cbiAgaWYgKG5vdGVbdHlwZV0uYmVnaW4pIHtcbiAgICBjb25zdCBuZXh0ID0gbm90ZVt0eXBlXS5uZXh0UGFyZW50XG4gICAgY29uc3QgeyBuZXh0SGFzRXJyb3IgfSA9IG5vdGVbdHlwZV1cblxuICAgIGlmICghbmV4dCB8fCBuZXh0LnN5c3RlbSAhPT0gbm90ZS5zeXN0ZW0pIHJlbmRlckJlZ2luQ3VydmUobm90ZSwgbmV4dEhhc0Vycm9yKVxuICAgIGVsc2UgcmVuZGVyQ29tcGxldGVDdXJ2ZShub3RlLCBuZXh0LCBuZXh0SGFzRXJyb3IpXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZW5kZXJlci9SZW5kZXJlci9yZW5kZXJDdXJ2ZS5qcyIsImltcG9ydCBNSURJIGZyb20gJ01JREknXG5cbmNvbnN0IHRpbWVvdXRzID0gW11cblxuY29uc3QgUGxheWVyTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHBsYXlpbmcgdGhlIHNvbmcuXG4gICAqL1xuICBwbGF5KCkge1xuICAgIGNvbnN0IHsgbWVhc3VyZXMgfSA9IHRoaXMucGFydHNbMF1cbiAgICB2YXIgdGltZSA9IDAgLy9hdWRpb0N0eC5jdXJyZW50VGltZVxuXG4gICAgbWVhc3VyZXMuZm9yRWFjaChjZWxsID0+IHtcbiAgICAgIGNlbGwuZGF0YS5mb3JFYWNoKGRhdGEgPT4ge1xuICAgICAgICBzd2l0Y2ggKGRhdGEuJHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdub3RlJzpcbiAgICAgICAgICAgIC8vIHBsYXlOb3RlKHRpbWUsIGR1ciwgZnJlcSlcbiAgICAgICAgICAgIHRpbWVvdXRzLnB1c2gobWlkaVBsYXlOb3RlKGRhdGEsIHRpbWUpKVxuICAgICAgICAgICAgdGltZSArPSBkYXRhLmR1cmF0aW9uLnNlY29uZFxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlICdyZXN0JzpcbiAgICAgICAgICAgIHRpbWUgKz0gZGF0YS5kdXJhdGlvbi5zZWNvbmRcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9LFxuXG4gIC8qKlxuICAgKiBTdG9wIHBsYXlpbmcgdGhlIHNvbmcuXG4gICAqL1xuICBzdG9wKCkge1xuICAgIHRpbWVvdXRzLmZvckVhY2godGltZW91dCA9PiB7IGNsZWFyVGltZW91dCh0aW1lb3V0KSB9KVxuICAgIHRpbWVvdXRzLmxlbmd0aCA9IDBcbiAgfVxufVxuXG4vLyBpZiAod2luZG93LkF1ZGlvQ29udGV4dCkge1xuLy8gICB2YXIgYXVkaW9DdHggPSBuZXcgd2luZG93LkF1ZGlvQ29udGV4dCgpXG4vLyAgIHZhciBnYWluTm9kZSA9IGF1ZGlvQ3R4LmNyZWF0ZUdhaW4oKVxuLy8gICBnYWluTm9kZS5jb25uZWN0KGF1ZGlvQ3R4LmRlc3RpbmF0aW9uKVxuLy8gICBnYWluTm9kZS5nYWluLnZhbHVlID0gMC41ICAvLyBzZXQgdGhlIHZvbHVtZVxuLy8gfVxuXG4vLyAvLyB2YXIgb3NjaWxsYXRvciA9IGF1ZGlvQ3R4LmNyZWF0ZU9zY2lsbGF0b3IoKVxuLy8gLy8gb3NjaWxsYXRvci5jb25uZWN0KGdhaW5Ob2RlKVxuLy8gLy8gb3NjaWxsYXRvci50eXBlID0gJ3NxdWFyZScgLy8gc2luZSB8IHNxdWFyZSB8IHNhd3Rvb3RoIHwgdHJpYW5nbGUgfCBjdXN0b21cblxuLy8gZnVuY3Rpb24gcGxheU5vdGUodGltZSwgZHVyLCBmcmVxKSB7XG4vLyAgIGlmICghYXVkaW9DdHgpIHsgcmV0dXJuIH1cblxuLy8gICB2YXIgb3NjaWxsYXRvciA9IGF1ZGlvQ3R4LmNyZWF0ZU9zY2lsbGF0b3IoKVxuLy8gICBvc2NpbGxhdG9yLnR5cGUgPSAnc2luZSdcbi8vICAgb3NjaWxsYXRvci5jb25uZWN0KGF1ZGlvQ3R4LmRlc3RpbmF0aW9uKVxuLy8gICBvc2NpbGxhdG9yLmZyZXF1ZW5jeS52YWx1ZSA9IGZyZXFcbi8vICAgb3NjaWxsYXRvci5zdGFydCh0aW1lKVxuLy8gICBvc2NpbGxhdG9yLnN0b3AodGltZSArIGR1ciAtIDAuMDUpXG4vLyB9XG5cbmZ1bmN0aW9uIG1pZGlQbGF5Tm90ZShub3RlLCB0aW1lKSB7XG4gIGNvbnN0IHsgbWlkaU51bWJlciB9ID0gbm90ZS5waXRjaFxuICBjb25zdCBkdXIgPSBub3RlLmR1cmF0aW9uLnNlY29uZFxuXG4gIGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgaWYgKCFub3RlLnRpZS5wcmV2UGFyZW50IHx8IG5vdGUudGllLnByZXZIYXNFcnJvcikge1xuICAgICAgTUlESS5ub3RlT24oMCwgbWlkaU51bWJlciwgMTAwLCAwKVxuICAgIH1cbiAgICBpZiAoIW5vdGUudGllLm5leHRQYXJlbnQgfHwgbm90ZS50aWUubmV4dEhhc0Vycm9yKSB7XG4gICAgICBNSURJLm5vdGVPZmYoMCwgbWlkaU51bWJlciwgZHVyKVxuICAgIH1cbiAgICBub3RlLmVsLmFkZENsYXNzKCdtdXMtcGxheWluZycpXG4gICAgc2V0VGltZW91dCgoKSA9PiB7IG5vdGUuZWwucmVtb3ZlQ2xhc3MoJ211cy1wbGF5aW5nJykgfSwgZHVyICogODAwICsgMTAwKVxuICAgIGNvbnNvbGUubG9nKCdQbGF5OiAnICsgbm90ZSwgdGltZSwgZHVyLCBtaWRpTnVtYmVyKVxuICB9XG5cbiAgcmV0dXJuIHNldFRpbWVvdXQocGxheSwgdGltZSAqIDgwMClcbn1cblxuZXhwb3J0IGRlZmF1bHQgUGxheWVyTWl4aW5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wbGF5ZXIvUGxheWVyTWl4aW4uanMiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNDJfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcIk1JRElcIlxuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==